<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8">
  
  <title>View机制深入学习（五） 事件处理机制一 | Liuyunyicai</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="以TouchEvent为主，看一下View和ViewGroup内部是如何处理Input Events的；首先来看事件的产生来源：
一、获取事件:事件的来源可以分为“软件”，“硬件”两种；主要的事件包含有：按键事件（KeyEvent）    :即物理按键按下产生的事件，相关的常用物理按键一般有HOME,BACK等触摸事件（TouchEvent）:鼠标事件（MouseEvent）、轨迹球事件（Trac">
<meta property="og:type" content="article">
<meta property="og:title" content="View机制深入学习（五） 事件处理机制一">
<meta property="og:url" content="http://liuyunyicai.github.io/2016/05/10/View机制深入学习（五） 事件处理机制一/index.html">
<meta property="og:site_name" content="Liuyunyicai">
<meta property="og:description" content="以TouchEvent为主，看一下View和ViewGroup内部是如何处理Input Events的；首先来看事件的产生来源：
一、获取事件:事件的来源可以分为“软件”，“硬件”两种；主要的事件包含有：按键事件（KeyEvent）    :即物理按键按下产生的事件，相关的常用物理按键一般有HOME,BACK等触摸事件（TouchEvent）:鼠标事件（MouseEvent）、轨迹球事件（Trac">
<meta property="og:image" content="http://chuantu.biz/t4/12/1462870025x3738746571.png">
<meta property="og:updated_time" content="2016-05-10T09:32:15.696Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="View机制深入学习（五） 事件处理机制一">
<meta name="twitter:description" content="以TouchEvent为主，看一下View和ViewGroup内部是如何处理Input Events的；首先来看事件的产生来源：
一、获取事件:事件的来源可以分为“软件”，“硬件”两种；主要的事件包含有：按键事件（KeyEvent）    :即物理按键按下产生的事件，相关的常用物理按键一般有HOME,BACK等触摸事件（TouchEvent）:鼠标事件（MouseEvent）、轨迹球事件（Trac">
<meta name="twitter:image" content="http://chuantu.biz/t4/12/1462870025x3738746571.png">
  
    <link rel="alternative" href="/atom.xml" title="Liuyunyicai" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
      <link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet">
  
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/clipboard.js/1.5.9/clipboard.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
          fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
          scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.0.9/scrollreveal.min.js"
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/liuyunyicai.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">流云易采</a></h1>
        </hgroup>

        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">文章列表</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/979724798@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" target="_blank" href="http://blog.csdn.net/woliuyunyicai" title="CSDN"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">Android,Java</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">流云易采</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/liuyunyicai.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">流云易采</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">文章列表</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/979724798@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" target="_blank" href="http://blog.csdn.net/woliuyunyicai" title="CSDN"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-View机制深入学习（五） 事件处理机制一" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/10/View机制深入学习（五） 事件处理机制一/" class="article-date">
      <time datetime="2016-05-10T09:28:45.538Z" itemprop="datePublished">2016-05-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      View机制深入学习（五） 事件处理机制一
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>以TouchEvent为主，看一下View和ViewGroup内部是如何处理Input Events的；<br>首先来看事件的产生来源：</p>
<h1 id="一、获取事件"><a href="#一、获取事件" class="headerlink" title="一、获取事件:"></a>一、获取事件:</h1><p>事件的来源可以分为“软件”，“硬件”两种；<br>主要的事件包含有：<br><strong>按键事件（KeyEvent）</strong>    :即物理按键按下产生的事件，相关的常用物理按键一般有HOME,BACK等<br><strong>触摸事件（TouchEvent）</strong>:<br>鼠标事件（MouseEvent）、轨迹球事件（TrackBallEvent）（这两个已经不常见）；</p>
<p>针对所有事件的共性抽象出了InputEvent接口；其有两个子类：KeyEvent,MotionEvent;</p>
<h2 id="1、事件的投递流程："><a href="#1、事件的投递流程：" class="headerlink" title="1、事件的投递流程："></a>1、事件的投递流程：</h2><p><img src="http://chuantu.biz/t4/12/1462870025x3738746571.png" alt="enter image description here"></p>
<p><strong>1&gt;源信息采集</strong><br>    对“硬件源”产生的原始信息进行收集；它需要Linux内核驱动的支持，Android系统通过/dev/input下的节点来访问当前发生的事件。<br><strong>2&gt;前期处理</strong><br>    对收集到信息进行筛选以及格式转化<br><strong>3&gt;WMS分配</strong><br>    WMS是窗口的Manager，同时也是InputEvent的派发者。<br><strong>4&gt;应用程序处理</strong><br>    WMS会先把事件传递到对应ViewRootImpl，ViewRootImpl分发事件，传递给相应的DecorView,DecorView在调用Activity中的Window.Callback将事件传递给Activity；然后Activity在通过dispatchTouchEvent分发事件，下面就来到熟悉的View事件分发机制；具体见<a href="http://blog.csdn.net/woliuyunyicai/article/details/49866177" target="_blank" rel="external">《View机制深入学习（四）View的事件分发机制》</a></p>
<h2 id="2、InputManagerService启动"><a href="#2、InputManagerService启动" class="headerlink" title="2、InputManagerService启动:"></a>2、InputManagerService启动:</h2><p>InputManagerService同样也是有SystemServer进程启动，这个在<a href="http://blog.csdn.net/woliuyunyicai/article/details/47749009" target="_blank" rel="external">Android启动过程——init.rc,Zygote,SystemServer</a>中已经提到过，<br>系统启动后创建init进程（pid=1）,init进程创建出Zygote进程，然后Zygote进程孵化出SystemServer进程，在SystemServer进程中创建IMS：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@path</span>: \frameworks\base\services\java\com\android\server\SystemServer.java */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以看到IMS和WMS是紧密相关的</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// @value InputManagerService inputManager</span></span><br><span class="line">        inputManager = <span class="keyword">new</span> InputManagerService(context, wmHandler);</span><br><span class="line"></span><br><span class="line">        Slog.i(TAG, <span class="string">"Window Manager"</span>);</span><br><span class="line">        <span class="comment">// @value WindowManagerService wm</span></span><br><span class="line">        wm = WindowManagerService.main(context, power, display, inputManager,</span><br><span class="line">                uiHandler, wmHandler,</span><br><span class="line">                factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">                !firstBoot, onlyCore);</span><br><span class="line">        ServiceManager.addService(Context.WINDOW_SERVICE, wm);</span><br><span class="line">        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);</span><br><span class="line"></span><br><span class="line">        ActivityManagerService.self().setWindowManager(wm);</span><br><span class="line"></span><br><span class="line">        inputManager.setWindowManagerCallbacks(wm.getInputMonitor());</span><br><span class="line">        inputManager.start();</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、InputMangerService："><a href="#3、InputMangerService：" class="headerlink" title="3、InputMangerService："></a>3、InputMangerService：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\java\com\android\server\input\InputManagerService.java **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputManagerService</span> <span class="keyword">extends</span> <span class="title">IInputManager</span>.<span class="title">Stub</span> <span class="keyword">implements</span> <span class="title">Watchdog</span>.<span class="title">Monitor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指向native端IMS类对象的地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> mPtr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputManagerService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">        <span class="keyword">this</span>.mHandler = <span class="keyword">new</span> InputManagerHandler(DisplayThread.get().getLooper());</span><br><span class="line"></span><br><span class="line">        mUseDevInputEventForAudioJack = context.getResources().getBoolean(R.bool.config_useDevInputEventForAudioJack);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建native IMS对象</span></span><br><span class="line">        mPtr = nativeInit(<span class="keyword">this</span>, mContext, mHandler.getLooper().getQueue());</span><br><span class="line"></span><br><span class="line">        LocalServices.addService(InputManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到Java层的IMS实际上只是对Native层的InputManager的一层包装；其创建主要是native层进行创建，并把native层的InputManager地址赋值给InputManagerService的mPtr变量；<br>而且注意nativeInit中传入了Looper中的MessageQueue变量；</p>
<h2 id="4、native层的InputManagerService——NativeInputManager类："><a href="#4、native层的InputManagerService——NativeInputManager类：" class="headerlink" title="4、native层的InputManagerService——NativeInputManager类："></a>4、native层的InputManagerService——NativeInputManager类：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span></span><br><span class="line"><span class="keyword">class</span> NativeInputManager : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase,</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> InputReaderPolicyInterface,</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> InputDispatcherPolicyInterface,</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> PointerControllerPolicyInterface</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz,</span><br><span class="line">                        jobject serviceObj, jobject contextObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个Message Queue</span></span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"MessageQueue is not initialized."</span>);</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以看到NativeInputManager中包含有一个Looper，用以进行事件分派</span></span><br><span class="line">    NativeInputManager* im = new NativeInputManager(contextObj, serviceObj,</span><br><span class="line">            messageQueue-&gt;getLooper());</span><br><span class="line">    im-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 返回创建的IMS实例对象的地址（强制转化为long类型）</span></span><br><span class="line">    return <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(im);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到首先通过android_os_MessageQueue_getMessageQueue函数获取到本地端的MessageQueue，这个在Handler机制中的本地解析<a href="http://blog.csdn.net/woliuyunyicai/article/details/50780529" target="_blank" rel="external">《Handler机制深入解析》</a>中已经提到，该NativeMessageQueue对象在java层创建Looper时创建实例，然后将地址指针赋值为Looper对应的MessageQueue中的ptr变量中，这里根据指针来获取该NativeMessageQueue对象；<br>根据NativeMessageQueue对象获取其中对应的Looper（native），用以创建NativeInputManger;来看NativeInputManager的构造函数：</p>
<h2 id="5、NativeInputManager-NativeInputManager"><a href="#5、NativeInputManager-NativeInputManager" class="headerlink" title="5、NativeInputManager#NativeInputManager:"></a>5、NativeInputManager#NativeInputManager:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span></span><br><span class="line">NativeInputManager::NativeInputManager(jobject contextObj,</span><br><span class="line">                                       jobject serviceObj, <span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper) :</span><br><span class="line">        mLooper(looper), mInteractive(<span class="literal">true</span>) &#123;</span><br><span class="line">    JNIEnv* env = jniEnv();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局引用</span></span><br><span class="line">    mContextObj = env-&gt;NewGlobalRef(contextObj);</span><br><span class="line">    mServiceObj = env-&gt;NewGlobalRef(serviceObj);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mLocked.systemUiVisibility = ASYSTEM_UI_VISIBILITY_STATUS_BAR_VISIBLE;</span><br><span class="line">        mLocked.pointerSpeed = <span class="number">0</span>;</span><br><span class="line">        mLocked.pointerGesturesEnabled = <span class="literal">true</span>;</span><br><span class="line">        mLocked.showTouches = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建EventHUb</span></span><br><span class="line">    sp&lt;EventHub&gt; eventHub = new EventHub();</span><br><span class="line">    <span class="comment">// 创建InputManager实例</span></span><br><span class="line">    mInputManager = new InputManager(eventHub, this, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NativeInputManager中保存了Looper(native)实例；并且创建了EventHub，以及InputManager两个重要的对象；<br>EventHub从名字就可以看出，它是用来收集以及存储外部的输入事件的；<br>而InputManager则是对Event事件进行处理分发；<br>先来看EventHub：</p>
<h3 id="（一）EventHub："><a href="#（一）EventHub：" class="headerlink" title="（一）EventHub："></a>（一）EventHub：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*\frameworks\native\services\inputflinger\EventHub*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *DEVICE_PATH = <span class="string">"/dev/input"</span>;</span><br><span class="line">EventHub::EventHub(<span class="keyword">void</span>) :</span><br><span class="line">        mBuiltInKeyboardId(NO_BUILT_IN_KEYBOARD), mNextDeviceId(<span class="number">1</span>), mControllerNumbers(),</span><br><span class="line">        mOpeningDevices(<span class="number">0</span>), mClosingDevices(<span class="number">0</span>),</span><br><span class="line">        mNeedToSendFinishedDeviceScan(<span class="literal">false</span>),</span><br><span class="line">        mNeedToReopenDevices(<span class="literal">false</span>), mNeedToScanDevices(<span class="literal">true</span>),</span><br><span class="line">        mPendingEventCount(<span class="number">0</span>), mPendingEventIndex(<span class="number">0</span>), mPendingINotify(<span class="literal">false</span>) &#123;</span><br><span class="line">    acquire_wake_lock(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建epoll对象</span></span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用inotify机制监听文件或目录的移动、读取、写入或删除等事件</span></span><br><span class="line">    <span class="comment">// 创建一个inotify对象</span></span><br><span class="line">    mINotifyFd = inotify_init();</span><br><span class="line">    <span class="comment">// 把监控项添加到mINotifyFd对象的监控列表中</span></span><br><span class="line">    <span class="comment">// 这里监听的文件路径为"/dev/input"</span></span><br><span class="line">    <span class="keyword">int</span> result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> epoll_event eventItem;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(eventItem));</span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_INOTIFY;</span><br><span class="line">    <span class="comment">// 把inotify对象mINotifyFd添加到epoll对象的兴趣列表中，此处采用inotify与epoll机制结合起来检查文件</span></span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> wakeFds[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 创建pipe</span></span><br><span class="line">    result = pipe(wakeFds);</span><br><span class="line"></span><br><span class="line">    mWakeReadPipeFd = wakeFds[<span class="number">0</span>];</span><br><span class="line">    mWakeWritePipeFd = wakeFds[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 设置为非阻塞</span></span><br><span class="line">    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_WAKE;</span><br><span class="line">    <span class="comment">// 添加到epoll的兴趣列表中</span></span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> major, minor;</span><br><span class="line">    getLinuxRelease(&amp;major, &amp;minor);</span><br><span class="line">    <span class="comment">// EPOLLWAKEUP was introduced in kernel 3.5</span></span><br><span class="line">    mUsingEpollWakeup = major &gt; <span class="number">3</span> || (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面进行了一系列的变量的初始化；<br>然后epoll_create创建了一个epoll对象，可以看到和Handler中一样，IMS中也用到了epoll机制进行监听；<br>而后可以看到IMS是INotify机制和Epoll机制同时使用的：inotify_init创建iNotify对象，inotify_add_watch则将”/dev/input”路径添加到监听列表中；当”/dev/input”中文件发生变化，将会产生响应；<br>了解INotifiy文件系统监听机制：<br><a href="https://www.ibm.com/developerworks/cn/linux/l-inotifynew/" target="_blank" rel="external">《inotify – Linux 2.6 内核中的文件系统变化通知机制》</a><br><a href="http://www.infoq.com/cn/articles/inotify-linux-file-system-event-monitoring" target="_blank" rel="external">《Inotify: 高效、实时的Linux文件系统事件监控框架》</a><br>然后将iNotify对象添加到Epoll的兴趣列表中，进行监听；<br>然后同Handler机制，创建一个Pipe，然后设置为非阻塞形式，然后添加到epoll的兴趣列表中；下面就注意在何时调用epoll_wait来开启监听即可；这里仅进行了初始化；</p>
<h3 id="（二）InputManager："><a href="#（二）InputManager：" class="headerlink" title="（二）InputManager："></a>（二）InputManager：</h3><h4 id="1）构造函数："><a href="#1）构造函数：" class="headerlink" title="1）构造函数："></a>1）构造函数：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputManager.cpp **/</span></span><br><span class="line"><span class="keyword">class</span> InputManagerInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    sp&lt;InputReaderInterface&gt; mReader;</span><br><span class="line">    sp&lt;InputReaderThread&gt; mReaderThread;</span><br><span class="line"></span><br><span class="line">    sp&lt;InputDispatcherInterface&gt; mDispatcher;</span><br><span class="line">    sp&lt;InputDispatcherThread&gt; mDispatcherThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    InputManager::InputManager(</span><br><span class="line">            <span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;</span><br><span class="line">        <span class="comment">// 创建InputDispatcher</span></span><br><span class="line">        mDispatcher = new InputDispatcher(dispatcherPolicy);</span><br><span class="line">        <span class="comment">// 创建InputReader</span></span><br><span class="line">        mReader = new InputReader(eventHub, readerPolicy, mDispatcher);</span><br><span class="line">        initialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 进行初始化 **/</span></span><br><span class="line">    <span class="keyword">void</span> InputManager::initialize() &#123;</span><br><span class="line">        <span class="comment">// 创建两个Thread的实例</span></span><br><span class="line">        mReaderThread = new InputReaderThread(mReader);</span><br><span class="line">        mDispatcherThread = new InputDispatcherThread(mDispatcher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>InputManager中传入了前面创建的EventHub对象；然后初始化了两个中重要的类，InputDispatcher，以及InputReader;<br>显然从名字可以看出 InputReader用来读取EventHub中的事件，然后通过InputDiapatcher进行分发（InputReader中持有InputDisptcher的引用）；</p>
<p><strong>先看InputDispatcher:</strong></p>
<h5 id="1-1）InputDispatcher"><a href="#1-1）InputDispatcher" class="headerlink" title="1.1）InputDispatcher:"></a>1.1）InputDispatcher:</h5><p><strong>继承关系：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> InputDispatcher : <span class="keyword">public</span> InputDispatcherInterface</span><br><span class="line"><span class="keyword">class</span> InputDispatcherInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase, <span class="keyword">public</span> InputListenerInterface</span><br></pre></td></tr></table></figure>
<p><strong>构造函数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line">InputDispatcher::InputDispatcher(<span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy) :</span><br><span class="line">    mPolicy(policy),</span><br><span class="line">    mPendingEvent(<span class="literal">NULL</span>), mAppSwitchSawKeyDown(<span class="literal">false</span>), mAppSwitchDueTime(LONG_LONG_MAX),</span><br><span class="line">    mNextUnblockedEvent(<span class="literal">NULL</span>),</span><br><span class="line">    mDispatchEnabled(<span class="literal">false</span>), mDispatchFrozen(<span class="literal">false</span>), mInputFilterEnabled(<span class="literal">false</span>),</span><br><span class="line">    mInputTargetWaitCause(INPUT_TARGET_WAIT_CAUSE_NONE) &#123;</span><br><span class="line">    <span class="comment">// 可以看到这里创建了一个Looper</span></span><br><span class="line">    mLooper = new Looper(false);</span><br><span class="line"></span><br><span class="line">    mKeyRepeatState.lastKeyEntry = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    policy-&gt;getDispatcherConfiguration(&amp;mConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造函数中创建了一个Looper（native），注意这里是新创建了一个Looper对象，和ThreadLocal中该线程中的Looper是没有关系的；<br>再来看InputReader</p>
<h5 id="1-2）InputReader："><a href="#1-2）InputReader：" class="headerlink" title="1.2）InputReader："></a>1.2）InputReader：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> InputReader : <span class="keyword">public</span> InputReaderInterface</span><br><span class="line"><span class="keyword">class</span> InputReaderInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</span><br></pre></td></tr></table></figure>
<p><strong>构造函数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputReader.cpp **/</span></span><br><span class="line">InputReader::InputReader(<span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub, <span class="comment">// 前面提到的创建的EventHub</span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; policy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) :           <span class="comment">// 即传入进来的InputDispatcher</span></span><br><span class="line">        mContext(<span class="keyword">this</span>), mEventHub(eventHub), mPolicy(policy),   <span class="comment">// 一系列初始化</span></span><br><span class="line">        mGlobalMetaState(<span class="number">0</span>), mGeneration(<span class="number">1</span>),</span><br><span class="line">        mDisableVirtualKeysTimeout(LLONG_MIN), mNextTimeout(LLONG_MAX),</span><br><span class="line">        mConfigurationChangesToRefresh(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个QueuedInputListener对象，赋值给mQueuedListener</span></span><br><span class="line">    mQueuedListener = new QueuedInputListener(listener);</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        refreshConfigurationLocked(<span class="number">0</span>);</span><br><span class="line">        updateGlobalMetaStateLocked();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InputReader中包含了前面创建的EventHub，以及用以分发事件的InputDispatcher;在InputReader内部，将其封装成了QueuedInputListener类；</p>
<p>继续InputManager构造函数中内容，initialize进行初始化：</p>
<h4 id="2）InputManager-initialize"><a href="#2）InputManager-initialize" class="headerlink" title="2）InputManager#initialize:"></a>2）InputManager#initialize:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 进行初始化 **/</span></span><br><span class="line"><span class="keyword">void</span> InputManager::initialize() &#123;</span><br><span class="line"><span class="comment">// 创建两个Thread的实例</span></span><br><span class="line">mReaderThread = new InputReaderThread(mReader);</span><br><span class="line">    mDispatcherThread = new InputDispatcherThread(mDispatcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新创建了两个对象，这两个类都是继承Thread的，即对应地使用InputReader，以及InputDispatcher为参数创建了两个线程；<br>分别来看：</p>
<h5 id="2-1-gt-InputReaderThread："><a href="#2-1-gt-InputReaderThread：" class="headerlink" title="2.1&gt; InputReaderThread："></a>2.1&gt; InputReaderThread：</h5><p><strong>2.1.1）InputReaderThread类：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputReader.h **/</span></span><br><span class="line"><span class="comment">/** 无限循环从event hub中读取event,然后读取processes他们  */</span></span><br><span class="line"><span class="keyword">class</span> InputReaderThread : <span class="keyword">public</span> Thread &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    InputReaderThread(<span class="keyword">const</span> sp&lt;InputReaderInterface&gt;&amp; reader);</span><br><span class="line">    <span class="keyword">virtual</span> ~InputReaderThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    sp&lt;InputReaderInterface&gt; mReader;</span><br><span class="line">    <span class="comment">/** 继承Thread的子类必须实现该函数，因为这个其实是Thread的真正执行函数 **/</span></span><br><span class="line">    <span class="comment">// Derived class must implement threadLoop(). The thread starts its life</span></span><br><span class="line">    <span class="comment">// here. There are two ways of using the Thread object:</span></span><br><span class="line">    <span class="comment">// 1) loop: if threadLoop() returns true, it will be called again if</span></span><br><span class="line">    <span class="comment">//          requestExit() wasn't called.</span></span><br><span class="line">    <span class="comment">// 2) once: if threadLoop() returns false, the thread will exit upon return.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到InputReaderThread是一个Thread类，它的线程函数入口为threadLoop;</p>
<p><strong>2.1.2）InputReaderThread类构造函数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputReader.cpp **/</span></span><br><span class="line">    InputReaderThread::InputReaderThread(<span class="keyword">const</span> sp&lt;InputReaderInterface&gt;&amp; reader) :</span><br><span class="line">    Thread(<span class="comment">/*canCallJava*/</span><span class="literal">true</span>), mReader(reader) &#123;</span><br><span class="line">        <span class="comment">// 这里初始化重要变量sp&lt;InputReaderInterface&gt; mReader</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> InputReaderThread::threadLoop() &#123;</span><br><span class="line">        <span class="comment">// 调用mReader中的loopOnce函数，可以看出InputReaderInterface是该类的核心</span></span><br><span class="line">        mReader-&gt;loopOnce();</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>InputReaderThread的核心逻辑为调用InputReader的loopOnce函数；暂且停在这里，因为Thread只是创建，并未运行，等分析到具体运行代码时再作分析；</p>
<h5 id="2-2-gt-InputDispatcherThread"><a href="#2-2-gt-InputDispatcherThread" class="headerlink" title="2.2&gt;InputDispatcherThread"></a>2.2&gt;InputDispatcherThread</h5><p>/<strong> \frameworks\native\services\inputflinger\InputDispatcher.h </strong>/</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> InputDispatcherThread : <span class="keyword">public</span> Thread &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">InputDispatcherThread</span><span class="params">(<span class="keyword">const</span> sp&lt;InputDispatcherInterface&gt;&amp; dispatcher)</span></span>;</span><br><span class="line">    ~InputDispatcherThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">boolthreadLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    sp&lt;InputDispatcherInterface&gt; mDispatcher;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> InputDispatcherThread::threadLoop() &#123;</span><br><span class="line">    mDispatcher-&gt;dispatchOnce();</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 该类同样是一个Thread，其主要运行逻辑即调用InputDispatcher中的dispatchOnce函数；</p>
<p>回到InputManagerService在SystemServer进程中的创建过程知道，接下来创建WindowManagerService，然后将InputManagerService实例传递给WMS，然后调用InputManagerService.start开始工作。</p>
<h2 id="7、InputManagerService-start"><a href="#7、InputManagerService-start" class="headerlink" title="7、InputManagerService#start:"></a>7、InputManagerService#start:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\java\com\android\server\input\InputManagerService.java **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    nativeStart(mPtr);</span><br><span class="line">    <span class="comment">// Add ourself to the Watchdog monitors.</span></span><br><span class="line">    Watchdog.getInstance().addMonitor(<span class="keyword">this</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以看到start仅是对nativeStart本地方法进行封装，继续通过JNI来调用本地端的start函数；注意这里创建了WatchDog看门狗线程，并且把InputManagerService实例添加到WatchDog的监听；系统创建看门狗线程，每隔一段时间向管道中写入数据唤醒InputReader线程（后面会提到）去读取事件，看门狗WatchDog实际上也是一个线程，只不过会定时发送消息给InputReader线程读取输入事件。</p>
<h2 id="8、NativeInputManager-nativeStart"><a href="#8、NativeInputManager-nativeStart" class="headerlink" title="8、NativeInputManager#nativeStart:"></a>8、NativeInputManager#nativeStart:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ptr为创建的IMS实例的地址，这里将其强制转化成为NativeInputManager类</span></span><br><span class="line">    NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里进一步调用InputManager的star方法</span></span><br><span class="line">    <span class="keyword">status_t</span> result = im-&gt;getInputManager()-&gt;start();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Input manager could not be started."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @value sp&lt;InputManager&gt; mInputManager;</span></span><br><span class="line"><span class="keyword">inline</span> sp&lt;InputManager&gt; getInputManager() <span class="keyword">const</span> &#123; return mInputManager; &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里进一步调用了InputManager的start方法；IMS在Native层的主要实现实体其实是InputManager。</p>
<h2 id="9、InputManager-start："><a href="#9、InputManager-start：" class="headerlink" title="9、InputManager#start："></a>9、InputManager#start：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputManager.cpp **/</span></span><br><span class="line"><span class="keyword">class</span> InputManagerInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    sp&lt;InputReaderInterface&gt; mReader;</span><br><span class="line">    sp&lt;InputReaderThread&gt; mReaderThread;</span><br><span class="line"></span><br><span class="line">    sp&lt;InputDispatcherInterface&gt; mDispatcher;</span><br><span class="line">    sp&lt;InputDispatcherThread&gt; mDispatcherThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start函数</span></span><br><span class="line">    <span class="keyword">status_t</span> InputManager::start() &#123;</span><br><span class="line">        <span class="comment">// 可以看到这里会开启两个线程mDispatcherThread，与mReaderThread</span></span><br><span class="line">        <span class="comment">// 分别对应InputReaderThread，InputDispatcherThread</span></span><br><span class="line">        <span class="keyword">status_t</span> result = mDispatcherThread-&gt;run(<span class="string">"InputDispatcher"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">        ......</span><br><span class="line">        result = mReaderThread-&gt;run(<span class="string">"InputReader"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            mDispatcherThread-&gt;requestExit();</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        return OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  回到InputManager中来，来看start函数中所做的工作，在start中调用两个thread的run函数正是开启线程；由Thread的线程入口为threadLoop；前面已经提到了这两个Thread的入口函数，这里来看其中的具体工作逻辑；</p>
<h2 id="10、InputDispatcherThread-amp-InputReaderThread"><a href="#10、InputDispatcherThread-amp-InputReaderThread" class="headerlink" title="10、InputDispatcherThread&amp;InputReaderThread"></a>10、InputDispatcherThread&amp;InputReaderThread</h2><p><strong>InputDispatcherThread#threadLoop:</strong><br>由前面知InputDispatcherThread中主要通过调用InputDispatcher的dispathOnce来实现的；</p>
<h3 id="1）InputDispatcher-dispatchOnce"><a href="#1）InputDispatcher-dispatchOnce" class="headerlink" title="1）InputDispatcher::dispatchOnce:"></a>1）InputDispatcher::dispatchOnce:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mDispatcherIsAliveCondition.broadcast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在没有等待的commands事运行一个dispatch loop，这个loop之后可能enqueue commands</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有等待的commands的话，就运行所有的commands</span></span><br><span class="line">        <span class="comment">// If any commands were run then force the next poll to wake up immediately.</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始状态下是没有事件的，来到mLooper-&gt;pollOnce，了解Handler机制的native层知道，在pollOnce中调用epoll_wait对前面设置的兴趣事件进行监听，然后InputDispatchThread进入休眠等待唤醒；可想而知下面策略是InputReaderThread来对其进行唤醒；</p>
<p><strong>InputReaderThread#threadLoop:</strong><br>InputReaderThread中的主要逻辑是调用InputReader中的loopOnce函数</p>
<h3 id="1）InputReader-loopOnce"><a href="#1）InputReader-loopOnce" class="headerlink" title="1）InputReader#loopOnce :"></a>1）InputReader#loopOnce :</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** \frameworks\native\services\inputflinger\InputReader.h **/</span></span><br><span class="line">    <span class="keyword">class</span> InputReaderInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</span><br><span class="line">    <span class="keyword">class</span> InputReader : <span class="keyword">public</span> InputReaderInterface</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** \frameworks\native\services\inputflinger\InputReader.cpp **/</span></span><br><span class="line"><span class="comment">// loopOnce即事件处理函数</span></span><br><span class="line">    <span class="keyword">void</span> InputReader::loopOnce() &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 其实是通过mEventHub来获取Events的</span></span><br><span class="line">        <span class="comment">// @value sp&lt;EventHubInterface&gt; mEventHub;</span></span><br><span class="line">        <span class="keyword">size_t</span> count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// @value sp&lt;QueuedInputListener&gt; mQueuedListener;</span></span><br><span class="line">        mQueuedListener-&gt;flush();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到这里通过EventHub的getEvents来获取/dev/input中的Event事件，然后用到前面提到的封装了InputDispatcher的QueueListener来分发事件；<br>EventHub获取Events的具体流程：<a href="http://www.feeyan.cn/?p=280" target="_blank" rel="external">Android按键事件传递流程(一)</a><br>主要工作流程是注册这些监听的devices，然后调用epoll_wait使得InputReaderThread等待唤醒；<br>获取Events的过于复杂，直接跳过，来看事件的传递；当获取到Event之后，调用mQueuedListener的flush来传递消息；</p>
<h1 id="二、事件分发"><a href="#二、事件分发" class="headerlink" title="二、事件分发"></a>二、事件分发</h1><p>前面提到使用EventHub的getEvents来获取Events之后，通过mQueuedListener的flush开始消息的分发；</p>
<h2 id="1、QueueInputListener-flush"><a href="#1、QueueInputListener-flush" class="headerlink" title="1、QueueInputListener#flush:"></a>1、QueueInputListener#flush:</h2><h3 id="1）先看QueueInputListener的定义："><a href="#1）先看QueueInputListener的定义：" class="headerlink" title="1）先看QueueInputListener的定义："></a>1）先看QueueInputListener的定义：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputListener.h **/</span></span><br><span class="line"><span class="keyword">class</span> QueuedInputListener : <span class="keyword">public</span> InputListenerInterface &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~QueuedInputListener();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    QueuedInputListener(<span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; innerListener);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyConfigurationChanged</span><span class="params">(<span class="keyword">const</span> NotifyConfigurationChangedArgs* args)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyKey</span><span class="params">(<span class="keyword">const</span> NotifyKeyArgs* args)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyMotion</span><span class="params">(<span class="keyword">const</span> NotifyMotionArgs* args)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifySwitch</span><span class="params">(<span class="keyword">const</span> NotifySwitchArgs* args)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyDeviceReset</span><span class="params">(<span class="keyword">const</span> NotifyDeviceResetArgs* args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    sp&lt;InputListenerInterface&gt; mInnerListener;<span class="comment">// mInnerListner即是InputDispatcher</span></span><br><span class="line">    Vector&lt;NotifyArgs*&gt; mArgsQueue; <span class="comment">// 后面flush函数中将会用到</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在InputReader的构造函数中，传递进来的mInnerListener即为InputDispatcher；</p>
<h3 id="2）flush函数："><a href="#2）flush函数：" class="headerlink" title="2）flush函数："></a>2）flush函数：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputListener.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> QueuedInputListener::flush() &#123;</span><br><span class="line">    <span class="keyword">size_t</span> count = mArgsQueue.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        NotifyArgs* args = mArgsQueue[i];</span><br><span class="line">        <span class="comment">// 调用NotifyArgs。notify函数</span></span><br><span class="line">        args-&gt;notify(mInnerListener);</span><br><span class="line">        <span class="keyword">delete</span> args;</span><br><span class="line">    &#125;</span><br><span class="line">    mArgsQueue.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里仅是一个封装函数，最终调用InputListenerInterface的notifyKey函数</span></span><br><span class="line"><span class="keyword">void</span> NotifyKeyArgs::notify(<span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) <span class="keyword">const</span> &#123;</span><br><span class="line">    listener-&gt;notifyKey(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>前面最终调用InputListenerInterface（即InputDispatcher）的notifyKey回调函数；
总结前面的流程即InputReaderThread通过EventHub不断读取获取event信息，获得事件后，调用InputDispather的notifyKey函数来通知InputDispathcer进行处理。注意这里调用InputDispatcher的notifyKey函数依然是在InputReaderThread线程中进行的，此时InputDispathcerThread仍然是epoll_wait阻塞状态中；
</code></pre><h2 id="2、InputDispatcher-notifyKey："><a href="#2、InputDispatcher-notifyKey：" class="headerlink" title="2、InputDispatcher::notifyKey："></a>2、InputDispatcher::notifyKey：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::notifyKey(<span class="keyword">const</span> NotifyKeyArgs* args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!validateKeyEvent(args-&gt;action)) &#123; <span class="comment">// 判断event是否合法</span></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 初始化KeyEvent</span></span><br><span class="line">    KeyEvent event;</span><br><span class="line">    event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action,</span><br><span class="line">                     flags, keyCode, args-&gt;scanCode, metaState, <span class="number">0</span>,</span><br><span class="line">                     args-&gt;downTime, args-&gt;eventTime);</span><br><span class="line">    <span class="keyword">bool</span> needWake;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        mLock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldSendKeyToInputFilterLocked(args)) &#123;</span><br><span class="line">            mLock.unlock();</span><br><span class="line"></span><br><span class="line">            policyFlags |= POLICY_FLAG_FILTERED;</span><br><span class="line">            <span class="keyword">if</span> (!mPolicy-&gt;filterInputEvent(&amp;event, policyFlags)) &#123;</span><br><span class="line">                return; <span class="comment">// event was consumed by the filter</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mLock.lock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> repeatCount = <span class="number">0</span>;</span><br><span class="line">        KeyEntry* newEntry = new KeyEntry(args-&gt;eventTime,</span><br><span class="line">                                          args-&gt;deviceId, args-&gt;source, policyFlags,</span><br><span class="line">                                          args-&gt;action, flags, keyCode, args-&gt;scanCode,</span><br><span class="line">                                          metaState, repeatCount, args-&gt;downTime);</span><br><span class="line"></span><br><span class="line">        needWake = enqueueInboundEventLocked(newEntry);</span><br><span class="line">        mLock.unlock();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒InputDispatcherThread线程</span></span><br><span class="line">    <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">        mLooper-&gt;wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 该部分对传递过来的按键事件进行检查、验证，之后处理特殊按键，将原始按键信息封装成KeyEntry，再调用enqueueInboundEventLocked函数把KeyEntry添加到InboundQueue队列中，最后调用Looper对象的wake往管道中写入字符唤醒InputDispatcherThread线程（类似于Handler机制中的唤醒）；<br>先来看enqueueInboundEventLocked添加事件到InboundQueue队列中：</p>
<h3 id="1）InputDispatcher-enqueueInboundEventLocked："><a href="#1）InputDispatcher-enqueueInboundEventLocked：" class="headerlink" title="1）InputDispatcher::enqueueInboundEventLocked："></a>1）InputDispatcher::enqueueInboundEventLocked：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">bool</span> InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) &#123;</span><br><span class="line">    <span class="comment">// @value Queue&lt;EventEntry&gt; mInboundQueue;</span></span><br><span class="line">    <span class="keyword">bool</span> needWake = mInboundQueue.isEmpty();</span><br><span class="line">    <span class="comment">// 将entry入队列</span></span><br><span class="line">    mInboundQueue.enqueueAtTail(entry);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> (entry-&gt;type) &#123; <span class="comment">// 如前面所述，InputEvent分为KeyEvent和MotionEvent进行分别处理</span></span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_KEY: ......</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_MOTION: .....</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return needWake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将entry添加到InboundQueue队列尾部；然后判断是否需要唤醒，即needWake是否为true；当mInboundQueue不为空，则明显InputDispathcerThread仍处于运行状态来分发事件，因而不用进行唤醒；而当mInboundQueue为空时，测试InputDispatcherThread进行休眠状态，使用wake对其来唤醒；<br>    InputDispatcherThread之前调用Looper的poolOnce函数阻塞休眠，这里调用wake将其唤醒；因为InputDispatcherThread的threadLoop返回值为true，表示该Thread是循环执行的，故继续调用其dispatchOnce函数；</p>
<h2 id="3、InputDispatcher-dispatchOnce"><a href="#3、InputDispatcher-dispatchOnce" class="headerlink" title="3、InputDispatcher::dispatchOnce:"></a>3、InputDispatcher::dispatchOnce:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mDispatcherIsAliveCondition.broadcast();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 在没有等待的commands事运行一个dispatch loop，这个loop之后可能enqueue commands</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果有等待的commands的话，就运行所有的commands</span></span><br><span class="line">        <span class="comment">// If any commands were run then force the next poll to wake up immediately.</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来到dispatchOnceInnerLocked：</p>
<h2 id="4、InputDispathcer-dispatchOnceInnerLocked"><a href="#4、InputDispathcer-dispatchOnceInnerLocked" class="headerlink" title="4、InputDispathcer#dispatchOnceInnerLocked:"></a>4、InputDispathcer#dispatchOnceInnerLocked:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnceInnerLocked(<span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! mPendingEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInboundQueue.isEmpty()) &#123; <span class="comment">// 当前mInboundQueue已经存在元素</span></span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inbound queue has at least one entry.</span></span><br><span class="line">            mPendingEvent = mInboundQueue.dequeueAtHead();</span><br><span class="line">            traceInboundQueueLengthLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now we have an event to dispatch.</span></span><br><span class="line">    <span class="comment">// All events are eventually dequeued and processed this way, even if we intend to drop them.</span></span><br><span class="line">    ALOG_ASSERT(mPendingEvent != <span class="literal">NULL</span>);</span><br><span class="line">    .......</span><br><span class="line">    <span class="comment">// 根据mPendingEvent的Type的不同分别进行处理</span></span><br><span class="line">    <span class="keyword">switch</span> (mPendingEvent-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_CONFIGURATION_CHANGED: &#123;</span><br><span class="line">            ......</span><br><span class="line">            done = dispatchConfigurationChangedLocked(currentTime, typedEntry);</span><br><span class="line">            dropReason = DROP_REASON_NOT_DROPPED; <span class="comment">// configuration changes are never dropped</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// KeyEvent采用dispatchKeyLocked进行处理</span></span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">            KeyEntry* typedEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(mPendingEvent);</span><br><span class="line">            ......</span><br><span class="line">            done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// MotionEvent采用dispatchMotionLocked进行处理</span></span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">            ......</span><br><span class="line">            done = dispatchMotionLocked(currentTime, typedEntry,</span><br><span class="line">                                        &amp;dropReason, nextWakeupTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOG_ASSERT(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dropReason != DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">            dropInboundEventLocked(mPendingEvent, dropReason);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        releasePendingEventLocked();</span><br><span class="line">        *nextWakeupTime = LONG_LONG_MIN;  <span class="comment">// force next poll to wake up immediately</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到是事件处理机制中常用的处理模式，类似于Handler机制，这里先dequeueAtHead使得InBoundQueue事件队列中的事件出队列（FIFO）；然后根据事件的类似进行不同的处理；如TYPE_KEY类型事件采用dispatchKeyLocked；TYPE_MOTION类型事件采用dispatchMotionLocked处理<br> 下面以KeyEvent为例进行分析,下面忽略对event的具体处理细节，具体来看事件是如何传递的；</p>
<h2 id="5、InputDispatcher-dispatchKeyLocked"><a href="#5、InputDispatcher-dispatchKeyLocked" class="headerlink" title="5、InputDispatcher::dispatchKeyLocked:"></a>5、InputDispatcher::dispatchKeyLocked:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">bool</span> InputDispatcher::dispatchKeyLocked(<span class="keyword">nsecs_t</span> currentTime, KeyEntry* entry,</span><br><span class="line">        DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/** 确定事件的接收方（Target） **/</span></span><br><span class="line">    Vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">            entry, inputTargets, nextWakeupTime);</span><br><span class="line"> </span><br><span class="line">    setInjectionResultLocked(entry, injectionResult);</span><br><span class="line">    addMonitoringTargetsLocked(inputTargets);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** 将消息dispatch给Target **/</span></span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面对event的处理细节忽略，重点来看系统是如何查找event对应的接收方（Target）的，这里的InputTarget指定一个输入事件如何被分发到一个特定窗口。该结构体包含了很多特征变量：x,y坐标，输入事件通道InputChannel等；<br>这里通过findFocusedWindowTargetsLocked来确定InputTarget的，然后调用dispatchEventLocked来将Event分发给具体的Target；<br>接下来分析函数findFocusedWindowTargetsLocked；</p>
<h2 id="6、InputDispatcher-findFocusedWindowTargetsLocked"><a href="#6、InputDispatcher-findFocusedWindowTargetsLocked" class="headerlink" title="6、InputDispatcher::findFocusedWindowTargetsLocked:"></a>6、InputDispatcher::findFocusedWindowTargetsLocked:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">int32_t</span> InputDispatcher::findFocusedWindowTargetsLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> EventEntry* entry, Vector&lt;InputTarget&gt;&amp; inputTargets, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult;</span><br><span class="line">    String8 reason;</span><br><span class="line">    <span class="comment">// mFocusedWindowHandle表示当前焦点窗口的句柄</span></span><br><span class="line">    <span class="comment">// @value sp&lt;InputWindowHandle&gt; mFocusedWindowHandle;</span></span><br><span class="line">    <span class="comment">/** 当获得焦点的窗口为null时，会丢弃这一事件 **/</span></span><br><span class="line">    <span class="keyword">if</span> (mFocusedWindowHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFocusedApplicationHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有焦点窗口，但焦点窗口所在的应用程序进程存在，说明该应程序还在启动过程中，故等待nextWakeupTime后再重试</span></span><br><span class="line">            injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                    mFocusedApplicationHandle, NULL, nextWakeupTime,</span><br><span class="line">                    <span class="string">"Waiting because no window has focus but there is a "</span></span><br><span class="line">                    <span class="string">"focused application that may eventually add a window "</span></span><br><span class="line">                    <span class="string">"when it finishes starting up."</span>);</span><br><span class="line">            <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        injectionResult = INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 如果执行到这里说明当前有焦点窗口 **/</span></span><br><span class="line">    <span class="comment">// 先判断权限</span></span><br><span class="line">    <span class="keyword">if</span> (! checkInjectionPermission(mFocusedWindowHandle, entry-&gt;injectionState)) &#123;</span><br><span class="line">        injectionResult = INPUT_EVENT_INJECTION_PERMISSION_DENIED;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前焦点窗口正在处理上一个事件，采取和最上面一样的作法，等待一段时间后重试</span></span><br><span class="line">    reason = checkWindowReadyForMoreInputLocked(currentTime,</span><br><span class="line">            mFocusedWindowHandle, entry, <span class="string">"focused"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!reason.isEmpty()) &#123;</span><br><span class="line">        injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                mFocusedApplicationHandle, mFocusedWindowHandle, nextWakeupTime, reason.string());</span><br><span class="line">        <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功找到匹配的窗口，通过addWindowTargetLocked添加到inputTargets变量中</span></span><br><span class="line">    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;</span><br><span class="line">    addWindowTargetLocked(mFocusedWindowHandle,</span><br><span class="line">            InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS, BitSet32(<span class="number">0</span>),</span><br><span class="line">            inputTargets);</span><br><span class="line"></span><br><span class="line">Failed:</span><br><span class="line">Unresponsive:</span><br><span class="line">    <span class="keyword">nsecs_t</span> timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);</span><br><span class="line">    updateDispatchStatisticsLocked(currentTime, entry,</span><br><span class="line">            injectionResult, timeSpentWaitingForApplication);</span><br><span class="line">    return injectionResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面查找焦点窗口的逻辑很清晰， 当mFocusedWindowHandle为null时，如果mFocusedApplicationHandle不为null，表示当前没有焦点窗口，但焦点窗口所在的应用程序进程存在，说明该应程序还在启动过程中，故等待nextWakeupTime后再重试；如果mFocusedApplicationHandle为null，则丢弃该事件，因为没有能够接收该事件的窗口；<br>    如果mFocusedWindowHandle不为null，先判断当前窗口是否locked，如果是表示正在处理其他输入事件，这时采用和上面相同的策略，等待一段时间后，然后重试。<br>    当找到匹配的目标窗口之后，赋值给InputTarget；先来看InputTarget的定义：</p>
<h2 id="7、InputTarget"><a href="#7、InputTarget" class="headerlink" title="7、InputTarget:"></a>7、InputTarget:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.h **/</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * An input target specifies how an input event is to be dispatched to a particular window</span><br><span class="line"> * including the window's input channel, control flags, a timeout, and an X / Y offset to</span><br><span class="line"> * be added to input event coordinates to compensate for the absolute position of the</span><br><span class="line"> * window area.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> InputTarget &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; <span class="comment">// 该枚举类列举个关于目标窗口的各种属性值描述</span></span><br><span class="line">        <span class="comment">/* This flag indicates that the event is being delivered to a foreground application. */</span></span><br><span class="line">        FLAG_FOREGROUND = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">// 说明目标窗口是前台应用</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** InputDispatcher与WMS建立关联通信的地方 */</span></span><br><span class="line">    sp&lt;InputChannel&gt; inputChannel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里引出了重要的类InputChannel，InputDispatcher与WMS之间的通信，正是通过InputChannel来实现的。</p>
<p>继续前面的dispatchKeyLocked函数，接下来会调用dispatchEventLocked来传递消息；</p>
<h2 id="8、InputDispatcher-dispatchEventLocked"><a href="#8、InputDispatcher-dispatchEventLocked" class="headerlink" title="8、InputDispatcher#dispatchEventLocked"></a>8、InputDispatcher#dispatchEventLocked</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchEventLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        EventEntry* eventEntry, <span class="keyword">const</span> Vector&lt;InputTarget&gt;&amp; inputTargets) &#123;</span><br><span class="line">    ALOG_ASSERT(eventEntry-&gt;dispatchInProgress); <span class="comment">// should already have been set to true</span></span><br><span class="line"></span><br><span class="line">    pokeUserActivityLocked(eventEntry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputTargets.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> InputTarget&amp; inputTarget = inputTargets.itemAt(i);</span><br><span class="line">        <span class="comment">// 根据inputChannel（其中的fd）来获取对应的Connection</span></span><br><span class="line">        <span class="keyword">ssize_t</span> connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);</span><br><span class="line">        <span class="keyword">if</span> (connectionIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);</span><br><span class="line">            <span class="comment">// 继续向下调用</span></span><br><span class="line">            prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里根据InputChannel的fd值来获取对应的Connection对象，InputChannel以及Connection的相关知识可以西安看第三章；Connection是用来管理InputChannel的变量；然后接着调用 prepareDispatchCycleLocked；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::prepareDispatchCycleLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Split a motion event if needed.</span></span><br><span class="line">    <span class="keyword">if</span> (inputTarget-&gt;flags &amp; InputTarget::FLAG_SPLIT) &#123;</span><br><span class="line">        ALOG_ASSERT(eventEntry-&gt;type == EventEntry::TYPE_MOTION);</span><br><span class="line"></span><br><span class="line">        MotionEntry* originalMotionEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);</span><br><span class="line">        <span class="keyword">if</span> (inputTarget-&gt;pointerIds.count() != originalMotionEntry-&gt;pointerCount) &#123;</span><br><span class="line">            MotionEntry* splitMotionEntry = splitMotionEvent(</span><br><span class="line">                    originalMotionEntry, inputTarget-&gt;pointerIds);</span><br><span class="line">            <span class="keyword">if</span> (!splitMotionEntry) &#123;</span><br><span class="line">                return; <span class="comment">// split event was dropped</span></span><br><span class="line">            &#125;</span><br><span class="line">            enqueueDispatchEntriesLocked(currentTime, connection,</span><br><span class="line">                    splitMotionEntry, inputTarget);</span><br><span class="line">            splitMotionEntry-&gt;release();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not splitting.  Enqueue dispatch entries for the event as is.</span></span><br><span class="line">    enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后接着调用 enqueueDispatchEntriesLocked函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::enqueueDispatchEntriesLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget) &#123;</span><br><span class="line">    <span class="keyword">bool</span> wasEmpty = connection-&gt;outboundQueue.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue dispatch entries for the requested modes.</span></span><br><span class="line">    <span class="comment">// 将dispatch entries入队列</span></span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_OUTSIDE);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_IS);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the outbound queue was previously empty, start the dispatch cycle going.</span></span><br><span class="line">    <span class="comment">// 开始分发事件</span></span><br><span class="line">    <span class="keyword">if</span> (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        startDispatchCycleLocked(currentTime, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enqueueDispatchEntryLocked创建DispatchEntry（按键事件对象），并且把该对象作为一个发送数据包加入到outboundQueue队列中；<br>startDispatchCycleLocked取出outboundQueue队列头元素，赋给dispatchEntry，再取出事件对象KeyEntry，根据事件类型确定case语句分支，如果是按键事件，就调用connection的InputPublisher的publishKeyEvent函数发送到inputchannel中，如果publishKeyEvent返回0，表示按键事件发送成功；<br><strong>InputDispathcer#enqueueDispatchEntryLocked：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::enqueueDispatchEntryLocked(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget,</span><br><span class="line">        <span class="keyword">int32_t</span> dispatchMode) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> inputTargetFlags = inputTarget-&gt;flags;</span><br><span class="line">    <span class="comment">// 如果inputTargetFlags和dispatchMode不匹配</span></span><br><span class="line">    <span class="keyword">if</span> (!(inputTargetFlags &amp; dispatchMode)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    inputTargetFlags = (inputTargetFlags &amp; ~InputTarget::FLAG_DISPATCH_MASK) | dispatchMode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建DispatchEntry</span></span><br><span class="line">    DispatchEntry* dispatchEntry = new DispatchEntry(eventEntry, <span class="comment">// increments ref</span></span><br><span class="line">            inputTargetFlags, inputTarget-&gt;xOffset, inputTarget-&gt;yOffset,</span><br><span class="line">            inputTarget-&gt;scaleFactor);</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue the dispatch entry.</span></span><br><span class="line">    <span class="comment">// 添加到outboundQueue中</span></span><br><span class="line">    connection-&gt;outboundQueue.enqueueAtTail(dispatchEntry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9、InputDispathcer-startDispatchCycleLocked"><a href="#9、InputDispathcer-startDispatchCycleLocked" class="headerlink" title="9、InputDispathcer#startDispatchCycleLocked:"></a>9、InputDispathcer#startDispatchCycleLocked:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::startDispatchCycleLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (connection-&gt;status == Connection::STATUS_NORMAL</span><br><span class="line">            &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 取出outboundQueue的首部元素</span></span><br><span class="line">        DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head;</span><br><span class="line">        dispatchEntry-&gt;deliveryTime = currentTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Publish the event.</span></span><br><span class="line">        <span class="keyword">status_t</span> status;</span><br><span class="line">        EventEntry* eventEntry = dispatchEntry-&gt;eventEntry;</span><br><span class="line">        <span class="comment">// 根据EventEntry的Type类型进行处理</span></span><br><span class="line">        <span class="keyword">switch</span> (eventEntry-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">            KeyEntry* keyEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(eventEntry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Publish the key event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    keyEntry-&gt;deviceId, keyEntry-&gt;source,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags,</span><br><span class="line">                    keyEntry-&gt;keyCode, keyEntry-&gt;scanCode,</span><br><span class="line">                    keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime,</span><br><span class="line">                    keyEntry-&gt;eventTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">            MotionEntry* motionEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);</span><br><span class="line">            ....</span><br><span class="line">            <span class="comment">// Publish the motion event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishMotionEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    motionEntry-&gt;deviceId, motionEntry-&gt;source,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags,</span><br><span class="line">                    motionEntry-&gt;edgeFlags, motionEntry-&gt;metaState, motionEntry-&gt;buttonState,</span><br><span class="line">                    xOffset, yOffset,</span><br><span class="line">                    motionEntry-&gt;xPrecision, motionEntry-&gt;yPrecision,</span><br><span class="line">                    motionEntry-&gt;downTime, motionEntry-&gt;eventTime,</span><br><span class="line">                    motionEntry-&gt;pointerCount, motionEntry-&gt;pointerProperties,</span><br><span class="line">                    usingCoords);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Re-enqueue the event on the wait queue.</span></span><br><span class="line">        <span class="comment">// 事件处理完，将该Entry移除队列</span></span><br><span class="line">        connection-&gt;outboundQueue.dequeue(dispatchEntry);</span><br><span class="line">        traceOutboundQueueLengthLocked(connection);</span><br><span class="line">        connection-&gt;waitQueue.enqueueAtTail(dispatchEntry);</span><br><span class="line">        traceWaitQueueLengthLocked(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>典型的事件处理函数，从outBoundQueue中取出EventEntry，然后根据其Type，是TypeEvent，还是MotionEvent分别进行处理；可以看到KeyEvent使用publishKeyEvent来处理；而MotionEvent采用publishMotionEvent来处理；</p>
<h2 id="10、InputPublisher-publishMotionEvent："><a href="#10、InputPublisher-publishMotionEvent：" class="headerlink" title="10、InputPublisher#publishMotionEvent："></a>10、InputPublisher#publishMotionEvent：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\libs\input\InputTransport.cpp **/</span> </span><br><span class="line"><span class="keyword">status_t</span> InputPublisher::publishMotionEvent(</span><br><span class="line">        <span class="keyword">uint32_t</span> seq,</span><br><span class="line">        <span class="keyword">int32_t</span> deviceId,</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">const</span> PointerProperties* pointerProperties,</span><br><span class="line">        <span class="keyword">const</span> PointerCoords* pointerCoords) &#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="comment">// 一系列的赋值操作</span></span><br><span class="line">    InputMessage msg;</span><br><span class="line">    msg.header.type = InputMessage::TYPE_MOTION;</span><br><span class="line">    msg.body.motion.seq = seq;</span><br><span class="line">    msg.body.motion.deviceId = deviceId;</span><br><span class="line">    ......</span><br><span class="line">    return mChannel-&gt;sendMessage(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InputPublisher的publishMotionEvent中创建一个InputMessage，然后根据传递进来的EventEntry中的值进行赋值，然后调用InputChannel的sendMessage进行事件发送；这里的InputChannel即是下面将会提到的在ViewRootImpl中创建的Server端的InputChannel；</p>
<h2 id="11、InputChannel-sendMessage"><a href="#11、InputChannel-sendMessage" class="headerlink" title="11、InputChannel#sendMessage:"></a>11、InputChannel#sendMessage:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\libs\input\InputTransport.cpp **/</span></span><br><span class="line"><span class="keyword">status_t</span> InputChannel::sendMessage(<span class="keyword">const</span> InputMessage* msg) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> msgLength = msg-&gt;size();</span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// mFd对应socket fd;则例相当于往服务器socket中发送消息</span></span><br><span class="line">        nWrite = ::send(mFd, msg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送失败</span></span><br><span class="line">    <span class="keyword">if</span> (nWrite &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       .....</span><br><span class="line">        return -error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送成功</span></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InputChannel的sendMessage操作即是使用服务器socket send一个Message；下面将会提到socket服务端没有往inputchannel中写入数据时，客户端暂时处于阻塞状态，一旦服务端有了数据后，客户端也被唤醒了。</p>
<p>这里先来了解下这个重要类InputChannel是如何被初始化的；</p>
<h1 id="三、重要的类InputChannel"><a href="#三、重要的类InputChannel" class="headerlink" title="三、重要的类InputChannel:"></a>三、重要的类InputChannel:</h1><h2 id="1、InputChannel定义"><a href="#1、InputChannel定义" class="headerlink" title="1、InputChannel定义:"></a>1、InputChannel定义:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\include\input\InputTransport.h **/</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * An input channel consists of a local unix domain socket used to send and receive</span><br><span class="line"> * input messages across processes.  Each channel has a descriptive name for debugging purposes.</span><br><span class="line"> *</span><br><span class="line"> * Each endpoint has its own InputChannel object that specifies its file descriptor.</span><br><span class="line"> *</span><br><span class="line"> * The input channel is closed when all references to it are released.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// 上面提到InputChannel是使用unix domain socket（UDS）进行通信的，而非Binder</span></span><br><span class="line"><span class="keyword">class</span> InputChannel : <span class="keyword">public</span> RefBase &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span>~InputChannel();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    InputChannel(<span class="keyword">const</span> String8&amp; name, <span class="keyword">int</span> fd); <span class="comment">// fd类似设备描述符</span></span><br><span class="line">    <span class="comment">// 用于打开一个InputChannel对（Pair）,用以实现双向通信</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> status_t <span class="title">openInputChannelPair</span><span class="params">(<span class="keyword">const</span> String8&amp; name,</span><br><span class="line">            sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> String8 <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; returnmName; &#125;</span><br><span class="line">    <span class="function">inlineint <span class="title">getFd</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; returnmFd; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 发送接收信息</span></span><br><span class="line">    <span class="keyword">status_t</span> sendMessage(<span class="keyword">const</span> InputMessage* msg);</span><br><span class="line">    <span class="keyword">status_t</span> receiveMessage(InputMessage* msg);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Returns a new object that has a duplicate of this channel's fd. */</span></span><br><span class="line">    sp&lt;InputChannel&gt; dup() <span class="keyword">const</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    String8 mName;</span><br><span class="line">    <span class="keyword">int</span> mFd;  <span class="comment">// 重点要弄清该变量代表的含义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>InputChannel是可以双向通信的，它通过openInputChannelPair来打开一个InputChannel对，然后sendMessage或者receiveMessage来发送接收消息；<br>InputChannel是通过UDS来实现通信的，Android系统中最为常用的进程间通信时Binder通信，其次便是UDS进行单机内的进程间通信，也称IPC Socket。<br>来看InputChannel的初始化：<br>了解Window的创建过程后，之后有一个重要的对象ViewRootImpl，这里从其setView开始探索：</p>
<h2 id="2、ViewRootImpl-setView"><a href="#2、ViewRootImpl-setView" class="headerlink" title="2、ViewRootImpl#setView:"></a>2、ViewRootImpl#setView:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\core\java\android\view\ViewRootImpl.java **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        .....</span><br><span class="line">        <span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">                &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">            mInputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在Session addToDisplay时，传入mInputChannel</span></span><br><span class="line">            res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                    getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                    mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mInputChannel);</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实Java层的InputChannel只是对native层的封装，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\core\java\android\view\InputChannel.java **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InputChannel</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mPtr; <span class="comment">// used by native code</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> InputChannel[] nativeOpenInputChannelPair(String name);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeDispose</span><span class="params">(<span class="keyword">boolean</span> finalized)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeTransferTo</span><span class="params">(InputChannel other)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeReadFromParcel</span><span class="params">(Parcel parcel)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeWriteToParcel</span><span class="params">(Parcel parcel)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeDup</span><span class="params">(InputChannel target)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> String <span class="title">nativeGetName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WindowSession的具体细节参见<a href="http://blog.csdn.net/woliuyunyicai/article/details/48419135" target="_blank" rel="external">《View机制深入学习（一）》</a>，addToDisplay会继续调用WindowManagerService的addWindow函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\core\java\android\view\WindowManagerService.java **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span><br><span class="line">                     WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span><br><span class="line">                     Rect outContentInsets, Rect outStableInsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">if</span> (outInputChannel != <span class="keyword">null</span> &amp;&amp; (attrs.inputFeatures</span><br><span class="line">            &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">        String name = win.makeInputChannelName();</span><br><span class="line">        <span class="comment">// 打开InputChannel对</span></span><br><span class="line">        InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);</span><br><span class="line">        <span class="comment">// WindowState设置inputChannel变量</span></span><br><span class="line">        win.setInputChannel(inputChannels[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 设置outputChannel</span></span><br><span class="line">        inputChannels[<span class="number">1</span>].transferTo(outInputChannel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// InputManager注册InputChannel</span></span><br><span class="line">        mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在这里通过openInputChannelPair打开InputChannel，前面提到openInputChannelPair就是调用native端InputChannel的openInputChannelPair函数；<br>从这里面还可以看到，创建的InputChannel对，一个用来设置给WindowState，即供Window使用；一个设置给InputManagerService，其实是设置给native端的InputDispatcher，用以分发相应的事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\core\java\android\view\InputChannel.java **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InputChannel[] openInputChannelPair(String name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"name must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nativeOpenInputChannelPair(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> InputChannel[] nativeOpenInputChannelPair(String name);</span><br></pre></td></tr></table></figure>
<p>下面来看native端的InputChannel；</p>
<h2 id="3、InputChannel-openInputChannelPair"><a href="#3、InputChannel-openInputChannelPair" class="headerlink" title="3、InputChannel::openInputChannelPair:"></a>3、InputChannel::openInputChannelPair:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\libs\input\InputTransport.cpp **/</span></span><br><span class="line"><span class="keyword">status_t</span> InputChannel::openInputChannelPair(<span class="keyword">const</span> String8&amp; name,</span><br><span class="line">                                            sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel) &#123;</span><br><span class="line">    <span class="comment">// 建立UDS</span></span><br><span class="line">    <span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 创建一个饱含2个元素的socket数组，socketpair创建一对socket对象，SOCK_SEQPACKET表示创建连续可靠的数据包连接，如果创建成功，返回0，如果返回-1，出错。</span></span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets)) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> result = -errno;</span><br><span class="line">        outServerChannel.clear();</span><br><span class="line">        outClientChannel.clear();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置缓冲区大小</span></span><br><span class="line">    <span class="keyword">int</span> bufferSize = SOCKET_BUFFER_SIZE;</span><br><span class="line">    setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Server与Client端实例</span></span><br><span class="line">    String8 serverChannelName = name;</span><br><span class="line">    serverChannelName.append(<span class="string">" (server)"</span>);</span><br><span class="line">    outServerChannel = new InputChannel(serverChannelName, sockets[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    String8 clientChannelName = name;</span><br><span class="line">    clientChannelName.append(<span class="string">" (client)"</span>);</span><br><span class="line">    outClientChannel = new InputChannel(clientChannelName, sockets[<span class="number">1</span>]);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面创建了一对InputChannel：分别为服务端管道对象outServerChannel和客户端管道对象outClientChannel;inputChannels[0]作为服务端管道提供给InputDispatcher使用，用来发送按键事件；inputChannels[1]作为客户端管道提供给应用程序主线程使用，用来接收、消费按键事件。</p>
<p>创建好InputChannel之后，继续来看addWindow中的InputManagerService注册InputChannel的过程；前面提到，创建的inputChannels[0]即outServerChannel是供IMS中的InputDispatcher使用的，因此这里需要进行注册；</p>
<h2 id="4、InputManagerService-registerInputChannel："><a href="#4、InputManagerService-registerInputChannel：" class="headerlink" title="4、InputManagerService#registerInputChannel："></a>4、InputManagerService#registerInputChannel：</h2><p>直接来到本地端的nativeRegisterInputChannel，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span>  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeRegisterInputChannel</span><span class="params">(JNIEnv* env, jclass clazz,</span><br><span class="line">        jlong ptr, jobject inputChannelObj, jobject inputWindowHandleObj, jboolean monitor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将Java端存储的ptr指针地址转化为NativeInputManager对象</span></span><br><span class="line">    NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据传输进来的inputChannelObj获取InputChannel对象</span></span><br><span class="line">    sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env, inputChannelObj);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 根据传递进来的inputWindowHandleObj来获取InputWindowHandle对象</span></span><br><span class="line">    sp&lt;InputWindowHandle&gt; inputWindowHandle = android_server_InputWindowHandle_getHandle(env, inputWindowHandleObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用NativeInputManager的registerInputChannel进行注册</span></span><br><span class="line">    <span class="keyword">status_t</span> status = im-&gt;registerInputChannel(env, inputChannel, inputWindowHandle, monitor);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的逻辑很清晰，通过java层传递进来的inputChannelObj,inputWindowHandleObj来获取相对应的InputChannel以及InputWindowHandle对象。<br>然后将获得的实例传入到NativeInputManager中的registerInputChannel进行注册；</p>
<h2 id="5、NativeInputManager-registerInputChannel"><a href="#5、NativeInputManager-registerInputChannel" class="headerlink" title="5、NativeInputManager#registerInputChannel:"></a>5、NativeInputManager#registerInputChannel:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span>  </span><br><span class="line"><span class="keyword">status_t</span> NativeInputManager::registerInputChannel(JNIEnv* env,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="keyword">bool</span> monitor) &#123;</span><br><span class="line">    return mInputManager-&gt;getDispatcher()-&gt;registerInputChannel(</span><br><span class="line">            inputChannel, inputWindowHandle, monitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里最终是调用InputManager中的InputDispatcher的registerInputChannel进行注册，这也验证了前面所叙述的服务器端的InputChannel是供以InputDispatcher来使用的。</p>
<h2 id="6、InputDispatcher-registerInputChannel"><a href="#6、InputDispatcher-registerInputChannel" class="headerlink" title="6、InputDispatcher#registerInputChannel:"></a>6、InputDispatcher#registerInputChannel:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span>  </span><br><span class="line"><span class="keyword">status_t</span> InputDispatcher::registerInputChannel(<span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="keyword">bool</span> monitor) &#123;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getConnectionIndexLocked(inputChannel) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            return BAD_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Connection来管理对应的InputChannel以及WindowHandler</span></span><br><span class="line">        sp&lt;Connection&gt; connection = new Connection(inputChannel, inputWindowHandle, monitor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取InputChannel对应的socket Fd;</span></span><br><span class="line">        <span class="keyword">int</span> fd = inputChannel-&gt;getFd();</span><br><span class="line">        <span class="comment">// 类似于key,value形式，将connection与inputChannel的fd建立起关联</span></span><br><span class="line">        mConnectionsByFd.add(fd, connection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (monitor) &#123;</span><br><span class="line">            mMonitoringChannels.push(inputChannel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将InputChannel的fd添加到Looper中epoll的兴趣事件列表中</span></span><br><span class="line">        mLooper-&gt;addFd(fd, <span class="number">0</span>, ALOOPER_EVENT_INPUT, handleReceiveCallback, <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wake the looper because some connections have changed.</span></span><br><span class="line">    <span class="comment">// 因为connection已经发生了变化，则唤醒Looper</span></span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过InputChannel以及InputWindowHandle来创建相对应的Connection；Connetction是用来管理InputChannel的，Connection存储在 mConnectionsByFd的，它通过key-value形式进行存储，Connection的关键字使用InputChannel创建时的socket的fd来标识。</p>
<p>然后将InputChannel的fd添加到Looper的epoll兴趣列表中，注意这里的Looper对应的是InputDispatcherThread中的Looper；当server端的InputChannel有事件传递时，这时Looper会被唤醒，执行handleReceiveCallback回调；</p>
<p>服务器端InputChannel使用InputManagerService的registerInputChannel来实现，而客户端的InputChannel则通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputChannels[1].transferTo(outInputChannel);</span><br></pre></td></tr></table></figure>
<p>来实现；</p>
<h2 id="7、InputChannel-transferTo："><a href="#7、InputChannel-transferTo：" class="headerlink" title="7、InputChannel#transferTo："></a>7、InputChannel#transferTo：</h2><p>直接来到对应的native层的transferTo:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @path: \frameworks\base\core\jni\android_view_InputChannel.cpp */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_view_InputChannel_nativeTransferTo</span><span class="params">(JNIEnv* env, jobject obj,</span><br><span class="line">        jobject otherObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (android_view_InputChannel_getNativeInputChannel(env, otherObj) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>,</span><br><span class="line">                <span class="string">"Other object already has a native input channel."</span>);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建InputChannel</span></span><br><span class="line">    NativeInputChannel* nativeInputChannel =</span><br><span class="line">            android_view_InputChannel_getNativeInputChannel(env, obj);</span><br><span class="line">    android_view_InputChannel_setNativeInputChannel(env, otherObj, nativeInputChannel);</span><br><span class="line">    android_view_InputChannel_setNativeInputChannel(env, obj, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意函数中出现的几个变量对应的含义：<br>obj：本地方法所在对象的引用，对应inputChannels[1]客户端对象的引用<br>otherObj：在ViewRootImpl中创建的InputChannel对象<br>具体不再细述，就是将本地端的InputChannel[1]赋值给Java端的outInputChannel对象；</p>
<p>在前面第二章末已经提出，使用InputPublisher来将Message传递给InputChannel，这里是发送事件；而相对应的，会有一个是用来接收事件的，其类名为InputConsumer；</p>

      
    </div>
    
  </div>
  
    


    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2016/05/12/设计模式汇总--结构型模型/">
                    设计模式汇总--结构型模式
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2016/05/06/Retrofit源码解析/">
                    Retrofit源码解析
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、获取事件"><span class="toc-number">1.</span> <span class="toc-text">一、获取事件:</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、事件的投递流程："><span class="toc-number">1.1.</span> <span class="toc-text">1、事件的投递流程：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、InputManagerService启动"><span class="toc-number">1.2.</span> <span class="toc-text">2、InputManagerService启动:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、InputMangerService："><span class="toc-number">1.3.</span> <span class="toc-text">3、InputMangerService：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、native层的InputManagerService——NativeInputManager类："><span class="toc-number">1.4.</span> <span class="toc-text">4、native层的InputManagerService——NativeInputManager类：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、NativeInputManager-NativeInputManager"><span class="toc-number">1.5.</span> <span class="toc-text">5、NativeInputManager#NativeInputManager:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#（一）EventHub："><span class="toc-number">1.5.1.</span> <span class="toc-text">（一）EventHub：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#（二）InputManager："><span class="toc-number">1.5.2.</span> <span class="toc-text">（二）InputManager：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1）构造函数："><span class="toc-number">1.5.2.1.</span> <span class="toc-text">1）构造函数：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1）InputDispatcher"><span class="toc-number">1.5.2.1.1.</span> <span class="toc-text">1.1）InputDispatcher:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2）InputReader："><span class="toc-number">1.5.2.1.2.</span> <span class="toc-text">1.2）InputReader：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2）InputManager-initialize"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">2）InputManager#initialize:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-gt-InputReaderThread："><span class="toc-number">1.5.2.2.1.</span> <span class="toc-text">2.1> InputReaderThread：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-gt-InputDispatcherThread"><span class="toc-number">1.5.2.2.2.</span> <span class="toc-text">2.2>InputDispatcherThread</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、InputManagerService-start"><span class="toc-number">1.6.</span> <span class="toc-text">7、InputManagerService#start:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8、NativeInputManager-nativeStart"><span class="toc-number">1.7.</span> <span class="toc-text">8、NativeInputManager#nativeStart:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9、InputManager-start："><span class="toc-number">1.8.</span> <span class="toc-text">9、InputManager#start：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10、InputDispatcherThread-amp-InputReaderThread"><span class="toc-number">1.9.</span> <span class="toc-text">10、InputDispatcherThread&InputReaderThread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1）InputDispatcher-dispatchOnce"><span class="toc-number">1.9.1.</span> <span class="toc-text">1）InputDispatcher::dispatchOnce:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1）InputReader-loopOnce"><span class="toc-number">1.9.2.</span> <span class="toc-text">1）InputReader#loopOnce :</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、事件分发"><span class="toc-number">2.</span> <span class="toc-text">二、事件分发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、QueueInputListener-flush"><span class="toc-number">2.1.</span> <span class="toc-text">1、QueueInputListener#flush:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1）先看QueueInputListener的定义："><span class="toc-number">2.1.1.</span> <span class="toc-text">1）先看QueueInputListener的定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2）flush函数："><span class="toc-number">2.1.2.</span> <span class="toc-text">2）flush函数：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、InputDispatcher-notifyKey："><span class="toc-number">2.2.</span> <span class="toc-text">2、InputDispatcher::notifyKey：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1）InputDispatcher-enqueueInboundEventLocked："><span class="toc-number">2.2.1.</span> <span class="toc-text">1）InputDispatcher::enqueueInboundEventLocked：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、InputDispatcher-dispatchOnce"><span class="toc-number">2.3.</span> <span class="toc-text">3、InputDispatcher::dispatchOnce:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、InputDispathcer-dispatchOnceInnerLocked"><span class="toc-number">2.4.</span> <span class="toc-text">4、InputDispathcer#dispatchOnceInnerLocked:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、InputDispatcher-dispatchKeyLocked"><span class="toc-number">2.5.</span> <span class="toc-text">5、InputDispatcher::dispatchKeyLocked:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、InputDispatcher-findFocusedWindowTargetsLocked"><span class="toc-number">2.6.</span> <span class="toc-text">6、InputDispatcher::findFocusedWindowTargetsLocked:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、InputTarget"><span class="toc-number">2.7.</span> <span class="toc-text">7、InputTarget:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8、InputDispatcher-dispatchEventLocked"><span class="toc-number">2.8.</span> <span class="toc-text">8、InputDispatcher#dispatchEventLocked</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9、InputDispathcer-startDispatchCycleLocked"><span class="toc-number">2.9.</span> <span class="toc-text">9、InputDispathcer#startDispatchCycleLocked:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10、InputPublisher-publishMotionEvent："><span class="toc-number">2.10.</span> <span class="toc-text">10、InputPublisher#publishMotionEvent：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11、InputChannel-sendMessage"><span class="toc-number">2.11.</span> <span class="toc-text">11、InputChannel#sendMessage:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、重要的类InputChannel"><span class="toc-number">3.</span> <span class="toc-text">三、重要的类InputChannel:</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、InputChannel定义"><span class="toc-number">3.1.</span> <span class="toc-text">1、InputChannel定义:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、ViewRootImpl-setView"><span class="toc-number">3.2.</span> <span class="toc-text">2、ViewRootImpl#setView:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、InputChannel-openInputChannelPair"><span class="toc-number">3.3.</span> <span class="toc-text">3、InputChannel::openInputChannelPair:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、InputManagerService-registerInputChannel："><span class="toc-number">3.4.</span> <span class="toc-text">4、InputManagerService#registerInputChannel：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、NativeInputManager-registerInputChannel"><span class="toc-number">3.5.</span> <span class="toc-text">5、NativeInputManager#registerInputChannel:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、InputDispatcher-registerInputChannel"><span class="toc-number">3.6.</span> <span class="toc-text">6、InputDispatcher#registerInputChannel:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、InputChannel-transferTo："><span class="toc-number">3.7.</span> <span class="toc-text">7、InputChannel#transferTo：</span></a></li></ol></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }

    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })

    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>





    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"View机制深入学习（五） 事件处理机制一　| Liuyunyicai　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2016/05/12/设计模式汇总--结构型模型/" title="上一篇: 设计模式汇总--结构型模式">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2016/05/06/Retrofit源码解析/" title="下一篇: Retrofit源码解析">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/05/16/Fragment源码解析/">Fragment源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/16/Volley源码解析/">Volley源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/15/Picasso源码解析/">Picasso源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/12/设计模式汇总--结构型模型/">设计模式汇总--结构型模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/10/View机制深入学习（五） 事件处理机制一/">View机制深入学习（五） 事件处理机制一</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/06/Retrofit源码解析/">Retrofit源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/06/ArrayMapy、SparseArray源码学习/">ArrayMapy、SparseArray源码学习</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016 流云易采
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8">
  
  <title>Volley源码解析 | Liuyunyicai</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、Volley框架图
图中是官方给出的Volley工作的流程，见右下角的注释，蓝色表示主线程(main thread)，绿色表示缓存线程(cache thread)，黄色表示网络线程(network threads)；再寻找图中的关键字：queue(RequestQueue)，cache queue，CacheDispatcher，NetworkDispatcher;    流程可简单地描述为：">
<meta property="og:type" content="article">
<meta property="og:title" content="Volley源码解析">
<meta property="og:url" content="http://liuyunyicai.github.io/2016/05/16/Volley源码解析/index.html">
<meta property="og:site_name" content="Liuyunyicai">
<meta property="og:description" content="一、Volley框架图
图中是官方给出的Volley工作的流程，见右下角的注释，蓝色表示主线程(main thread)，绿色表示缓存线程(cache thread)，黄色表示网络线程(network threads)；再寻找图中的关键字：queue(RequestQueue)，cache queue，CacheDispatcher，NetworkDispatcher;    流程可简单地描述为：">
<meta property="og:image" content="http://img.blog.csdn.net/20160525170835619">
<meta property="og:image" content="http://img.blog.csdn.net/20160525170851869">
<meta property="og:image" content="http://img.blog.csdn.net/20160525170907087">
<meta property="og:image" content="http://img.blog.csdn.net/20160525170932488">
<meta property="og:image" content="http://img.blog.csdn.net/20160525171031754">
<meta property="og:image" content="http://img.blog.csdn.net/20160525171114193">
<meta property="og:image" content="http://img.blog.csdn.net/20160525171436636">
<meta property="og:image" content="http://img.blog.csdn.net/20160525171508590">
<meta property="og:updated_time" content="2016-05-25T09:17:59.535Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Volley源码解析">
<meta name="twitter:description" content="一、Volley框架图
图中是官方给出的Volley工作的流程，见右下角的注释，蓝色表示主线程(main thread)，绿色表示缓存线程(cache thread)，黄色表示网络线程(network threads)；再寻找图中的关键字：queue(RequestQueue)，cache queue，CacheDispatcher，NetworkDispatcher;    流程可简单地描述为：">
<meta name="twitter:image" content="http://img.blog.csdn.net/20160525170835619">
  
    <link rel="alternative" href="/atom.xml" title="Liuyunyicai" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
      <link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet">
  
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/clipboard.js/1.5.9/clipboard.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
          fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
          scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.0.9/scrollreveal.min.js"
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/liuyunyicai.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">流云易采</a></h1>
        </hgroup>

        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">文章列表</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/979724798@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" target="_blank" href="http://blog.csdn.net/woliuyunyicai" title="CSDN"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">Android,Java</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">流云易采</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/liuyunyicai.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">流云易采</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">文章列表</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/979724798@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" target="_blank" href="http://blog.csdn.net/woliuyunyicai" title="CSDN"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-Volley源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/16/Volley源码解析/" class="article-date">
      <time datetime="2016-05-16T09:04:34.825Z" itemprop="datePublished">2016-05-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Volley源码解析
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="一、Volley框架图"><a href="#一、Volley框架图" class="headerlink" title="一、Volley框架图"></a>一、Volley框架图</h1><p><img src="http://img.blog.csdn.net/20160525170835619" alt="这里写图片描述"></p>
<p>图中是官方给出的Volley工作的流程，见右下角的注释，蓝色表示主线程(main thread)，绿色表示缓存线程(cache thread)，黄色表示网络线程(network threads)；<br>再寻找图中的关键字：queue(RequestQueue)，cache queue，CacheDispatcher，NetworkDispatcher;<br>    流程可简单地描述为：RequestQueue的add()操作将Request添加到缓存队列cache queue中。CacheDispatcher将Request从queue中取出，如果发现缓存中已经保存了相应的结果，则直接从缓存中读取并解析，将response结果回调给主线程。如果缓存中未发现，则将Request添加到网络队列中，进行相应的HTTP transaction等事务处理，将网络请求的结果返回给主线程。</p>
<h1 id="二、Volley系统流程设计图"><a href="#二、Volley系统流程设计图" class="headerlink" title="二、Volley系统流程设计图"></a>二、Volley系统流程设计图</h1><p><img src="http://img.blog.csdn.net/20160525170851869" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160525170907087" alt="这里写图片描述"><br>DispatchThread(Cache层对应CacheDispatcher,Network层对应NetworkDispatcher),不断从RequestQueue获取用户请求，根据是否已经存储在Cache中分别从内存缓存或服务器中来请求数据，然后交由ResponseDelivery进行结果分发和回调处理。</p>
<h1 id="三、概念小结"><a href="#三、概念小结" class="headerlink" title="三、概念小结"></a>三、概念小结</h1><p>上面涉及到的RequestQueue，ResponseDelivery，CacheDispatcher，NetworkDispatcher等概念，对其作用做了简单总结：<br><strong>Volley                   ：</strong>Volley 对外暴露的 API，类中只有两个函数<br>                                通过 newRequestQueue(…) 函数新建并启动一个请求队列RequestQueue。<br><strong>Request<t>          ：</t></strong>表示一个请求的抽象类。<br>                                StringRequest、JsonRequest、ImageRequest 都是它的子类，表示某种类型的请求。<br>                                也可自定义自己的Request<br><strong>RequestQueue      ：</strong>表示请求队列，一个RequestQueue对象包含：<br>                               一个CacheDispatcher(用于处理走缓存请求的调度线程)、<br>                               一个NetworkDispatcher数组(默认数组大小为4，用于处理走网络请求的调度线程)，<br>                               一个ResponseDelivery(返回结果分发接口)，<br>                               在start() 函数启动时会创建启动CacheDispatcher和NetworkDispatchers。<br><strong>CacheDispatcher   ：</strong>Cache层中的一个线程，用于调度处理缓存的请求。<br>                               启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery去执行后续处理。<br>                               当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入NetworkDispatcher去调度处理。<br><strong>NetworkDispatcher：</strong>NetWork层中的一个线程，用于调度处理走网络的请求。<br>                                启动后会不断从网络请求队列中取请求处理，队列为空则等待，<br>                                请求处理结束则将结果传递给ResponseDelivery去执行后续处理，并判断结果是否要进行缓存。<br><strong>ResponseDelivery ：</strong>返回结果分发接口，在创建RequestQueue对象时进行了初始化<br>                              在目前只有基于ExecutorDelivery的在入参 handler 对应线程内进行分发。<br><strong>HttpStack             ：</strong>处理 Http 请求，返回请求结果。在newRequestQueue中被初始化。<br>                              目前 Volley 中有基于 HttpURLConnection 的HurlStack和 基于 Apache HttpClient 的HttpClientStack。<br>                              上一篇中已经对其如何根据Android版本进行选择做了解析。<br><strong>Network               ：</strong>调用HttpStack处理请求，并将结果转换为可被ResponseDelivery处理的NetworkResponse。<br>                               在newRequestQueue中被初始化<br><strong>Cache                   ：</strong>缓存请求结果，Volley 默认使用的是基于 sdcard 的DiskBasedCache。<br>                  NetworkDispatcher得到请求结果后判断是否需要存储在 Cache，CacheDispatcher会从 Cache 中取缓存结果。<br>下面附上每个类之间的关系图：<br><img src="http://img.blog.csdn.net/20160525170932488" alt="这里写图片描述"></p>
<h1 id="四、源码分析："><a href="#四、源码分析：" class="headerlink" title="四、源码分析："></a>四、源码分析：</h1><p>由上图可以得出流程图的入口在于RequestQueue的add()方法，先从RequestQueue的创建看起：</p>
<h2 id="（一）RequestQueue的使用："><a href="#（一）RequestQueue的使用：" class="headerlink" title="（一）RequestQueue的使用："></a>（一）RequestQueue的使用：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RequestQueue mRequestQueue = Volley.newRequestQueue(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>看一下Volley.newRequestQueue的事务逻辑，Volley类中总共就两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Creates a default instance of the worker pool and calls &#123;<span class="doctag">@link</span> RequestQueue#start()&#125; on it.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> newRequestQueue(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的事务主体在这里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Default on-disk cache directory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CACHE_DIR = <span class="string">"volley"</span>;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Creates a default instance of the worker pool and calls &#123;<span class="doctag">@link</span> RequestQueue#start()&#125; on it.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> context A &#123;<span class="doctag">@link</span> Context&#125; to use for creating the cache dir.</span><br><span class="line"> * <span class="doctag">@param</span> stack An &#123;<span class="doctag">@link</span> HttpStack&#125; to use for the network, or null for default.</span><br><span class="line"> * <span class="doctag">@return</span> A started &#123;<span class="doctag">@link</span> RequestQueue&#125; instance.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建cache</span></span><br><span class="line">    File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line"> </span><br><span class="line">    String userAgent = <span class="string">"volley/0"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String packageName = context.getPackageName();</span><br><span class="line">        PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class="number">0</span>);</span><br><span class="line">        userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** 根据博文http://blog.csdn.net/guolin_blog/article/details/12452307，HurlStack是用HttpURLConnection实现的；</span><br><span class="line">        HttpClintStack是由HttpClient实现的；由Android2.3之前的版本宜使用HttpClient，因为其Bug较少；</span><br><span class="line">        Android2.3之后版本宜使用HttpURLConnection，因其较轻量级且API简单；</span><br><span class="line">        故会有此HurlStack和HttpURLConnection的使用分类 */</span></span><br><span class="line">    <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">            stack = <span class="keyword">new</span> HurlStack();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建以stack为参数的Network对象</span></span><br><span class="line">    Network network = <span class="keyword">new</span> BasicNetwork(stack);</span><br><span class="line">    <span class="comment">//创建RequestQueue对象</span></span><br><span class="line">    RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</span><br><span class="line">    queue.start();<span class="comment">//继续向下分析的入口</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-、HurlStack"><a href="#1-、HurlStack" class="headerlink" title="1) 、HurlStack"></a>1) 、HurlStack</h2><p>HurlStack中的部分代码，可以看出其是基于HttpURLClient实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HttpEntity <span class="title">entityFromConnection</span><span class="params">(HttpURLConnection connection)</span></span><br><span class="line"> 对应的HttpClientStack的构造函数可以看出其实基于HttpClient实现的：    </span><br><span class="line"><span class="keyword">public</span> <span class="title">HttpClientStack</span><span class="params">(HttpClient client)</span> </span>&#123;</span><br><span class="line">     mClient = client;</span><br><span class="line"> &#125;</span><br><span class="line"> 而两者都是基于HttpStack接口的：</span><br><span class="line"> <span class="comment">/** An HTTP stack abstraction.*/</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpStack</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">         <span class="keyword">throws</span> IOException, AuthFailureError</span>; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>   由于Android 2.3版本之前，因为HttpURLConnection的BUG较多，HttpClient的API已经较完备，故宜使用HttpClient，故这里版本9之前，选择使用HttpClientStack;<br> Android2.3之后版本，HttpURLConnection不断发展，因其较为轻量级，且API使用较为简单，其也在不断优化性能等，故这里使用基于其的HurlStack;</p>
<h3 id="2-、-Network"><a href="#2-、-Network" class="headerlink" title="2)、 Network"></a>2)、 Network</h3><p>这里引出一个Network对象，看一下构造函数,其用以处理stack传来的网络请求，与主线关系不大，可以不看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * A network performing Volley requests over an &#123;<span class="doctag">@link</span> HttpStack&#125;.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicNetwork</span> <span class="keyword">implements</span> <span class="title">Network</span> </span>&#123;</span><br><span class="line">    ...   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_POOL_SIZE = <span class="number">4096</span>; </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> HttpStack mHttpStack; </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ByteArrayPool mPool;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicNetwork</span><span class="params">(HttpStack httpStack)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If a pool isn't passed in, then build a small default pool that will give us a lot of</span></span><br><span class="line">        <span class="comment">// benefit and not use too much memory.</span></span><br><span class="line">        <span class="keyword">this</span>(httpStack, <span class="keyword">new</span> ByteArrayPool(DEFAULT_POOL_SIZE));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * <span class="doctag">@param</span> httpStack HTTP stack to be used</span><br><span class="line">     * <span class="doctag">@param</span> pool a buffer pool that improves GC performance in copy operations</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicNetwork</span><span class="params">(HttpStack httpStack, ByteArrayPool pool)</span> </span>&#123;</span><br><span class="line">        mHttpStack = httpStack;</span><br><span class="line">        mPool = pool;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存了创建的stack，并创建一个字节数组池（ByteArrayPool）</p>
<h3 id="3-、-RequestQueue"><a href="#3-、-RequestQueue" class="headerlink" title="3)、 RequestQueue"></a>3)、 RequestQueue</h3><p>回到重要的RequestQueue，其构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Number of network request dispatcher threads to start. */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NETWORK_THREAD_POOL_SIZE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(cache, network, threadPoolSize,</span><br><span class="line">               <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span><br><span class="line">    * Creates the worker pool. Processing will not begin until &#123;<span class="doctag">@link</span> #start()&#125; is called.</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> cache A Cache to use for persisting responses to disk</span><br><span class="line">    * <span class="doctag">@param</span> network A Network interface for performing HTTP requests</span><br><span class="line">    * <span class="doctag">@param</span> threadPoolSize Number of network dispatcher threads to create</span><br><span class="line">    * <span class="doctag">@param</span> delivery A ResponseDelivery interface for posting responses and errors</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize,</span><br><span class="line">           ResponseDelivery delivery)</span> </span>&#123;</span><br><span class="line">       mCache = cache;</span><br><span class="line">       mNetwork = network;</span><br><span class="line">       mDispatchers = <span class="keyword">new</span> NetworkDispatcher[threadPoolSize];</span><br><span class="line">       mDelivery = delivery;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在这里创建了之前分析中一个重要的对象：NetworkDispatcher;并且可以看到其类似线程池似的，创建了大小为threadPoolSize的NetworkDispatcher数组；其中的处理逻辑暂且不看，首先可以知道其是一个线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkDispatcher</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure>
<p>总结第一部RequestQueue中add方法所作的工作：<br>1）创建了Cache；<br>2）创建了HttpStack，并由HttpStack为基创建了Network对象；<br>3）创建RequestQueue对象，并在RequestQueue构造函数中创建了大小为threadPoolSize的NetworkDispatcher数组（注并未创建相应NetworkDispatcher对象）<br>4）创建ResponseDelivery对象（new ExecutorDelivery(new Handler(Looper.getMainLooper()))）<br>5）调用RequestQueue.start()函数</p>
<h2 id="（二）从start方法看起："><a href="#（二）从start方法看起：" class="headerlink" title="（二）从start方法看起："></a>（二）从start方法看起：</h2><h3 id="1、RequestQueue-start"><a href="#1、RequestQueue-start" class="headerlink" title="1、RequestQueue.start():"></a>1、RequestQueue.start():</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Starts the dispatchers in this queue.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">publicvoid <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stop();  <span class="comment">// Make sure any currently running dispatchers are stopped.</span></span><br><span class="line">    <span class="comment">// Create the cache dispatcher and start it.</span></span><br><span class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">    mCacheDispatcher.start();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Create network dispatchers (and corresponding threads) up to the pool size.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</span><br><span class="line">                mCache, mDelivery);</span><br><span class="line">        mDispatchers[i] = networkDispatcher;</span><br><span class="line">        networkDispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Stops the cache and network dispatchers.*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCacheDispatcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCacheDispatcher.quit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDispatchers[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mDispatchers[i].quit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>start()依然在做初始化，可以看到创建了一个CacheDispatcher线程（它也是继承Thread的）；又创建了threadPoolSize(默认为4)个NetworkDispatcher线程；则start()后加上主线程，一共有六个线程在运行；回顾之前的流程图，黄色、绿色、蓝色对应的线程都已集齐；黄色线程和绿色线程运行下后台一直在等待网络Request并进行dispatch；<br>    则下面学习的主体落到了两个主要的处理线程CacheDispatcher和NetworkDispathcer上来；试了下，直接看源代码有些困难；先把之前使用Volley的流程走一遍；创建好RequestQueue之后，是创建自己的Request，前面文章已经做了学习；而后是将request通过RequestQueue的add()方法添加进来；</p>
<h3 id="2、RequestQueue-add"><a href="#2、RequestQueue-add" class="headerlink" title="2、RequestQueue.add()"></a>2、RequestQueue.add()</h3><p>下面看一下RequestQueue.add()方法，它是前面流程图运行的入口函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * The set of all requests currently being processed by this RequestQueue. A Request</span><br><span class="line">    * will be in this set if it is waiting in any queue or currently being processed by any dispatcher.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Request&gt; mCurrentRequests = <span class="keyword">new</span> HashSet&lt;Request&gt;();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span><br><span class="line">    * Adds a Request to the dispatch queue.</span><br><span class="line">    * <span class="doctag">@param</span> request The request to service</span><br><span class="line">    * <span class="doctag">@return</span> The passed-in request</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Request <span class="title">add</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Tag the request as belonging to this queue and add it to the set of current requests.</span></span><br><span class="line">       request.setRequestQueue(<span class="keyword">this</span>);  <span class="comment">//见附I Request设置其对应的RequestQueue</span></span><br><span class="line">       <span class="keyword">synchronized</span> (mCurrentRequests) &#123; <span class="comment">//mCurrentRequests表示当前该RequestQueue持有的requests，由HashSet来保存</span></span><br><span class="line">           mCurrentRequests.add(request);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 为新添加的request进行一系列的初始化设置</span></span><br><span class="line">       request.setSequence(getSequenceNumber());</span><br><span class="line">       request.addMarker(<span class="string">"add-to-queue"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 见附II 判断request是否允许缓存</span></span><br><span class="line">       <span class="keyword">if</span> (!request.shouldCache()) &#123;</span><br><span class="line">           mNetworkQueue.add(request);</span><br><span class="line">           <span class="keyword">return</span> request;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//request如果允许缓存 </span></span><br><span class="line">       <span class="comment">//Insert request into stage if there's already a request with the same cache key in flight.</span></span><br><span class="line">       <span class="keyword">synchronized</span> (mWaitingRequests) &#123;  <span class="comment">// 见附III</span></span><br><span class="line">           String cacheKey = request.getCacheKey();</span><br><span class="line">           <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</span><br><span class="line">               <span class="comment">// There is already a request in flight. Queue up.</span></span><br><span class="line">               Queue&lt;Request&gt; stagedRequests = mWaitingRequests.get(cacheKey);</span><br><span class="line">               <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&gt;();</span><br><span class="line">               &#125;</span><br><span class="line">               stagedRequests.add(request);</span><br><span class="line">               mWaitingRequests.put(cacheKey, stagedRequests);</span><br><span class="line">               <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">                   VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Insert 'null' queue for this cacheKey, indicating there is now a request in</span></span><br><span class="line">               <span class="comment">// flight.</span></span><br><span class="line">               mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</span><br><span class="line">               mCacheQueue.add(request);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> request;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-：mCurrentRequests"><a href="#1-：mCurrentRequests" class="headerlink" title="1)：mCurrentRequests"></a>1)：mCurrentRequests</h3><p>mCurrentRequests维护了一个正在进行中，尚未完成的请求集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = <span class="keyword">new</span> HashSet&lt;Request&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="2-、Request-setRequestQueue"><a href="#2-、Request-setRequestQueue" class="headerlink" title="2)、Request.setRequestQueue()"></a>2)、Request.setRequestQueue()</h3><p>字面上可以看出是Request设置其对应的RequestQueue，简单的setter函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The request queue this request is associated with. */</span></span><br><span class="line"><span class="keyword">private</span> RequestQueue mRequestQueue;   </span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Associates this request with the given queue. The request queue will be notified when this</span><br><span class="line"> * request has finished.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestQueue</span><span class="params">(RequestQueue requestQueue)</span> </span>&#123;</span><br><span class="line">    mRequestQueue = requestQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-、request-shouldCache"><a href="#3-、request-shouldCache" class="headerlink" title="3)、request.shouldCache()"></a>3)、request.shouldCache()</h3><p>用以判断该request是否允许缓存（默认允许，可使用setShouldCache(false)来禁止缓存）；如果不允许缓存，则直接将其添加到mNetworkQueue中返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/** The queue of requests that are actually going out to the network. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&gt; mNetworkQueue = <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&gt;();</span><br><span class="line">RequetQueue其实并不是一个真正的Queue，真正存储Request供处理线程去读取和操作的Queue是mNetworkQueue,其类型是PriorityBlockingQueue；</span><br></pre></td></tr></table></figure>
<h3 id="4-、mWaitingRequests"><a href="#4-、mWaitingRequests" class="headerlink" title="4)、mWaitingRequests"></a>4)、mWaitingRequests</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Staging area for requests that already have a duplicate request in flight.</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> *     &lt;li&gt;containsKey(cacheKey) indicates that there is a request in flight for the given cache</span><br><span class="line"> *          key.&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;get(cacheKey) returns waiting requests for the given cache key. The in flight request</span><br><span class="line"> *          is &lt;em&gt;not&lt;/em&gt; contained in that list. Is null if no requests are staged.&lt;/li&gt;</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Queue&lt;Request&gt;&gt; mWaitingRequests = <span class="keyword">new</span> HashMap&lt;String, Queue&lt;Request&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>维护了一个等待请求的集合，如果一个请求正在被处理并且可以被缓存，后续的相同 url 的请求，将进入此等待队列。<br>函数：<br><strong>containsKey(cacheKey):</strong>  true表明对于给定的cache key，已经存在了一个request<br>         <strong>get(cacheKey)            :</strong>  返回对于给定cache key对应的waiting requests，即Queue<request><br>其存储request的整个工作流程为：<br><img src="http://img.blog.csdn.net/20160525171031754" alt="这里写图片描述"><br>1）对于每个新add的request,先获取它的CacheKey;<br>2）如果当前mWaitingRequests不存在当前cachekey，则会put(cacheKey, null);null表示当前Map中已经存在了一个对应cacheKey的请求；<br>3）如果mWaitingRequests已经存在了对应的cacheKey，通过get(Key)获取cacheKey对应的Queue;如果Queue为null，由第二步知，当前cacheKey仅仅对应一个request,则新建对应的Map Value值——Queue<request>（这里由LinkedList来实现），然后添加进去即可；<br>附IV）mCacheQueue和mNetworkQueue是想对应存在的：<br>mCacheQueue 放在缓存请求队列中的 Request，将通过缓存获取数据；<br>mNetworkQueue放在网络请求队列中的 Request，将通过网络获取数据。</request></request></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue = <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue = <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure>
<h1 id="五、CacheDispatcher："><a href="#五、CacheDispatcher：" class="headerlink" title="五、CacheDispatcher："></a>五、CacheDispatcher：</h1><p>一个线程，用于调度处理走缓存的请求。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery 去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入NetworkDispatcher去调度处理。</p>
<h2 id="（一）成员变量"><a href="#（一）成员变量" class="headerlink" title="（一）成员变量"></a>（一）成员变量</h2><p>看源码前，先看一下从其成员变量与处理流程：</p>
<h3 id="1-成员变量"><a href="#1-成员变量" class="headerlink" title="(1). 成员变量"></a>(1). 成员变量</h3><p><strong>BlockingQueue<request<?>&gt; mCacheQueue</request<?></strong>     缓存请求队列<br><strong>BlockingQueue<request<?>&gt; mNetworkQueue</request<?></strong> 网络请求队列<br><strong>Cache mCache</strong>                                                缓存类，代表了一个可以获取请求结果，存储请求结果的缓存<br><strong>ResponseDelivery mDelivery</strong>                        请求结果传递类</p>
<h3 id="2-处理流程图"><a href="#2-处理流程图" class="headerlink" title="(2). 处理流程图"></a>(2). 处理流程图</h3><p><img src="http://img.blog.csdn.net/20160525171114193" alt="这里写图片描述"></p>
<h3 id="3-源码："><a href="#3-源码：" class="headerlink" title="(3)源码："></a>(3)源码：</h3><h4 id="1、构造函数："><a href="#1、构造函数：" class="headerlink" title="1、构造函数："></a>1、构造函数：</h4><p>一系列赋值初始化操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Creates a new cache triage dispatcher thread.  You must call &#123;<span class="doctag">@link</span> #start()&#125;</span><br><span class="line">    * in order to begin processing.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CacheDispatcher</span><span class="params">(BlockingQueue&lt;Request&gt; cacheQueue, BlockingQueue&lt;Request&gt; networkQueue,</span><br><span class="line">           Cache cache, ResponseDelivery delivery)</span> </span>&#123;</span><br><span class="line">       mCacheQueue = cacheQueue;</span><br><span class="line">       mNetworkQueue = networkQueue;</span><br><span class="line">       mCache = cache;</span><br><span class="line">       mDelivery = delivery;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 提到使用CacheDispatcher时一定要调用start()方法；而CacheDispatcher的创建与线程start都是在RequestQueue中的add()函数中实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the cache dispatcher and start it.</span></span><br><span class="line">   mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">   mCacheDispatcher.start();</span><br></pre></td></tr></table></figure>
<h4 id="2、看起执行逻辑："><a href="#2、看起执行逻辑：" class="headerlink" title="2、看起执行逻辑："></a>2、看起执行逻辑：</h4><p>既然是线程，重点看其run()函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置优先级</span></span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">    <span class="comment">// Make a blocking call to initialize the cache.</span></span><br><span class="line">    <span class="comment">//这里的Cache其实是DiskBasedCache，见附I</span></span><br><span class="line">    mCache.initialize();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*****循环处理逻辑******/</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从缓存队列 mCacheQueue中取出一个Request；如果mCacheQueue为空，则阻塞进行忙等待</span></span><br><span class="line">            <span class="keyword">final</span> Request request = mCacheQueue.take();</span><br><span class="line">            request.addMarker(<span class="string">"cache-queue-take"</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 如果取出的Request请求已经被取消，则直接finish,处理下一个request</span></span><br><span class="line">            <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">                request.finish(<span class="string">"cache-discard-canceled"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 尝试从缓存中获取request对应的结果</span></span><br><span class="line">            Cache.Entry entry = mCache.get(request.getCacheKey());</span><br><span class="line">           </span><br><span class="line">            <span class="comment">//为null，表示该cacheKey对应缓存结果不存在，则直接将request添加到mNetworkQueue中</span></span><br><span class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                request.addMarker(<span class="string">"cache-miss"</span>);</span><br><span class="line">                mNetworkQueue.put(request);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//如果缓存结果存在，但是已过期，同样也是将request添加到mNetworkQueue中</span></span><br><span class="line">            <span class="keyword">if</span> (entry.isExpired()) &#123;</span><br><span class="line">                request.addMarker(<span class="string">"cache-hit-expired"</span>);</span><br><span class="line">                request.setCacheEntry(entry);</span><br><span class="line">                mNetworkQueue.put(request);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 如果命中(hit)找到了对应的缓存结果，则解析其数据为Response并返回给该request</span></span><br><span class="line">            request.addMarker(<span class="string">"cache-hit"</span>);</span><br><span class="line">            Response&lt;?&gt; response = request.parseNetworkResponse(</span><br><span class="line">                    <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">            request.addMarker(<span class="string">"cache-hit-parsed"</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 还需判断缓存结果是否时间过久已经不新鲜，是否需要refresh</span></span><br><span class="line">            <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</span><br><span class="line">              <span class="comment">// 不需要Refresh,则直接由mDelivery提交给相应的request</span></span><br><span class="line">                mDelivery.postResponse(request, response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果已经不新鲜，mDelivery依旧提交结果给request，</span></span><br><span class="line">              <span class="comment">// 但同时要将Request传递给mNetworkQueue进行新鲜度验证</span></span><br><span class="line">                request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</span><br><span class="line">                request.setCacheEntry(entry);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// Mark the response as intermediate.</span></span><br><span class="line">                response.intermediate = <span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// Post the intermediate response back to the user and have</span></span><br><span class="line">                <span class="comment">// the delivery then forward the request along to the network.</span></span><br><span class="line">                mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            mNetworkQueue.put(request);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// We may have been interrupted because it was time to quit.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的Cache实际是DiskBasedCache，mCache.initialize()实际上调用的是DiskBasedCache.initialize():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Initializes the DiskBasedCache by scanning for all files currently in the</span><br><span class="line">    * specified root directory. Creates the root directory if necessary.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h1 id="六、NetworkDispatcher"><a href="#六、NetworkDispatcher" class="headerlink" title="六、NetworkDispatcher"></a>六、NetworkDispatcher</h1><p>一个线程，用于调度处理网络的请求。启动后会不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给 ResponseDelivery 去执行后续处理，并判断结果是否要进行缓存。</p>
<h2 id="1-成员变量-1"><a href="#1-成员变量-1" class="headerlink" title="(1). 成员变量"></a>(1). 成员变量</h2><p><strong>BlockingQueue<request<?>&gt; mQueue</request<?></strong> 网络请求队列<br><strong>Network mNetwork</strong>                             网络类，代表了一个可以执行请求的网络<br><strong>Cache mCache</strong>                                    缓存类，代表了一个可以获取请求结果，存储请求结果的缓存<br><strong>ResponseDelivery mDelivery</strong>           请求结果传递类，可以传递请求的结果或者错误到调用者</p>
<h2 id="2-处理流程图-1"><a href="#2-处理流程图-1" class="headerlink" title="(2). 处理流程图"></a>(2). 处理流程图</h2><p><img src="http://img.blog.csdn.net/20160525171436636" alt="这里写图片描述"></p>
<h2 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="(3).构造函数"></a>(3).构造函数</h2><p>先看其构造函数，与CacheDispatcher的逻辑处理大致相同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Creates a new network dispatcher thread.  You must call &#123;<span class="doctag">@link</span> #start()&#125;</span><br><span class="line">    * in order to begin processing.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NetworkDispatcher</span><span class="params">(BlockingQueue&lt;Request&gt; queue,</span><br><span class="line">           Network network, Cache cache,</span><br><span class="line">           ResponseDelivery delivery)</span> </span>&#123;</span><br><span class="line">       mQueue = queue;</span><br><span class="line">       mNetwork = network;</span><br><span class="line">       mCache = cache;</span><br><span class="line">       mDelivery = delivery;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-其run-函数："><a href="#4-其run-函数：" class="headerlink" title="(4).其run()函数："></a>(4).其run()函数：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//设为后台进程</span></span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">    Request request;</span><br><span class="line">    <span class="comment">/*********循环处理逻辑********/</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从网络请求队列中取出request，同理mQueue为空时，也是忙等待</span></span><br><span class="line">            request = mQueue.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            request.addMarker(<span class="string">"network-queue-take"</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 如果取出的Request请求已经被取消，则直接finish,处理下一个request</span></span><br><span class="line">            <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">                request.finish(<span class="string">"network-discard-cancelled"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Tag the request (if API &gt;= 14)</span></span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">                TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 通过Network执行Request，获得NetworkResponse，故网络请求的处理逻辑应该都封装在了Network中</span></span><br><span class="line">            NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class="line">            request.addMarker(<span class="string">"network-http-complete"</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 用来验证新鲜度，（notModified=304）响应为304且请求已经有了Response传输情况</span></span><br><span class="line">            <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">                request.finish(<span class="string">"not-modified"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 将NetworkResponse解析为Response</span></span><br><span class="line">            Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">            request.addMarker(<span class="string">"network-parse-complete"</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 如果request可以被缓存，并且其请求实体补位空，则添加到mCache中</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Only update cache metadata instead of entire record for 304s.</span></span><br><span class="line">            <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">                request.addMarker(<span class="string">"network-cache-written"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 传输Response</span></span><br><span class="line">            request.markDelivered();</span><br><span class="line">            mDelivery.postResponse(request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</span><br><span class="line">            parseAndDeliverNetworkError(request, volleyError);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</span><br><span class="line">            mDelivery.postError(request, <span class="keyword">new</span> VolleyError(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="七、Network"><a href="#七、Network" class="headerlink" title="七、Network"></a>七、Network</h1><p>在NetworkDispatcher中需要处理的网络请求，由下面进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br></pre></td></tr></table></figure>
<p>看一下mNetwork的定义：（定义在NetworkDispatcher中）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/** The network interface for processing requests. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Network mNetwork;</span><br><span class="line">NetworkDispatcher.mNetwork初始化发生在RequestQueue.start()中：</span><br><span class="line">    NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</span><br><span class="line">         mCache, mDelivery);</span><br></pre></td></tr></table></figure>
<p>而RequestQueue.mNetwork是在其构造函数中传入的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize,</span><br><span class="line">        ResponseDelivery delivery)</span> </span>&#123;</span><br><span class="line">    mCache = cache;</span><br><span class="line">    mNetwork = network;</span><br><span class="line">    mDispatchers = <span class="keyword">new</span> NetworkDispatcher[threadPoolSize];</span><br><span class="line">    mDelivery = delivery;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由前面分析知RequestQueue的构建是在Volley.newRequestQueue中实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建以stack为参数的Network对象</span></span><br><span class="line">Network network = <span class="keyword">new</span> BasicNetwork(stack);</span><br><span class="line"><span class="comment">//创建RequestQueue对象</span></span><br><span class="line">RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</span><br><span class="line">queue.start();<span class="comment">//继续向下分析的入口</span></span><br></pre></td></tr></table></figure>
<p> 可以看出mNetwork其实是BasicNetwork对象。<br>    则NetworkResponse中mNetwork实际上调用的是BasicNetwork.performRequest(),这是一个专门用来处理网络请求的函数，其作用为调用HttpStack处理请求，并将结果转换为可被ResponseDelivery处理的NetworkResponse。<br>看一下其源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">         HttpResponse httpResponse = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</span><br><span class="line">         Map&lt;String, String&gt; responseHeaders = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">/** 忽略网络处理的细节*/</span></span><br><span class="line">             <span class="comment">// Gather headers.</span></span><br><span class="line">             Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">             addCacheHeaders(headers, request.getCacheEntry());</span><br><span class="line">            </span><br><span class="line">             <span class="comment">/**执行网络请求</span><br><span class="line">              * 这里调用了HttpStack.performRequest，并得到一个HttpResponse返回结果*/</span></span><br><span class="line">             httpResponse = mHttpStack.performRequest(request, headers);</span><br><span class="line">            </span><br><span class="line">             StatusLine statusLine = httpResponse.getStatusLine();</span><br><span class="line">             <span class="keyword">int</span> statusCode = statusLine.getStatusCode();</span><br><span class="line">             responseHeaders = convertHeaders(httpResponse.getAllHeaders());</span><br><span class="line"> </span><br><span class="line">             <span class="comment">/**新鲜度验证：</span><br><span class="line">              * 304 Not Modified：客户端有缓冲的文件并发出了一个条件性的请求</span><br><span class="line">              * （一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。</span><br><span class="line">              * 服务器告诉客户，原来缓冲的文档还可以继续使用。*/</span></span><br><span class="line">             <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</span><br><span class="line">               <span class="comment">/** 解析成NetworkResponse，返回*/</span></span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED,</span><br><span class="line">                         request.getCacheEntry().data, responseHeaders, <span class="keyword">true</span>);</span><br><span class="line">             &#125;</span><br><span class="line"> </span><br><span class="line">             <span class="comment">// 判断responses是否有实体信息，一些响应如204，并不包含content，所以需要验证</span></span><br><span class="line">             <span class="keyword">if</span> (httpResponse.getEntity() != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//实体信息转化成byte[]</span></span><br><span class="line">                 responseContents = entityToBytes(httpResponse.getEntity());</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 无实体信息情况</span></span><br><span class="line">               responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">             &#125;</span><br><span class="line"> </span><br><span class="line">             <span class="comment">// 超时情况处理.</span></span><br><span class="line">             <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</span><br><span class="line">             logSlowRequests(requestLifetime, request, responseContents, statusLine);</span><br><span class="line"> </span><br><span class="line">             <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class="keyword">false</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">             attemptRetryOnException(<span class="string">"socket"</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">         &#125; <span class="keyword">catch</span> (ConnectTimeoutException e) &#123;</span><br><span class="line">             attemptRetryOnException(<span class="string">"connection"</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">         &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Bad URL "</span> + request.getUrl(), e);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">             ...</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 总结一下Network.performRequest所做的工作：<br>1、由传入的HttpStack对象执行网络请求：mHttpStack.performRequest()<br>2、解析响应结果，将HttpResponse解析成NetworkResponse;<br>3、对返回结果进行新鲜度验证（304）<br>4、将response的实体信息转化为byte数组<br>5、超时情况处理，如果发生超时，认证失败等错误，进行重试操作(attemptRetryOnException)，直到成功、抛出异常(不满足重试策略等)结束。</p>
<p>attemptRetryOnException()是根据重试策略进行请求重试操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">   * Attempts to prepare the request for a retry. If there are no more attempts remaining in the</span><br><span class="line">   * request's retry policy, a timeout exception is thrown.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attemptRetryOnException</span><span class="params">(String logPrefix, Request&lt;?&gt; request,</span><br><span class="line">          VolleyError exception)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">      RetryPolicy retryPolicy = request.getRetryPolicy();</span><br><span class="line">      <span class="keyword">int</span> oldTimeout = request.getTimeoutMs();</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          retryPolicy.retry(exception);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (VolleyError e) &#123;</span><br><span class="line">          request.addMarker(</span><br><span class="line">                  String.format(<span class="string">"%s-timeout-giveup [timeout=%s]"</span>, logPrefix, oldTimeout));</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">      request.addMarker(String.format(<span class="string">"%s-retry [timeout=%s]"</span>, logPrefix, oldTimeout));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="八、HttpClientStack、HurlStack"><a href="#八、HttpClientStack、HurlStack" class="headerlink" title="八、HttpClientStack、HurlStack"></a>八、HttpClientStack、HurlStack</h1><p>据上面源码知，网络请求处理的逻辑实际上是交由传进来的参数HttpStack进行处理。前面已经分析过，Android2.3之前使用 HttpClientStack，之后使用HurlStack；</p>
<h2 id="1、先看两者的父类HttpStack"><a href="#1、先看两者的父类HttpStack" class="headerlink" title="1、先看两者的父类HttpStack:"></a>1、先看两者的父类HttpStack:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Performs an HTTP request with the given parameters.</span><br><span class="line">     * &lt;p&gt;A GET request is sent if request.getPostBody() == null. A POST request is sent otherwise,</span><br><span class="line">     * and the Content-Type header is set to request.getPostBodyContentType().&lt;/p&gt;</span><br><span class="line">     * <span class="doctag">@param</span> request the request to perform</span><br><span class="line">     * <span class="doctag">@param</span> 发起请求之前，添加额外的请求 Headers &#123;<span class="doctag">@link</span> Request#getHeaders()&#125;</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、HttpClientStack-使用HttpClient来实现"><a href="#2、HttpClientStack-使用HttpClient来实现" class="headerlink" title="2、HttpClientStack(使用HttpClient来实现)"></a>2、HttpClientStack(使用HttpClient来实现)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError </span>&#123;</span><br><span class="line">    HttpUriRequest httpRequest = createHttpRequest(request, additionalHeaders);<span class="comment">//见附一</span></span><br><span class="line">    addHeaders(httpRequest, additionalHeaders);</span><br><span class="line">    addHeaders(httpRequest, request.getHeaders());</span><br><span class="line">    onPrepareRequest(httpRequest);<span class="comment">// Nothing.空函数，用于重写；该函数在request被excute之前被调用</span></span><br><span class="line">    <span class="comment">//一些网络设置</span></span><br><span class="line">    HttpParams httpParams = httpRequest.getParams();</span><br><span class="line">    <span class="keyword">int</span> timeoutMs = request.getTimeoutMs();</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Reevaluate this connection timeout based on more wide-scale</span></span><br><span class="line">    <span class="comment">// data collection and possibly different for wifi vs. 3G.</span></span><br><span class="line">    HttpConnectionParams.setConnectionTimeout(httpParams, <span class="number">5000</span>);</span><br><span class="line">    HttpConnectionParams.setSoTimeout(httpParams, timeoutMs);</span><br><span class="line">    <span class="keyword">return</span> mClient.execute(httpRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1）：createHttpRequest函数："><a href="#1）：createHttpRequest函数：" class="headerlink" title="1）：createHttpRequest函数："></a>1）：createHttpRequest函数：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 根据传进来的request来构造合适的HttpUriRequest</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> HttpUriRequest <span class="title">createHttpRequest</span><span class="params">(Request&lt;?&gt; request,</span><br><span class="line">        Map&lt;String, String&gt; additionalHeaders)</span> <span class="keyword">throws</span> AuthFailureError </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (request.getMethod()) &#123;</span><br><span class="line">        <span class="keyword">case</span> Method.DEPRECATED_GET_OR_POST: &#123;</span><br><span class="line">            <span class="comment">// This is the deprecated way that needs to be handled for backwards compatibility.</span></span><br><span class="line">            <span class="comment">// If the request's post body is null, then the assumption is that the request is</span></span><br><span class="line">            <span class="comment">// GET.  Otherwise, it is assumed that the request is a POST.</span></span><br><span class="line">            <span class="keyword">byte</span>[] postBody = request.getPostBody();</span><br><span class="line">            <span class="keyword">if</span> (postBody != <span class="keyword">null</span>) &#123;</span><br><span class="line">                HttpPost postRequest = <span class="keyword">new</span> HttpPost(request.getUrl());</span><br><span class="line">                postRequest.addHeader(HEADER_CONTENT_TYPE, request.getPostBodyContentType());</span><br><span class="line">                HttpEntity entity;</span><br><span class="line">                entity = <span class="keyword">new</span> ByteArrayEntity(postBody);</span><br><span class="line">                postRequest.setEntity(entity);</span><br><span class="line">                <span class="keyword">return</span> postRequest;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HttpGet(request.getUrl());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/***********一般较多使用的是POST与GET，其等同于HttpClient的一般使用流程***************/</span></span><br><span class="line">        <span class="keyword">case</span> Method.GET:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HttpGet(request.getUrl());</span><br><span class="line">        <span class="keyword">case</span> Method.DELETE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HttpDelete(request.getUrl());</span><br><span class="line">        <span class="keyword">case</span> Method.POST: &#123;</span><br><span class="line">            HttpPost postRequest = <span class="keyword">new</span> HttpPost(request.getUrl());</span><br><span class="line">            <span class="comment">//这里就看到了前面实现Request时，重写getBodyContentType（）函数的意义</span></span><br><span class="line">            postRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());</span><br><span class="line">            setEntityIfNonEmptyBody(postRequest, request);</span><br><span class="line">            <span class="keyword">return</span> postRequest;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Method.PUT: &#123;</span><br><span class="line">            HttpPut putRequest = <span class="keyword">new</span> HttpPut(request.getUrl());</span><br><span class="line">            putRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());</span><br><span class="line">            setEntityIfNonEmptyBody(putRequest, request);</span><br><span class="line">            <span class="keyword">return</span> putRequest;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown request method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、HurlStack-由HttpURLConnection来实现"><a href="#3、HurlStack-由HttpURLConnection来实现" class="headerlink" title="3、HurlStack(由HttpURLConnection来实现)"></a>3、HurlStack(由HttpURLConnection来实现)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError </span>&#123;</span><br><span class="line">    String url = request.getUrl();</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.putAll(request.getHeaders());</span><br><span class="line">    map.putAll(additionalHeaders);</span><br><span class="line">    <span class="comment">//UrlRewriter见附一</span></span><br><span class="line">    <span class="keyword">if</span> (mUrlRewriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String rewritten = mUrlRewriter.rewriteUrl(url);</span><br><span class="line">        <span class="keyword">if</span> (rewritten == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="function">thrownew <span class="title">IOException</span><span class="params">(<span class="string">"URL blocked by rewriter: "</span> + url)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        url = rewritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**************HttpURLConnection的一般使用流程*******************/</span></span><br><span class="line">    URL parsedUrl = <span class="keyword">new</span> URL(url);</span><br><span class="line">    HttpURLConnection connection = openConnection(parsedUrl, request);</span><br><span class="line">    <span class="keyword">for</span> (String headerName : map.keySet()) &#123;</span><br><span class="line">        connection.addRequestProperty(headerName, map.get(headerName));</span><br><span class="line">    &#125;</span><br><span class="line">    setConnectionParametersForRequest(connection, request);</span><br><span class="line">    <span class="comment">// Initialize HttpResponse with data from the HttpURLConnection.</span></span><br><span class="line">    ProtocolVersion protocolVersion = <span class="keyword">new</span> ProtocolVersion(<span class="string">"HTTP"</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> responseCode = connection.getResponseCode();</span><br><span class="line">    <span class="keyword">if</span> (responseCode == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// -1 is returned by getResponseCode() if the response code could not be retrieved.</span></span><br><span class="line">        <span class="comment">// Signal to the caller that something was wrong with the connection.</span></span><br><span class="line">        <span class="function">thrownew <span class="title">IOException</span><span class="params">(<span class="string">"Could not retrieve response code from HttpUrlConnection."</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StatusLine responseStatus = <span class="keyword">new</span> BasicStatusLine(protocolVersion,</span><br><span class="line">            connection.getResponseCode(), connection.getResponseMessage());</span><br><span class="line">    BasicHttpResponse response = <span class="keyword">new</span> BasicHttpResponse(responseStatus);</span><br><span class="line">    response.setEntity(entityFromConnection(connection));</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, List&lt;String&gt;&gt; header : connection.getHeaderFields().entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (header.getKey() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Header h = <span class="keyword">new</span> BasicHeader(header.getKey(), header.getValue().get(<span class="number">0</span>));</span><br><span class="line">            response.addHeader(h);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1）：UrlRewriter"><a href="#1）：UrlRewriter" class="headerlink" title="1）：UrlRewriter"></a>1）：UrlRewriter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 对URLs在使用前进行重写转换*/</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UrlRewriter</span> </span>&#123;</span><br><span class="line">     <span class="comment">/**</span><br><span class="line">      * Returns a URL to use instead of the provided one, or null to indicate</span><br><span class="line">      * this URL should not be used at all.</span><br><span class="line">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">rewriteUrl</span><span class="params">(String originalUrl)</span></span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>参数mUrlRewriter通过HttpStack的构造函数传入进来，故可以自行进行定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HurlStack</span><span class="params">(UrlRewriter urlRewriter, SSLSocketFactory sslSocketFactory)</span> </span>&#123;</span><br><span class="line">    mUrlRewriter = urlRewriter;</span><br><span class="line">    mSslSocketFactory = sslSocketFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="九、NetworkResponse"><a href="#九、NetworkResponse" class="headerlink" title="九、NetworkResponse"></a>九、NetworkResponse</h1><p>回到起点NetworkDispatcher（Thread）中的run()函数，其中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br></pre></td></tr></table></figure>
<p>下面继续看NetworkResponse的源码：<br>NetworkResponse类很简单，仅是用以在多个类中传递数据，其成员变量：</p>
<h2 id="1）成员变量"><a href="#1）成员变量" class="headerlink" title="1）成员变量"></a>1）成员变量</h2><p><strong>int statusCode Http</strong> 响应状态码<br><strong>byte[] data Body</strong> 数据<br><strong>Map<string, string=""> headers</string,></strong> 响应 Headers<br><strong>boolean notModified</strong> 表示是否为 304 响应<br><strong>long networkTimeMs</strong> 请求耗时</p>
<h2 id="2）其主体只为几个构造函数："><a href="#2）其主体只为几个构造函数：" class="headerlink" title="2）其主体只为几个构造函数："></a>2）其主体只为几个构造函数：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NetworkResponse</span><span class="params">(<span class="keyword">int</span> statusCode, <span class="keyword">byte</span>[] data, Map&lt;String, String&gt; headers,</span><br><span class="line">         <span class="keyword">boolean</span> notModified)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.statusCode = statusCode;</span><br><span class="line">     <span class="keyword">this</span>.data = data;</span><br><span class="line">     <span class="keyword">this</span>.headers = headers;</span><br><span class="line">     <span class="keyword">this</span>.notModified = notModified;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">NetworkResponse</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(HttpStatus.SC_OK, data, Collections.&lt;String, String&gt;emptyMap(), <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">NetworkResponse</span><span class="params">(<span class="keyword">byte</span>[] data, Map&lt;String, String&gt; headers)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(HttpStatus.SC_OK, data, headers, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>3）回顾一下前面分析的设计NetworkResponse的类之间数据的传递关系：<br><img src="http://img.blog.csdn.net/20160525171508590" alt="这里写图片描述"></p>
<p>这里的主体是根据NetworkDispatcher.run()函数进行分析的<br>0、函数中调用Network.performRequest();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br></pre></td></tr></table></figure>
<p> 而Network.performRequest()是基于HttpStack实现的；<br>1、HttpClientStack与HurlStack（分别基于HttpClient与HttpURLConnection实现）中的public HttpResponse performRequest()函数返回HttpResponse ；<br>2、Network（实际为BasicNetwork）中performRequest()方法，使用1中的两个HttpStack类，获取到其返回值HttpResponse，然后将其解析成为NetworkResponse;<br>3、Request中 <code>abstract protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response);</code><br>    将NetworkResponse解析成Response;<br>    而该函数的调用是在NetworkDispatcher中的run()函数中调用的；<br>4、在NetworkDispatcher.run(）的最后一步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mDelivery.postResponse(request, response);</span><br></pre></td></tr></table></figure>
<p>将response传递给了ResponseDelivery<br>后面继续看Delivery的逻辑；<br>ResponseDelivery mDelivery的实际类型是ExecutorDelivery：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(cache, network, threadPoolSize,</span><br><span class="line">            <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make an Executor that just wraps the handler.</span></span><br><span class="line">    mResponsePoster = <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">            handler.post(command);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到很简单，就是使用主线程的Looper构建一个Handler，下面所有的post操作都是调用这个Handler来执行Runnable;<br>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">    request.markDelivered();</span><br><span class="line">    request.addMarker(<span class="string">"post-response"</span>);</span><br><span class="line">    mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将传递来的Response转化为ResponseDeliveryRunnable ，显然这是一个Runnable;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDeliveryRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Request mRequest;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Response mResponse;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mRunnable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseDeliveryRunnable</span><span class="params">(Request request, Response response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">        mRequest = request;</span><br><span class="line">        mResponse = response;</span><br><span class="line">        mRunnable = runnable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If this request has canceled, finish it and don't deliver.</span></span><br><span class="line">        <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</span><br><span class="line">            mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deliver a normal response or error, depending.</span></span><br><span class="line">        <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</span><br><span class="line">            mRequest.deliverResponse(mResponse.result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mRequest.deliverError(mResponse.error);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this is an intermediate response, add a marker, otherwise we're done</span></span><br><span class="line">        <span class="comment">// and the request can be finished.</span></span><br><span class="line">        <span class="keyword">if</span> (mResponse.intermediate) &#123;</span><br><span class="line">            mRequest.addMarker(<span class="string">"intermediate-response"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mRequest.finish(<span class="string">"done"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we have been provided a post-delivery runnable, run it.</span></span><br><span class="line">        <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mRunnable.run();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个子线程中，转而调用 Request来deliverResponse：<br>以StringRequest为例，来看这个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mListener.onResponse(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个Listener就是自己在定义Request的时候声明的ResponseListener，可以看到这个Listener工作在子线程中，所以如果要更新界面，注意使用Handler把消息传递主线程进行处理。</p>
<h1 id="十、Volley图片加载的实现"><a href="#十、Volley图片加载的实现" class="headerlink" title="十、Volley图片加载的实现"></a>十、Volley图片加载的实现</h1><p>Volley的图片加载主要还是基于上面的原理来实现的，具体如下：<br><strong>ImageLoader的使用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ImageLoader</span></span><br><span class="line">imageLoader = <span class="keyword">new</span> ImageLoader(httpUtils.getRequestQueue(), imageCache);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ImageLoader</span><span class="params">(RequestQueue queue, ImageCache imageCache)</span> </span>&#123;</span><br><span class="line">    mRequestQueue = queue;</span><br><span class="line">    mCache = imageCache;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面的ImageCache是自定义的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取最大内存缓存大小</span></span><br><span class="line"><span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);</span><br><span class="line">MAX_CACHE_SIZE = maxMemory / <span class="number">8</span>; <span class="comment">// 定义为应用最大缓存的1/8</span></span><br><span class="line"></span><br><span class="line">mImageLruCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(MAX_CACHE_SIZE)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String url, Bitmap bitmap)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bitmap.getRowBytes() * bitmap.getHeight() / <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建ImageCache</span></span><br><span class="line">imageCache = <span class="keyword">new</span> ImageLoader.ImageCache() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putBitmap</span><span class="params">(String url, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">        mImageLruCache.put(url, bitmap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmap</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mImageLruCache.get(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用LruCache来实现ImageCache接口，实现图片的内存缓存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmap</span><span class="params">(String url)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putBitmap</span><span class="params">(String url, Bitmap bitmap)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载图片时的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imageListener = ImageLoader.getImageListener(myImageView, default_pg, failed_pg);</span><br><span class="line">imageLoader.get(imageUrl, imageListener);</span><br></pre></td></tr></table></figure>
<p>来到ImageLoader#get:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ImageContainer <span class="title">get</span><span class="params">(String requestUrl, <span class="keyword">final</span> ImageListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(requestUrl, listener, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ImageContainer <span class="title">get</span><span class="params">(String requestUrl, ImageListener imageListener,</span><br><span class="line">                          <span class="keyword">int</span> maxWidth, <span class="keyword">int</span> maxHeight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(requestUrl, imageListener, maxWidth, maxHeight, ImageView.ScaleType.CENTER_INSIDE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ImageContainer <span class="title">get</span><span class="params">(String requestUrl, ImageListener imageListener,</span><br><span class="line">                          <span class="keyword">int</span> maxWidth, <span class="keyword">int</span> maxHeight, ImageView.ScaleType scaleType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果操作不是在主线程，则直接抛出异常</span></span><br><span class="line">    throwIfNotOnMainThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为图片的URL创建一个特定的cacheKey，注意这个cache还和图片的大小及scaleType相关</span></span><br><span class="line">    <span class="keyword">final</span> String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight, scaleType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里会使用自定义的LruCache去获取一个Bitmap实例</span></span><br><span class="line">    Bitmap cachedBitmap = mCache.getBitmap(cacheKey);</span><br><span class="line">    <span class="comment">// 如果缓存中已经存在，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (cachedBitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Return the cached bitmap.</span></span><br><span class="line">        ImageContainer container = <span class="keyword">new</span> ImageContainer(cachedBitmap, requestUrl, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        imageListener.onResponse(container, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存中不存在，则进行获取</span></span><br><span class="line">    ImageContainer imageContainer =</span><br><span class="line">            <span class="keyword">new</span> ImageContainer(<span class="keyword">null</span>, requestUrl, cacheKey, imageListener);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知Observer这时可以使用默认的图片</span></span><br><span class="line">    imageListener.onResponse(imageContainer, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否已经有了一个相同的请求在等待</span></span><br><span class="line">    BatchedImageRequest request = mInFlightRequests.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If it is, add this request to the list of listeners.</span></span><br><span class="line">        request.addContainer(imageContainer);</span><br><span class="line">        <span class="keyword">return</span> imageContainer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Request，重复之前的流程</span></span><br><span class="line">    Request&lt;Bitmap&gt; newRequest = makeImageRequest(requestUrl, maxWidth, maxHeight, scaleType,</span><br><span class="line">            cacheKey);</span><br><span class="line"></span><br><span class="line">    mRequestQueue.add(newRequest);</span><br><span class="line">    mInFlightRequests.put(cacheKey,</span><br><span class="line">            <span class="keyword">new</span> BatchedImageRequest(newRequest, imageContainer));</span><br><span class="line">    <span class="keyword">return</span> imageContainer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理逻辑大致和前面的addRequest相同，首先判断缓存中是否已经存在该url对应的bitmap，如果存在直接返回；如果不存在，先判断是否已经有了一个相同的请求在等待，如果是，把这个请求添加到监听者链表中；如果不存在，则创建一个Request<bitmap>，添加到RequestQueue中，从网络中去获取；从网络中获取的流程和前面分析的相同。</bitmap></p>
<p><strong>先来看Request<bitmap>:</bitmap></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Request&lt;Bitmap&gt; <span class="title">makeImageRequest</span><span class="params">(String requestUrl, <span class="keyword">int</span> maxWidth, <span class="keyword">int</span> maxHeight,</span><br><span class="line">        ScaleType scaleType, <span class="keyword">final</span> String cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImageRequest(requestUrl, <span class="keyword">new</span> Listener&lt;Bitmap&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Bitmap response)</span> </span>&#123;</span><br><span class="line">            onGetImageSuccess(cacheKey, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, maxWidth, maxHeight, scaleType, Config.RGB_565, <span class="keyword">new</span> ErrorListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">            onGetImageError(cacheKey, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上返回一个ImageRequest类型，来看其请求成功的响应：即把获得的图片存储到缓存中；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onGetImageSuccess</span><span class="params">(String cacheKey, Bitmap response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把获取到的图片存储到缓存中</span></span><br><span class="line">    mCache.putBitmap(cacheKey, response);</span><br><span class="line">    <span class="comment">// 可以看到如果是多个相同请求在等待，则可以同时进行更新处理</span></span><br><span class="line">    BatchedImageRequest request = mInFlightRequests.remove(cacheKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Update the response bitmap.</span></span><br><span class="line">        request.mResponseBitmap = response;</span><br><span class="line">        <span class="comment">// Send the batched response</span></span><br><span class="line">        batchResponse(cacheKey, request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后NetWork执行的结果会封装成NetWorkResponse，通过ResponseDelivery进行转发，这个类最后会调用Request中deliverResponse方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(Bitmap response)</span> </span>&#123;</span><br><span class="line">    mListener.onResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个Listener就是最初定义的ImageListener:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ImageListener <span class="title">getImageListener</span><span class="params">(<span class="keyword">final</span> ImageView view,</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> defaultImageResId, <span class="keyword">final</span> <span class="keyword">int</span> errorImageResId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImageListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (errorImageResId != <span class="number">0</span>) &#123;</span><br><span class="line">                view.setImageResource(errorImageResId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(ImageContainer response, <span class="keyword">boolean</span> isImmediate)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (response.getBitmap() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                view.setImageBitmap(response.getBitmap());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (defaultImageResId != <span class="number">0</span>) &#123;</span><br><span class="line">                view.setImageResource(defaultImageResId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里最终给View空间设置了图片，以上就是Volley实现图片加载的流程。</p>

      
    </div>
    
  </div>
  
    


    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2016/05/16/Fragment源码解析/">
                    Fragment源码解析
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2016/05/15/Picasso源码解析/">
                    Picasso源码解析
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、Volley框架图"><span class="toc-number">1.</span> <span class="toc-text">一、Volley框架图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、Volley系统流程设计图"><span class="toc-number">2.</span> <span class="toc-text">二、Volley系统流程设计图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、概念小结"><span class="toc-number">3.</span> <span class="toc-text">三、概念小结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、源码分析："><span class="toc-number">4.</span> <span class="toc-text">四、源码分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#（一）RequestQueue的使用："><span class="toc-number">4.1.</span> <span class="toc-text">（一）RequestQueue的使用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-、HurlStack"><span class="toc-number">4.2.</span> <span class="toc-text">1) 、HurlStack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-、-Network"><span class="toc-number">4.2.1.</span> <span class="toc-text">2)、 Network</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-、-RequestQueue"><span class="toc-number">4.2.2.</span> <span class="toc-text">3)、 RequestQueue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#（二）从start方法看起："><span class="toc-number">4.3.</span> <span class="toc-text">（二）从start方法看起：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、RequestQueue-start"><span class="toc-number">4.3.1.</span> <span class="toc-text">1、RequestQueue.start():</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、RequestQueue-add"><span class="toc-number">4.3.2.</span> <span class="toc-text">2、RequestQueue.add()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-：mCurrentRequests"><span class="toc-number">4.3.3.</span> <span class="toc-text">1)：mCurrentRequests</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-、Request-setRequestQueue"><span class="toc-number">4.3.4.</span> <span class="toc-text">2)、Request.setRequestQueue()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-、request-shouldCache"><span class="toc-number">4.3.5.</span> <span class="toc-text">3)、request.shouldCache()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-、mWaitingRequests"><span class="toc-number">4.3.6.</span> <span class="toc-text">4)、mWaitingRequests</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、CacheDispatcher："><span class="toc-number">5.</span> <span class="toc-text">五、CacheDispatcher：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#（一）成员变量"><span class="toc-number">5.1.</span> <span class="toc-text">（一）成员变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-成员变量"><span class="toc-number">5.1.1.</span> <span class="toc-text">(1). 成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-处理流程图"><span class="toc-number">5.1.2.</span> <span class="toc-text">(2). 处理流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-源码："><span class="toc-number">5.1.3.</span> <span class="toc-text">(3)源码：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、构造函数："><span class="toc-number">5.1.3.1.</span> <span class="toc-text">1、构造函数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、看起执行逻辑："><span class="toc-number">5.1.3.2.</span> <span class="toc-text">2、看起执行逻辑：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、NetworkDispatcher"><span class="toc-number">6.</span> <span class="toc-text">六、NetworkDispatcher</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-成员变量-1"><span class="toc-number">6.1.</span> <span class="toc-text">(1). 成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-处理流程图-1"><span class="toc-number">6.2.</span> <span class="toc-text">(2). 处理流程图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-构造函数"><span class="toc-number">6.3.</span> <span class="toc-text">(3).构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-其run-函数："><span class="toc-number">6.4.</span> <span class="toc-text">(4).其run()函数：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、Network"><span class="toc-number">7.</span> <span class="toc-text">七、Network</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#八、HttpClientStack、HurlStack"><span class="toc-number">8.</span> <span class="toc-text">八、HttpClientStack、HurlStack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、先看两者的父类HttpStack"><span class="toc-number">8.1.</span> <span class="toc-text">1、先看两者的父类HttpStack:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、HttpClientStack-使用HttpClient来实现"><span class="toc-number">8.2.</span> <span class="toc-text">2、HttpClientStack(使用HttpClient来实现)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1）：createHttpRequest函数："><span class="toc-number">8.2.1.</span> <span class="toc-text">1）：createHttpRequest函数：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、HurlStack-由HttpURLConnection来实现"><span class="toc-number">8.3.</span> <span class="toc-text">3、HurlStack(由HttpURLConnection来实现)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1）：UrlRewriter"><span class="toc-number">8.3.1.</span> <span class="toc-text">1）：UrlRewriter</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#九、NetworkResponse"><span class="toc-number">9.</span> <span class="toc-text">九、NetworkResponse</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1）成员变量"><span class="toc-number">9.1.</span> <span class="toc-text">1）成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2）其主体只为几个构造函数："><span class="toc-number">9.2.</span> <span class="toc-text">2）其主体只为几个构造函数：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#十、Volley图片加载的实现"><span class="toc-number">10.</span> <span class="toc-text">十、Volley图片加载的实现</span></a></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }

    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })

    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>





    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"Volley源码解析　| Liuyunyicai　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2016/05/16/Fragment源码解析/" title="上一篇: Fragment源码解析">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2016/05/15/Picasso源码解析/" title="下一篇: Picasso源码解析">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/05/16/Fragment源码解析/">Fragment源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/16/Volley源码解析/">Volley源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/15/Picasso源码解析/">Picasso源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/12/设计模式汇总--结构型模型/">设计模式汇总--结构型模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/10/View机制深入学习（五） 事件处理机制一/">View机制深入学习（五） 事件处理机制一</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/06/Retrofit源码解析/">Retrofit源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/06/ArrayMapy、SparseArray源码学习/">ArrayMapy、SparseArray源码学习</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016 流云易采
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8">
  
  <title>设计模式汇总--结构型模式 | Liuyunyicai</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="总体来说设计模式分为三大类：创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。其实还有两类：并发型模式和线程池模式。前面已经介">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式汇总--结构型模式">
<meta property="og:url" content="http://liuyunyicai.github.io/2016/05/12/设计模式汇总--结构型模型/index.html">
<meta property="og:site_name" content="Liuyunyicai">
<meta property="og:description" content="总体来说设计模式分为三大类：创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。其实还有两类：并发型模式和线程池模式。前面已经介">
<meta property="og:image" content="http://img.blog.csdn.net/20160525163616480">
<meta property="og:image" content="http://img.blog.csdn.net/20160525163628959">
<meta property="og:image" content="http://img.blog.csdn.net/20160525163645319">
<meta property="og:image" content="http://img.blog.csdn.net/20160525163654647">
<meta property="og:image" content="http://img.blog.csdn.net/20160525163712195">
<meta property="og:image" content="http://img.blog.csdn.net/20160525162105489">
<meta property="og:image" content="http://img.blog.csdn.net/20160525163305682">
<meta property="og:image" content="http://img.blog.csdn.net/20160525162407804">
<meta property="og:image" content="http://img.blog.csdn.net/20160525162506414">
<meta property="og:image" content="http://img.blog.csdn.net/20160525162606697">
<meta property="og:image" content="http://img.blog.csdn.net/20160525162731976">
<meta property="og:image" content="http://img.blog.csdn.net/20160525162828758">
<meta property="og:updated_time" content="2016-05-25T09:02:17.699Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式汇总--结构型模式">
<meta name="twitter:description" content="总体来说设计模式分为三大类：创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。其实还有两类：并发型模式和线程池模式。前面已经介">
<meta name="twitter:image" content="http://img.blog.csdn.net/20160525163616480">
  
    <link rel="alternative" href="/atom.xml" title="Liuyunyicai" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
      <link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet">
  
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/clipboard.js/1.5.9/clipboard.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
          fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
          scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.0.9/scrollreveal.min.js"
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/liuyunyicai.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">流云易采</a></h1>
        </hgroup>

        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">文章列表</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/979724798@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" target="_blank" href="http://blog.csdn.net/woliuyunyicai" title="CSDN"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">Android,Java</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">流云易采</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/liuyunyicai.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">流云易采</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">文章列表</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/979724798@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" target="_blank" href="http://blog.csdn.net/woliuyunyicai" title="CSDN"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-设计模式汇总--结构型模型" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/12/设计模式汇总--结构型模型/" class="article-date">
      <time datetime="2016-05-12T02:14:15.022Z" itemprop="datePublished">2016-05-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      设计模式汇总--结构型模式
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>总体来说设计模式分为三大类：<br><strong>创建型模式</strong>，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br><strong>结构型模式</strong>，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br><strong>行为型模式</strong>，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。<br>其实还有两类：并发型模式和线程池模式。<br>前面已经介绍了<a href="http://blog.csdn.net/woliuyunyicai/article/details/51287132" target="_blank" rel="external">《设计模式汇总：创建型模式》</a>，下面来看结构型模型：</p>
<h1 id="一、适配器模式"><a href="#一、适配器模式" class="headerlink" title="一、适配器模式"></a>一、适配器模式</h1><p>适配器模式在Android中比较常见，在ListView中无时无刻不在使用；<br>适配器的思想是将一个类的接口转换成客户希望的另外一个接口。其主要涉及三个角色：<br>模式所涉及的角色有：<br><strong>目标(Target)角色：</strong>这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。<br><strong>源(Adapee)角色：</strong>现在需要适配的接口。<br><strong>适配器(Adaper)角色：</strong>适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。<br>把Adaptee设想成使用ListView时想要加载的数据如ArrayList；<br>目标角色Target即是ListView源码中会用到的BaseAdapter这些;<br>而开发时继承BaseAdater自定义的Adapter即为Adapter角色；</p>
<p>实现适配器的方法有两种，可以分别通过继承和组合来实现适配器效果：<br>一种是类适配器模式；一种是对象适配器模式；</p>
<h2 id="1）类适配器模式"><a href="#1）类适配器模式" class="headerlink" title="1）类适配器模式"></a>1）类适配器模式</h2><p><img src="http://img.blog.csdn.net/20160525163616480" alt="这里写图片描述"><br><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reqeust</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">specReqeust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adaptee specReqeust"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为Adaptee适配成Target接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reqeust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        specReqeust();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Target target = <span class="keyword">new</span> Adapter();</span><br><span class="line">        target.reqeust();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Target不为接口时，Java不支持多继承，可以采用组合的形式来实现：</p>
<h2 id="2）对象适配器模式"><a href="#2）对象适配器模式" class="headerlink" title="2）对象适配器模式"></a>2）对象适配器模式</h2><p><img src="http://img.blog.csdn.net/20160525163628959" alt="这里写图片描述"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">reqeust</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">specReqeust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adaptee specReqeust"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为Adaptee适配成Target接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reqeust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.specReqeust();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将Adaptee适配成Target来使用</span></span><br><span class="line">        Target target = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee());</span><br><span class="line">        target.reqeust();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3）适配器模式的优点-："><a href="#3）适配器模式的优点-：" class="headerlink" title="3）适配器模式的优点 ："></a>3）适配器模式的优点 ：</h2><p><strong>1）更好的复用性</strong><br>系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。<br><strong>2）更好的扩展性</strong><br>在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。</p>
<p><strong>适配器模式的缺点 ：</strong><br>　　过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</p>
<h1 id="二、装饰者模式"><a href="#二、装饰者模式" class="headerlink" title="二、装饰者模式"></a>二、装饰者模式</h1><p>Java中InputStream，FilterInputStream，DataInputStream这些就是典型的装饰者模式。<br><img src="http://img.blog.csdn.net/20160525163645319" alt="这里写图片描述"><br><strong>Decorator模式（别名Wrapper）</strong>：动态将职责附加到对象上，若要扩展功能，装饰者提供了比继承更具弹性的代替方案。<br>意图：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。<br><img src="http://img.blog.csdn.net/20160525163654647" alt="这里写图片描述"><br><strong>适用性</strong>：<br>以下情况使用Decorator模式<br>1）需要扩展一个类的功能，或给一个类添加附加职责。<br>2）需要动态的给一个对象添加功能，这些功能可以再动态的撤销。<br>3）需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。<br>4）当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。 比如如下情况所提供的灵活性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = null;</span><br><span class="line">new BufferedInputStream(new DataInputStream(in));</span><br><span class="line">new DataInputStream(new BufferedInputStream(in));</span><br></pre></td></tr></table></figure>
<p>明显采用继承是比较难以实现的；</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">abstract class Compontent &#123;</span><br><span class="line">    abstract void operation1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConcreteCompontent extends Compontent&#123;</span><br><span class="line">    @Override</span><br><span class="line">    void operation1() &#123;</span><br><span class="line">        System.out.print(&quot;ConcreteCompontent operation1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Decorator extends Compontent &#123;</span><br><span class="line">    Compontent compontent;</span><br><span class="line"></span><br><span class="line">    public Decorator(Compontent compontent) &#123;</span><br><span class="line">        this.compontent = compontent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void operation1() &#123;</span><br><span class="line">        compontent.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConcreteDecorator1 extends Decorator &#123;</span><br><span class="line">    int addedField; // 动态添加的变量</span><br><span class="line"></span><br><span class="line">    public ConcreteDecorator1(Compontent compontent) &#123;</span><br><span class="line">        super(compontent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void operation1() &#123;</span><br><span class="line">        System.out.println(&quot;do other sth&quot;);</span><br><span class="line">        super.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConcreteDecorator2 extends Decorator &#123;</span><br><span class="line"></span><br><span class="line">    public ConcreteDecorator2(Compontent compontent) &#123;</span><br><span class="line">        super(compontent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 动态添加的操作</span><br><span class="line">    void operation2() &#123;</span><br><span class="line">        System.out.print(&quot;ConcreteCompontent operation2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client &#123;</span><br><span class="line">    public void dosth() &#123;</span><br><span class="line">        Compontent co = new ConcreteCompontent();</span><br><span class="line">        Compontent compontent0 = new ConcreteDecorator2(co);</span><br><span class="line">        Compontent compontent1 = new ConcreteDecorator1(new ConcreteDecorator2(co));</span><br><span class="line">        Compontent compontent2 = new ConcreteDecorator2(new ConcreteDecorator1(co));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装饰者模式的优缺点："><a href="#装饰者模式的优缺点：" class="headerlink" title="装饰者模式的优缺点："></a>装饰者模式的优缺点：</h2><h3 id="1）优点："><a href="#1）优点：" class="headerlink" title="1）优点："></a>1）优点：</h3><ol>
<li>通过组合而非继承的方式，实现了动态扩展对象的功能的能力。</li>
<li>有效避免了使用继承的方式扩展对象功能而带来的灵活性差，子类无限制扩张的问题。</li>
<li>充分利用了继承和组合的长处和短处，在灵活性和扩展性之间找到完美的平衡点。</li>
<li>装饰者和被装饰者之间虽然都是同一类型，但是它们彼此是完全独立并可以各自独立任意改变的。</li>
<li>遵守大部分GRASP原则和常用设计原则，高内聚、低偶合。</li>
<li>Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。</li>
<li>通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合<h3 id="2）缺点："><a href="#2）缺点：" class="headerlink" title="2）缺点："></a>2）缺点：</h3></li>
<li>装饰链不能过长，否则会影响效率。</li>
<li>因为所有对象都是Component,所以如果Component内部结构发生改变，则不可避免地影响所有子类(装饰者和被装饰者)，也就是说，通过继承建立的关系总是脆弱地，如果基类改变，势必影响对象的内部，而通过组合(Decoator HAS A Component)建立的关系只会影响被装饰对象的外部特征。</li>
<li>只在必要的时候使用装饰者模式，否则会提高程序的复杂性，增加系统维护难度。</li>
<li>这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。</li>
<li>装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</li>
<li>装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。</li>
</ol>
<p><strong>修饰者模式至少有两个关键利益及两个责任(liability)：</strong><br><strong>1）比静态继承更有弹性：</strong>修饰者模式提供一个较静态（多重）继承更有弹性的方式附加责任到对象上。使用修饰者责任可以在执行期简单的附加或取消，相对的继承需要为每一个新的附加责任建立一个新的类（如BorderedScrollableTextView、BorderedTextView等），如此会造成使用许多类及增加系统复杂度。更进一步；为特定的Component类提供不同的修饰者类让你比较及混合责任。<br>避免在层级架构中增加外貌装载(feature-laden《译注：在类中存有许多有关显示外貌的Component或属性等》)类：修饰者提供一个你要才有(pay-as-you-go)的方式附加责任。相对的不去在一个复杂客制化类中提供一所有可预测外貌；而定义一个简单类并在一个修饰者类逐步增加功能，其结果是一个应用系统无须准备一些不会使用到的外貌。同时也容易从他们所扩充的对象类定义一个新的修饰者类；甚至不在预测内。扩充一个复杂类需要揭露与你要附加责任无关的部分。<br><strong>2）修饰者及其Component不是同一个：</strong>修饰者就像透明的围墙(transparent enclosure)，但从一个对象界定(identity)的观点；一个被修饰的对象与其本身并不需要去区分(identical)，因此当你使用修饰者无区依赖对象界定。<br>有许多小对象：使用修饰这设计时常常产生在一个系统中组合看起来很像的许多小对象的结果。这些对象的差一点只是互动(interconnect)的方式；而非他的类或者其内不变量的值。虽然只要你了解他们就可以方便客制系统；但是可能难以学习及除错。<br>接口一致(conformance)：修饰者对象的接口必须与其修饰的对象接口一致具体修饰指(ConcreteDecorator)类必须继承一个公用(common)类。<br><strong>3）忽略(omitting)抽象修饰者类：</strong>当你只是附加单一责任时无须定义一个抽象修饰者类，这种情形一般是当你使用现存的类层级架构而非构建一个新的，因此你可以将修饰者传递请求到Component的责任融合(merge)至具体修饰者。<br>保持轻量(lightweight)的Component类：要确保接口一致，Component及修饰者必须自一个公用Component类继承，保持这个公用Component类轻量是很重要的，即必须专注于定义一个接口而非储存数据。数据责任的定义必须延缓至子类，否则太复杂的Component类会在数量上使用太过于重(heavyweight)。在Component类中放置太多的功能同时会增加其子类为许多没有必要的外表付出代价的可能性。<br><strong>4）改变对象的外表(skin)或其内部(guts)：</strong>我们可以想象修饰者就像对象的可以改变行为外表，另一种替代方式是改变其内部，策略模式(Strategy)就是改变其内部的作法。当Component类在本质上(intrinsically)太重(heavyweight)时策略模式是一个比较适当的选择，因为以修饰者模式实现成本太高。在策略模式中组件传递(forward)他的部分行为给另外的策略对象，策略模式让我们以替代的策略对象改变或扩充组件的功能。<br><strong>动态和静态的问题：</strong><br>所谓动态是说可以在系统运行时(RunTime)动态给对象增加其它职责而不需要修改代码或重新编译；<br>所谓静态是说必须通过调整代码(DesignTime)才能给对象增加职责,而且系统还需要重新编译；<br>从具体技术层面来说，对象的组合和继承正好对应于前面的动态和静态，因为通过对象组合建立的交互关系不是在代码中(DesignTime)固定死的，而是在运行时(RunTime)动态组合的；而通过继承建立的关系是僵硬的难以改变的，因为它是在代码中(DesignTime)固定死了的，根本不存在运行时(RunTime)改变的可能。换个角度说：我们应该多使用对象组合来保持系统的运行时扩展性，尽量少使继承，因为继承让程序变得僵硬，优先使用对象组合，而非类继承。</p>
<h1 id="三、代理模式"><a href="#三、代理模式" class="headerlink" title="三、代理模式"></a>三、代理模式</h1><p>代理模式就是给一个对象提供一个代理，并由代理对象控制对原对象的引用。<br>在代理模式中，proxy代理主要是起到一个中介的作用，它连接客户端和目标对象。<br>在Android的Binder机制中，代理模式起到很重要的作用。<br><img src="http://img.blog.csdn.net/20160525163712195" alt="这里写图片描述"></p>
<p><strong>代理模式适用于：</strong><br>在某些情况下，我们不希望或是不能直接访问对象 A，而是通过访问一个中介对象 B，由 B 去访问 A 达成目的，这种方式我们就称为代理。<br>这里对象 A 所属类我们称为委托类，也称为被代理类，对象 B 所属类称为代理类。<br><strong>代理优点有：</strong><br>1）隐藏委托类的实现<br>2）解耦，不改变委托类代码情况下做一些额外处理，比如添加初始判断及其他公共操作<br><strong>代理模式中有三类角色：</strong><br><strong>抽象主题角色（Object）：</strong>声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。<br><strong>具体主题角色（RealObject)：</strong>也称为委托角色或者被代理角色。定义了代理对象所代表的目标对象。<br><strong>代理主题角色（Proxy)：</strong>也叫代理类。代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。</p>
<p>Java中根据程序运行前代理类是否已经存在，可以将代理分为静态代理和动态代理。 </p>
<h2 id="1）静态代理："><a href="#1）静态代理：" class="headerlink" title="1）静态代理："></a>1）静态代理：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">interface IObject &#123;</span><br><span class="line">    void operation1();</span><br><span class="line">    void operation2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RealObject implements IObject&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operation1() &#123;</span><br><span class="line">        System.out.print(&quot;RealObject operation1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operation2() &#123;</span><br><span class="line">        System.out.print(&quot;RealObject operation2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Proxy implements IObject &#123;</span><br><span class="line">    private RealObject real;</span><br><span class="line"></span><br><span class="line">    public Proxy() &#123;</span><br><span class="line">        real = new RealObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operation1() &#123;</span><br><span class="line">        real.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operation2() &#123;</span><br><span class="line">        real.operation2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client &#123;</span><br><span class="line">    void doSth() &#123;</span><br><span class="line">        Proxy proxy = new Proxy();</span><br><span class="line">        proxy.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上可见，Proxy就相当于生活中的代理，比如买东西的时候，没必要去生产商品的厂家去购买，直接去代理地点也即是超市购买即可；代理通过调用委托类来未用户提供同样的服务，而又避免了用户去直接调用委托类。</p>
<h2 id="2）动态代理："><a href="#2）动态代理：" class="headerlink" title="2）动态代理："></a>2）动态代理：</h2><p>由前所见，每一个委托类需要对应一个代理类，这样在大型项目中将会出现众多的代理类，而这些代理类只是一个中介而已，为了优化代码结果，Java提供了动态代理的方式，使用反射来动态生成相应的代理类来为用户提供服务。</p>
<h3 id="2-1）创建动态代理的流程："><a href="#2-1）创建动态代理的流程：" class="headerlink" title="2.1）创建动态代理的流程："></a>2.1）创建动态代理的流程：</h3><p>1、定义一个代理类和委托类共同使用的接口Operate<br>2、实现一个委托类继承Interface，它是真正实现操作逻辑的类记为Real<br>3、继承一个InvocationHandler，传入委托类实例；重写invoke函数<br>4、使用Proxy.newProxyInstance来动态创建一个代理类，今后的所有操作都通过这个实例proxy来操作；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 创建委托类和代理类统一的接口</span><br><span class="line">interface Operate &#123;</span><br><span class="line">    void do1();</span><br><span class="line">    void do2();</span><br><span class="line">    void do3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体的委托类</span><br><span class="line">class RealImpl implements Operate &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void do1() &#123;</span><br><span class="line">        System. out.println(&quot;Real do1&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void do2() &#123;</span><br><span class="line">        System. out.println(&quot;Real do2&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void do3() &#123;</span><br><span class="line">        System. out.println(&quot;Real do3&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 自定义InvocationHandler</span><br><span class="line">class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">    private Object target ;</span><br><span class="line"></span><br><span class="line">    public MyInvocationHandler(Object target ) &#123;</span><br><span class="line">        this.target = target ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy , Method method, Object[] args)</span><br><span class="line">            throws Throwable &#123;</span><br><span class="line">        // 执行 method之前的一些操作</span><br><span class="line">        Object result = method.invoke( target, args);</span><br><span class="line">        // 执行 method之后的一些自处理操作</span><br><span class="line">        return result ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class ProxyDynamic &#123;</span><br><span class="line">        // 具体的使用</span><br><span class="line">        public void a() &#123;</span><br><span class="line">              Operate proxy = (Operate) Proxy.newProxyInstance(Operate.class.getClassLoader(), new Class&lt;?&gt;[] &#123;Operate.class&#125;,</span><br><span class="line">                            new MyInvocationHandler(new RealImpl()));</span><br><span class="line">               proxy.do1();</span><br><span class="line">               proxy.do2();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2）原理："><a href="#2-2）原理：" class="headerlink" title="2.2）原理："></a>2.2）原理：</h3><p>Proxy这个类根据ClassLoader以及interfaces这个数组，获得一个相应的代理类的名称，一般的格式是packagename+$Proxy+num，然后通过<br> ProxyGenerator.generateProxyClass(proxyName, interfaces , accessFlags );<br>来创建对应的类；最后通过反射调用该类的构造器创建一个具体实例；这个类是继承Proxy的，Proxy持有InvocationHandler的实例h；<br>代理类的所有操作都是通过将Method传递到h的invoke函数，通过invoke函数进行最终的处理；<br>因此InvocationHandler是代理类和委托类之间的中介；</p>
<h4 id="1、来看具体的动态生成的类-Proxy0"><a href="#1、来看具体的动态生成的类-Proxy0" class="headerlink" title="1、来看具体的动态生成的类$Proxy0:"></a>1、来看具体的动态生成的类$Proxy0:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">import com.hust.liuyun.Operate;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line">public final class $Proxy0 extends Proxy</span><br><span class="line">  implements Operate</span><br><span class="line">&#123;</span><br><span class="line">  private static Method m4 ;</span><br><span class="line">  private static Method m1 ;</span><br><span class="line">  private static Method m5 ;</span><br><span class="line">  private static Method m0 ;</span><br><span class="line">  private static Method m3 ;</span><br><span class="line">  private static Method m2 ;</span><br><span class="line"></span><br><span class="line">  public $Proxy0(InvocationHandler paramInvocationHandler)</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    super(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final void operateMethod1()</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      h.invoke( this, m4, null );</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final boolean equals(Object paramObject)</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return ((Boolean)h.invoke( this, m1, new Object[] &#123; paramObject &#125;)).booleanValue();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final void operateMethod2()</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      h.invoke( this, m5, null );</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final int hashCode()</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return ((Integer)h.invoke( this, m0, null )).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final void operateMethod3()</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      h.invoke( this, m3, null );</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final String toString()</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return (String)h.invoke( this, m2, null );</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      m4 = Class.forName(&quot;com.hust.liuyun.Operate&quot;).getMethod( &quot;do1&quot;, new Class[0]);</span><br><span class="line">      m1 = Class.forName(&quot;java.lang.Object&quot; ).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);</span><br><span class="line">      m5 = Class.forName(&quot;com.hust.liuyun.Operate&quot;).getMethod( &quot;do2&quot;, new Class[0]);</span><br><span class="line">      m0 = Class.forName(&quot;java.lang.Object&quot; ).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">      m3 = Class.forName(&quot;com.hust.liuyun.Operate&quot;).getMethod( &quot;do3&quot;, new Class[0]);</span><br><span class="line">      m2 = Class.forName(&quot;java.lang.Object&quot; ).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoSuchMethodError(localNoSuchMethodException .getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoClassDefFoundError(localClassNotFoundException .getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到该生成类是继承Proxy的，在构造函数中将InvocationHandler的实例传递进来；然后通过反射获取到该类中所有相关的Method的实例。<br>相关的所有操作都是通过h.invoke来实现的。</p>
<h4 id="2、Proxy-newProxyInstance："><a href="#2、Proxy-newProxyInstance：" class="headerlink" title="2、Proxy#newProxyInstance："></a>2、Proxy#newProxyInstance：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                 Class&lt;?&gt;[] interfaces, InvocationHandler h )</span><br><span class="line">                  throws IllegalArgumentException &#123;</span><br><span class="line">          Objects. requireNonNull(h);</span><br><span class="line"></span><br><span class="line">           final Class&lt;?&gt;[] intfs = interfaces .clone();</span><br><span class="line">           final SecurityManager sm = System.getSecurityManager ();</span><br><span class="line">           if (sm != null) &#123;</span><br><span class="line">                  checkProxyAccess(Reflection. getCallerClass(), loader, intfs);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">           * Look up or generate the designated proxy class.</span><br><span class="line">           */</span><br><span class="line">           // 通过这个重要类，来生成一个动态代理类</span><br><span class="line">          Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">           * Invoke its constructor with the designated invocation handler.</span><br><span class="line">           */</span><br><span class="line">           try &#123;</span><br><span class="line">                  if (sm != null) &#123;</span><br><span class="line">                        checkNewProxyPermission(Reflection.getCallerClass() , cl);</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                  // 调用动态代理类的构造器来创建一个具体实例</span><br><span class="line">                  final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">                  final InvocationHandler ih = h ;</span><br><span class="line">                  if (!Modifier.isPublic( cl.getModifiers())) &#123;</span><br><span class="line">                       AccessController. doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                               public Void run() &#123;</span><br><span class="line">                                      cons.setAccessible( true);</span><br><span class="line">                                      return null ;</span><br><span class="line">                              &#125;</span><br><span class="line">                       &#125;);</span><br><span class="line">                 &#125;</span><br><span class="line">                  // 可以看到这里将InvocationHandler这个中介以参数形式加入进来</span><br><span class="line">                  return cons .newInstance(new Object[] &#123; h &#125;);</span><br><span class="line">          &#125; catch (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">                  throw new InternalError(e.toString(), e);</span><br><span class="line">          &#125; catch (InvocationTargetException e ) &#123;</span><br><span class="line">                 Throwable t = e.getCause();</span><br><span class="line">                  if (t instanceof RuntimeException) &#123;</span><br><span class="line">                        throw (RuntimeException) t ;</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                        throw new InternalError(t.toString(), t);</span><br><span class="line">                 &#125;</span><br><span class="line">          &#125; catch (NoSuchMethodException e ) &#123;</span><br><span class="line">                  throw new InternalError(e.toString(), e);</span><br><span class="line">          &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>流程：<br>1）进行一些权限检查之类<br>2）通过getProxyClass0来获得对应的动态代理类（可能是新创建，也可能是从Cache中取出）<br>3）调用代理类的构造器来创建一个具体的代理类；</p>
<h4 id="3、getProxyClass0"><a href="#3、getProxyClass0" class="headerlink" title="3、getProxyClass0"></a>3、getProxyClass0</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static final WeakCache &lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">proxyClassCache = new WeakCache &lt;&gt;(new KeyFactory(), new ProxyClassFactory());</span><br><span class="line">/**</span><br><span class="line"> * Generate a proxy class.  Must call the checkProxyAccess method</span><br><span class="line"> * to perform permission checks before calling this.</span><br><span class="line"> */</span><br><span class="line">private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    if (interfaces.length &gt; 65535) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If the proxy class defined by the given loader implementing</span><br><span class="line">    // the given interfaces exists, this will simply return the cached copy;</span><br><span class="line">    // otherwise, it will create the proxy class via the ProxyClassFactory</span><br><span class="line">    return proxyClassCache.get(loader , interfaces );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个WeakCache来存储相关的代理类信息，通过代理类来获取；</p>
<h4 id="4、WeakCache-get"><a href="#4、WeakCache-get" class="headerlink" title="4、WeakCache#get:"></a>4、WeakCache#get:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public V get(K key , P parameter) &#123;</span><br><span class="line">    Objects.requireNonNull(parameter );</span><br><span class="line"></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    // 根据ClassLoader获取相应的key值</span><br><span class="line">    Object cacheKey = CacheKey.valueOf(key , refQueue);</span><br><span class="line"></span><br><span class="line">    // 根据ClassLoader获得其中的ConcurrentMap</span><br><span class="line">    // lazily install the 2nd level valuesMap for the particular cacheKey</span><br><span class="line">    ConcurrentMap&lt;Object, Supplier&lt; V&gt;&gt; valuesMap = map.get(cacheKey );</span><br><span class="line">    if (valuesMap == null) &#123;</span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt; V&gt;&gt; oldValuesMap</span><br><span class="line">            = map.putIfAbsent(cacheKey,</span><br><span class="line">                              valuesMap = new ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        if (oldValuesMap != null) &#123;</span><br><span class="line">            valuesMap = oldValuesMap ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span><br><span class="line">    // subKey from valuesMap</span><br><span class="line">    // 在ConcurrentMap中，key对应的interfaces，Value则对应着具体的类Class信息&lt;?&gt;</span><br><span class="line">    // 代理类的具体创建逻辑是通过subKeyFactory.apply来实现的</span><br><span class="line">    Object subKey = Objects.requireNonNull(subKeyFactory.apply( key, parameter));</span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap .get(subKey );</span><br><span class="line">    Factory factory = null;</span><br><span class="line"></span><br><span class="line">    while ( true) &#123;</span><br><span class="line">       // 如果已经存在，则直接返回</span><br><span class="line">        if (supplier != null) &#123;</span><br><span class="line">            // supplier might be a Factory or a CacheValue&lt;V&gt; instance</span><br><span class="line">            V value = supplier.get();</span><br><span class="line">            if (value != null) &#123;</span><br><span class="line">                return value ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // else no supplier in cache</span><br><span class="line">        // or a supplier that returned null (could be a cleared CacheValue</span><br><span class="line">        // or a Factory that wasn&apos;t successful in installing the CacheValue)</span><br><span class="line"></span><br><span class="line">        // lazily construct a Factory</span><br><span class="line">        if (factory == null) &#123;</span><br><span class="line">            factory = new Factory( key, parameter, subKey , valuesMap );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (supplier == null) &#123;</span><br><span class="line">            supplier = valuesMap.putIfAbsent(subKey , factory );</span><br><span class="line">            if (supplier == null) &#123;</span><br><span class="line">                // successfully installed Factory</span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125;</span><br><span class="line">            // else retry with winning supplier</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (valuesMap .replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                // successfully replaced</span><br><span class="line">                // cleared CacheEntry / unsuccessful Factory</span><br><span class="line">                // with our Factory</span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // retry with current supplier</span><br><span class="line">                supplier = valuesMap.get(subKey );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的Cache是个两级缓存，通过ClassLoader为key来缓存一个ConcurrentMap；该ConcurrentMap的key对应着传入进来的interface参数；</p>
<p>由前面知道subKeyFactory对应的具体类为：ProxyClassFactory，具体来看其apply函数；</p>
<h4 id="5、ProxyClassFactory-apply"><a href="#5、ProxyClassFactory-apply" class="headerlink" title="5、ProxyClassFactory#apply:"></a>5、ProxyClassFactory#apply:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">private static final class ProxyClassFactory</span><br><span class="line">    implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    // prefix for all proxy class names</span><br><span class="line">    private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;</span><br><span class="line"></span><br><span class="line">    // next number to use for generation of unique proxy class names</span><br><span class="line">    private static final AtomicLong nextUniqueNumber = new AtomicLong();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces .length );</span><br><span class="line">       </span><br><span class="line">        /** 对传递进来的interface进行判断</span><br><span class="line">         * 1、先判断该interface是否是通过传递进来的ClassLoader来加载的</span><br><span class="line">         * 2、判断该interface是否为接口</span><br><span class="line">         * 3、判断该接口数组中是否有重复的类  **/</span><br><span class="line">        for (Class&lt;?&gt; intf : interfaces ) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Verify that the class loader resolves the name of this</span><br><span class="line">             * interface to the same Class object.</span><br><span class="line">             */</span><br><span class="line">            Class&lt;?&gt; interfaceClass = null ;</span><br><span class="line">            try &#123;</span><br><span class="line">                interfaceClass = Class.forName( intf.getName(), false, loader );</span><br><span class="line">            &#125; catch (ClassNotFoundException e ) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            if (interfaceClass != intf ) &#123;</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    intf + &quot; is not visible from class loader&quot; );</span><br><span class="line">            &#125;</span><br><span class="line">            /*</span><br><span class="line">             * Verify that the Class object actually represents an</span><br><span class="line">             * interface.</span><br><span class="line">             */</span><br><span class="line">            if (!interfaceClass .isInterface()) &#123;</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    interfaceClass.getName() + &quot; is not an interface&quot; );</span><br><span class="line">            &#125;</span><br><span class="line">            /*</span><br><span class="line">             * Verify that this interface is not a duplicate.</span><br><span class="line">             */</span><br><span class="line">            if (interfaceSet .put(interfaceClass , Boolean.TRUE) != null) &#123;</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    &quot;repeated interface: &quot; + interfaceClass .getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String proxyPkg = null;     // package to define proxy class in</span><br><span class="line">        int accessFlags = Modifier.PUBLIC | Modifier. FINAL;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Record the package of a non-public proxy interface so that the</span><br><span class="line">         * proxy class will be defined in the same package.  Verify that</span><br><span class="line">         * all non-public proxy interfaces are in the same package.</span><br><span class="line">         */</span><br><span class="line">        /******** 获取该代理类的名称 ********/</span><br><span class="line">        for (Class&lt;?&gt; intf : interfaces ) &#123;</span><br><span class="line">            int flags = intf .getModifiers();</span><br><span class="line">            if (!Modifier.isPublic( flags)) &#123;</span><br><span class="line">                accessFlags = Modifier.FINAL;</span><br><span class="line">                String name = intf.getName();</span><br><span class="line">                int n = name .lastIndexOf(&apos;.&apos;);</span><br><span class="line">                String pkg = (( n == -1) ? &quot;&quot; : name .substring(0, n + 1));</span><br><span class="line">                if (proxyPkg == null) &#123;</span><br><span class="line">                    proxyPkg = pkg;</span><br><span class="line">                &#125; else if (!pkg .equals(proxyPkg )) &#123;</span><br><span class="line">                    throw new IllegalArgumentException(</span><br><span class="line">                        &quot;non-public interfaces from different packages&quot; );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (proxyPkg == null) &#123;</span><br><span class="line">            // if no non-public proxy interfaces, use com.sun.proxy package</span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Choose a name for the proxy class to generate.</span><br><span class="line">         */</span><br><span class="line">        long num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">        // 代理类的名称一般为包名+$ Proxy+num</span><br><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Generate the specified proxy class.</span><br><span class="line">         */</span><br><span class="line">        /** 通过ProxyGenerator.generateProxyClass来具体创建该代理类的二进制码 **/</span><br><span class="line">        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces , accessFlags) ;</span><br><span class="line">        try &#123;</span><br><span class="line">               // 这是一个native类，通过它来具体加载该代理类，返回响应的Class信息</span><br><span class="line">            return defineClass0( loader, proxyName,</span><br><span class="line">                                proxyClassFile, 0, proxyClassFile .length );</span><br><span class="line">        &#125; catch (ClassFormatError e ) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * A ClassFormatError here means that (barring bugs in the</span><br><span class="line">             * proxy class generation code) there was some other</span><br><span class="line">             * invalid aspect of the arguments supplied to the proxy</span><br><span class="line">             * class creation (such as virtual machine limitations</span><br><span class="line">             * exceeded).</span><br><span class="line">             */</span><br><span class="line">            throw new IllegalArgumentException(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）对传递进来的interface进行判断</p>
<ul>
<li>先判断该interface是否是通过传递进来的ClassLoader来加载的</li>
<li>判断该interface是否为接口</li>
<li>判断该接口数组中是否有重复的类<br>2）获取该代理类的名称;代理类的名称一般为包名+$ Proxy+num<br>3）通过ProxyGenerator.generateProxyClass来具体创建该代理类的二进制码<br>4）defineClass0,这是一个native类，通过它来具体加载该代理类，返回响应的Class信息</li>
</ul>
<p>参考博客：<a href="http://blog.csdn.net/u013256816/article/details/51009592" target="_blank" rel="external">http://blog.csdn.net/u013256816/article/details/51009592</a><br><strong>装饰模式和代理模式的区别 ：</strong><br>装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p>
<p><strong>外观模式和代理模式的区别 ：</strong><br>代理与外观的主要区别在于，代理对象代表一个单一对象而外观对象代表一个子系统，代理的客户对象无法直接访问对象，由代理提供单独的目标对象的访问，而通常外观对象提供对子系统各元件功能的简化的共同层次的调用接口。代理是一种原来对象的代表，其他需要与这个对象打交道的操作都是和这个代表交涉的。</p>
<p><strong>适配器模式和代理模式的区别 ：</strong><br>适配器模式改变所考虑的对象的接口，代理模式不能改变所代理对象的接口。</p>
<h1 id="四、外观模式（Fasade）"><a href="#四、外观模式（Fasade）" class="headerlink" title="四、外观模式（Fasade）"></a>四、外观模式（Fasade）</h1><p><strong>外观模式：</strong>为子系统中的一组接口提供一个一致的界面， Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>引入外观角色之后，用户只需要直接与外观角色交互，用户与子系统之间的复杂关系由外观角色来实现，从而降低了系统的耦合度。<br>即提供一个Facade类，来统一操作子系统；适用于子系统比较复杂的情况。</p>
<p><strong>主要解决问题：</strong>组件的客户和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。<br><strong>举个例子：</strong><br>比如，现在有一辆汽车，我们（客户程序）要启动它，那我们就要发动引擎（子系统1），使四个车轮（子系统2）转动。但是实际中我们并不需要用手推动车轮使其转动，我们踩下油门，此时汽车再根据一些其他的操作使车轮转动。油门就好比系统给我们留下的接口，不论汽车是以何种方式转动车轮，车轮变化成什么牌子的，我们要开走汽车所要做的还是踩下油门。<br><strong>使用外观模式之后的效果：</strong><br><img src="http://img.blog.csdn.net/20160525162105489" alt="这里写图片描述"><br><strong>类图：</strong><br><img src="http://img.blog.csdn.net/20160525163305682" alt="这里写图片描述"></p>
<p><strong>其中涉及到的角色有</strong>：<br><strong>外观角色（Facade）</strong>：是模式的核心，他被客户client角色调用，知道各个子系统的功能。同时根据客户角色已有的需求预订了几种功能组合。<br><strong>子系统角色（Subsystem classes）</strong>：实现子系统的功能，并处理由Facade对象指派的任务。对子系统而言，facade和client角色是未知的，没有Facade的任何相关信息；即没有指向Facade的实例。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子系统类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass1 operation1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass2 operation2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass3 operation3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外观类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    SubClass1 subClass1;</span><br><span class="line">    SubClass2 subClass2;</span><br><span class="line">    SubClass3 subClass3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Facade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subClass1 = <span class="keyword">new</span> SubClass1();</span><br><span class="line">        subClass2 = <span class="keyword">new</span> SubClass2();</span><br><span class="line">        subClass3 = <span class="keyword">new</span> SubClass3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subClass1.operation1();</span><br><span class="line">        subClass2.operation2();</span><br><span class="line">        subClass3.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">        facade.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>适用场合：</strong><br> 1）当需要为复杂子系统提供一个外部简单接口来供用户调用使用时，子系统往往会因为不断演化而变得越来越复杂；当一些用户不需要定制子系统时，facade可以为用户提供一个默认缺省的视图来供使用，当有其他需要定制的用户，可以越过facade进行自行定制；这样的模式在开源项目中比较常见，比如Retrofit这些。<br>2）为了避免客户程序和抽象类存在很大的依赖性，引入facade来使得子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。<br>3）减少子系统之间的耦合；当需要构建一个层次结构的子系统时，使用 facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，可以让子系统仅通过facade进行通讯，从而简化了它们之间的依赖关系。</p>
<p><strong>Facade模式的优缺点：</strong><br><strong>优点：</strong><br><strong>1）松散耦合：</strong>门面模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护<br><strong>简单易用：</strong>门面模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟踪多个子系统内部的模块进行交互，只需要跟门面类交互就可以了<br>更好的划分访问层次：通过合理的使用Facade，可以帮助我们更好的划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地掩藏了内部的细节。<br><strong>缺点：</strong><br>1） 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。<br>2） 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</p>
<p>参考博客：<a href="http://blog.csdn.net/u013256816/article/details/51009480" target="_blank" rel="external">http://blog.csdn.net/u013256816/article/details/51009480</a></p>
<h1 id="五、桥接模式（Bridge）"><a href="#五、桥接模式（Bridge）" class="headerlink" title="五、桥接模式（Bridge）"></a>五、桥接模式（Bridge）</h1><p><strong>意图：</strong>将抽象部分与实现部分分离，使它们都可以独立的变化。<br><strong>适用场景：</strong>将抽象与实现分离<br>    设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：<br>第一种设计方案是为每一种形状都提供一套各种颜色的版本。<br>第二种设计方案是根据实际需要对形状和颜色进行组合<br>    对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。<br><strong>类图：</strong><br><img src="http://img.blog.csdn.net/20160525162407804" alt="这里写图片描述"></p>
<p>实现上面的案例得：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Abstraction抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> IColor color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IShape</span><span class="params">(IColor color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementor实现类接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IColor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteImplementor具体实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorRed</span> <span class="keyword">extends</span> <span class="title">IColor</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Color is Red"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorBlue</span> <span class="keyword">extends</span> <span class="title">IColor</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Color is Blue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RefinedAbstraction扩充抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">IShape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(IColor color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"It is a rectangle"</span>);</span><br><span class="line">        color.operationImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Oval</span> <span class="keyword">extends</span> <span class="title">IShape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Oval</span><span class="params">(IColor color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"It is a Oval"</span>);</span><br><span class="line">        color.operationImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cient使用类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IShape shape1 = <span class="keyword">new</span> Rectangle(<span class="keyword">new</span> ColorRed());</span><br><span class="line">        IShape shape2 = <span class="keyword">new</span> Oval(<span class="keyword">new</span> ColorBlue());</span><br><span class="line">        shape1.operation();</span><br><span class="line">        shape2.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优缺点：</strong><br><strong>1）优点：</strong><br>分离抽象接口及其实现部分。<br>桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。<br>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。<br>实现细节对客户透明，可以对用户隐藏实现细节。<br><strong>2）缺点 ：</strong><br>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进 行设计与编程。<br>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</p>
<p><strong>适用环境：</strong><br>如果你不希望在抽象和实现部分采用固定的绑定关系，可以采用桥接模式，来把抽象和实现部分分开，然后在程序运行期间来动态的设置抽象部分需要用到的具体的实现，还可以动态切换具体的实现。<br>如果出现抽象部分和实现部分都应该可以扩展的情况，可以采用桥接模式，让抽象部分和实现部分可以独立的变化，从而可以灵活的进行单独扩展，而不是搅在一起，扩展一边会影响到另一边。<br>如果希望实现部分的修改，不会对客户产生影响，可以采用桥接模式，客户是面向抽象的接口在运行，实现部分的修改，可以独立于抽象部分，也就不会对客户产生影响了，也可以说对客户是透明的。<br>如果采用继承的实现方案，会导致产生很多子类，对于这种情况，可以考虑采用桥接模式，分析功能变化的原因，看看是否能分离成不同的纬度，然后通过桥接模式来分离它们，从而减少子类的数目。</p>
<h1 id="六、组合模式（Composite）"><a href="#六、组合模式（Composite）" class="headerlink" title="六、组合模式（Composite）"></a>六、组合模式（Composite）</h1><p><strong>概念：</strong>将对象组合成树形结构以表示“部分-整体”的层次结构。 组合模式使得用户对单个对象和组合对象的使用具有唯一性。<br><strong>应用：</strong>组合模式比较典型的应用就是<br>1）文件目录结构<br>2）Android中的ViewGroup和View<br><img src="http://img.blog.csdn.net/20160525162506414" alt="这里写图片描述"></p>
<p><strong>适用性：</strong>组合模式解耦了客户程序与复杂元素内部结构，从而使客户程序可以向处理简单元素一样来处理复杂元素。<br>如果你想要创建层次结构，并可以在其中以相同的方式对待所有元素，那么组合模式就是最理想的选择。<br>1）表示对象的部分-整体层次结构，如树形菜单、文件夹菜单、部门组织架构等。<br>2）用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。<br><strong>类图：</strong><br><img src="http://img.blog.csdn.net/20160525162606697" alt="这里写图片描述"><br><strong>涉及角色：</strong><br>1） Component：是组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component.<br>2） Leaf：在组合中表示叶子节点对象，叶子节点没有子节点。<br>3） Composite：定义树枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加和删除等。<br><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Component</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Leaf "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function">Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Component&gt; childs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Composite</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        childs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Component child : childs)</span><br><span class="line">            child.operation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        childs.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        childs.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> childs.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Component leaf1 = <span class="keyword">new</span> Leaf(<span class="string">"leaf1"</span>);</span><br><span class="line">        Composite com = <span class="keyword">new</span> Composite(<span class="string">"Composite"</span>);</span><br><span class="line">        com.add(leaf1);</span><br><span class="line">        com.add(<span class="keyword">new</span> Leaf(<span class="string">"leaf2"</span>));</span><br><span class="line">        </span><br><span class="line">        Composite com2 = <span class="keyword">new</span> Composite(<span class="string">"Composite2"</span>);</span><br><span class="line">        com2.add(<span class="keyword">new</span> Leaf(<span class="string">"l3"</span>));</span><br><span class="line">        com2.add(com);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优缺点：</strong><br><strong>优点：</strong><br>1）可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易。<br>2）客户端调用简单，客户端可以一致的使用组合结构或其中单个对象。<br>3）定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可以形成复杂的树形结构。<br>4）更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改原有代码。<br><strong>缺点 ：</strong>使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联</p>
<h1 id="七、享元模式（FlyWeight）"><a href="#七、享元模式（FlyWeight）" class="headerlink" title="七、享元模式（FlyWeight）"></a>七、享元模式（FlyWeight）</h1><p><strong>背景：</strong>面向对象可以非常方便的解决一些扩展性的问题，但是在这个过程中系统务必会产生一些类或者对象，如果系统中存在对象的个数过多时，将会导致系统的性能下降。对于这样的问题解决最简单直接的办法就是减少系统中对象的个数。<br>    享元模式提供了一种解决方案，使用共享技术实现相同或者相似对象的重用。也就是说实现相同或者相似对象的代码共享。<br>Java中最典型的应用就是String：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"a"</span>;</span><br><span class="line">String s2 = <span class="string">"a"</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">// String采用享元模式 存储在常量池</span></span><br></pre></td></tr></table></figure>
<p><strong>定义：</strong>运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。<br><strong>概念：</strong>在了解享元模式之前我们先要了解两个概念：内部状态、外部状态。<br>      <strong>内部状态：</strong>在享元对象内部不随外界环境改变而改变的共享部分。<br>      <strong>外部状态：</strong>随着环境的改变而改变，不能够共享的状态就是外部状态。<br>      由于享元模式区分了内部状态和外部状态，所以我们可以通过设置不同的外部状态使得相同的对象可以具备一些不同的特性，而内部状态设置为相同部分。在我们的程序设计过程中，我们可能会需要大量的细粒度对象来表示对象，如果这些对象除了几个参数不同外其他部分都相同，这个时候我们就可以利用享元模式来大大减少应用程序当中的对象。如何利用享元模式呢？这里我们只需要将他们少部分的不同的部分当做参数移动到类实例的外部去，然后再方法调用的时候将他们传递过来就可以了。这里也就说明了一点：内部状态存储于享元对象内部，而外部状态则应该由客户端来考虑。</p>
<p>享元模式分为两种：<strong>单纯享元模式</strong>和<strong>复合享元模式</strong>两种形式；<br><strong>（一）单纯享元模式：</strong><br>在单纯的享元模式中，所有的享元对象都是可以共享的。<br><strong>类图：</strong><br><img src="http://img.blog.csdn.net/20160525162731976" alt="这里写图片描述"><br><strong>涉及角色：</strong><br><strong>Flyweight:</strong> 抽象享元类。所有具体享元类的超类或者接口，通过这个接口，Flyweight可以接受并作用于外部专题<br><strong>ConcreteFlyweight:</strong> 具体享元类。指定内部状态，为内部状态增加存储空间。<br><strong>FlyweightFactory:</strong> 享元工厂类。用来创建并管理Flyweight对象，它主要用来确保合理地共享Flyweight，当用户请求一个Flyweight时，FlyweightFactory就会提供一个已经创建的Flyweight对象或者新建一个（如果不存在）。<br>    享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。<br><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Flywight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(String externalState)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title">Flywight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String internalState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight</span><span class="params">(String internalState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.internalState = internalState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">(String externalState)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"内部状态:"</span> + internalState);</span><br><span class="line">        System.out.println(<span class="string">"外部状态:"</span> + externalState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Flywight&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flywight <span class="title">getFlyweight</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        Flywight flywight = map.get(state);</span><br><span class="line">        <span class="keyword">if</span> (flywight == <span class="keyword">null</span>) &#123;</span><br><span class="line">            flywight = <span class="keyword">new</span> ConcreteFlyweight(state);</span><br><span class="line">            map.put(state, flywight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flywight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（二）复合享元模式：</strong><br>    在单纯享元模式中，所有的享元对象都是单纯享元对象，也就是说都是可以直接共享的。还有一种较为复杂的情况，将一些单纯享元使用合成模式加以复合，形成复合享元对象。这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。</p>
<p><strong>类图：</strong><br><img src="http://img.blog.csdn.net/20160525162828758" alt="这里写图片描述"><br><strong>角色：</strong><br><strong>抽象享元(Flyweight)</strong> ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。<br><strong>具体享元(ConcreteFlyweight)</strong>：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。<br><strong>复合享元(ConcreteCompositeFlyweight)</strong> ：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象。<br><strong>享元工厂(FlyweightFactory)</strong> ：负责创建和管理享元角色。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Flywight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(String externalState)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title">Flywight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String internalState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight</span><span class="params">(String internalState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.internalState = internalState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">(String externalState)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"内部状态:"</span> + internalState);</span><br><span class="line">        System.out.println(<span class="string">"外部状态:"</span> + externalState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCompositeFlyweight</span> <span class="keyword">extends</span> <span class="title">Flywight</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Flywight&gt; list = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String state, Flywight flywight)</span> </span>&#123;</span><br><span class="line">        list.put(state, flywight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">(String externalState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Flywight&gt; data : list.entrySet()) &#123;</span><br><span class="line">            data.getValue().operation(externalState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Flywight&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flywight <span class="title">getFlyweight</span><span class="params">(List&lt;String&gt; states)</span> </span>&#123;</span><br><span class="line">        ConcreteCompositeFlyweight ccFlyweight = <span class="keyword">new</span> ConcreteCompositeFlyweight();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String state : states)</span><br><span class="line">            ccFlyweight.add(state, getFlyweight(state));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ccFlyweight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flywight <span class="title">getFlyweight</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        Flywight flywight = map.get(state);</span><br><span class="line">        <span class="keyword">if</span> (flywight == <span class="keyword">null</span>) &#123;</span><br><span class="line">            flywight = <span class="keyword">new</span> ConcreteFlyweight(state);</span><br><span class="line">            map.put(state, flywight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flywight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优缺点：</strong><br>享元模式的优点在于它大幅度地降低内存中对象的数量。但是，它做到这一点所付出的代价也是很高的：<br>1）享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。<br>2）享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。</p>

      
    </div>
    
  </div>
  
    


    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2016/05/15/Picasso源码解析/">
                    Picasso源码解析
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2016/05/10/View机制深入学习（五） 事件处理机制一/">
                    View机制深入学习（五） 事件处理机制一
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、适配器模式"><span class="toc-number">1.</span> <span class="toc-text">一、适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1）类适配器模式"><span class="toc-number">1.1.</span> <span class="toc-text">1）类适配器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2）对象适配器模式"><span class="toc-number">1.2.</span> <span class="toc-text">2）对象适配器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3）适配器模式的优点-："><span class="toc-number">1.3.</span> <span class="toc-text">3）适配器模式的优点 ：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、装饰者模式"><span class="toc-number">2.</span> <span class="toc-text">二、装饰者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#代码："><span class="toc-number">2.1.</span> <span class="toc-text">代码：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#装饰者模式的优缺点："><span class="toc-number">2.2.</span> <span class="toc-text">装饰者模式的优缺点：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1）优点："><span class="toc-number">2.2.1.</span> <span class="toc-text">1）优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2）缺点："><span class="toc-number">2.2.2.</span> <span class="toc-text">2）缺点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、代理模式"><span class="toc-number">3.</span> <span class="toc-text">三、代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1）静态代理："><span class="toc-number">3.1.</span> <span class="toc-text">1）静态代理：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2）动态代理："><span class="toc-number">3.2.</span> <span class="toc-text">2）动态代理：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1）创建动态代理的流程："><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1）创建动态代理的流程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2）原理："><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2）原理：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、来看具体的动态生成的类-Proxy0"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">1、来看具体的动态生成的类$Proxy0:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、Proxy-newProxyInstance："><span class="toc-number">3.2.2.2.</span> <span class="toc-text">2、Proxy#newProxyInstance：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、getProxyClass0"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">3、getProxyClass0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、WeakCache-get"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">4、WeakCache#get:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5、ProxyClassFactory-apply"><span class="toc-number">3.2.2.5.</span> <span class="toc-text">5、ProxyClassFactory#apply:</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、外观模式（Fasade）"><span class="toc-number">4.</span> <span class="toc-text">四、外观模式（Fasade）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、桥接模式（Bridge）"><span class="toc-number">5.</span> <span class="toc-text">五、桥接模式（Bridge）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、组合模式（Composite）"><span class="toc-number">6.</span> <span class="toc-text">六、组合模式（Composite）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、享元模式（FlyWeight）"><span class="toc-number">7.</span> <span class="toc-text">七、享元模式（FlyWeight）</span></a></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }

    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })

    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>





    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"设计模式汇总--结构型模式　| Liuyunyicai　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2016/05/15/Picasso源码解析/" title="上一篇: Picasso源码解析">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2016/05/10/View机制深入学习（五） 事件处理机制一/" title="下一篇: View机制深入学习（五） 事件处理机制一">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/05/16/Fragment源码解析/">Fragment源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/16/Volley源码解析/">Volley源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/15/Picasso源码解析/">Picasso源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/12/设计模式汇总--结构型模型/">设计模式汇总--结构型模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/10/View机制深入学习（五） 事件处理机制一/">View机制深入学习（五） 事件处理机制一</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/06/Retrofit源码解析/">Retrofit源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/06/ArrayMapy、SparseArray源码学习/">ArrayMapy、SparseArray源码学习</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016 流云易采
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
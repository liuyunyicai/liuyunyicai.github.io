<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8">
  
  <title>Liuyunyicai</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Liuyunyicai">
<meta property="og:url" content="http://liuyunyicai.github.io/index.html">
<meta property="og:site_name" content="Liuyunyicai">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Liuyunyicai">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Liuyunyicai" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
      <link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet">
  
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
      <style> .article { opacity: 0;} </style>
  
  <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/clipboard.js/1.5.9/clipboard.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
          fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
          scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.0.9/scrollreveal.min.js"
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/liuyunyicai.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">流云易采</a></h1>
        </hgroup>

        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">文章列表</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/979724798@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" target="_blank" href="http://blog.csdn.net/woliuyunyicai" title="CSDN"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">Android,Java</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">流云易采</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/liuyunyicai.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">流云易采</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">文章列表</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/979724798@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" target="_blank" href="http://blog.csdn.net/woliuyunyicai" title="CSDN"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-设计模式汇总--结构型模型" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/12/设计模式汇总--结构型模型/" class="article-date">
      <time datetime="2016-05-12T02:14:15.022Z" itemprop="datePublished">2016-05-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/12/设计模式汇总--结构型模型/">设计模式汇总--结构型模型</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>总体来说设计模式分为三大类：<br><strong>创建型模式</strong>，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br><strong>结构型模式</strong>，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br><strong>行为型模式</strong>，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。<br>其实还有两类：并发型模式和线程池模式。<br>前面已经介绍了<a href="http://blog.csdn.net/woliuyunyicai/article/details/51287132" target="_blank" rel="external">《设计模式汇总：创建型模式》</a>，下面来看结构型模型：</p>
<h1 id="一、适配器模式"><a href="#一、适配器模式" class="headerlink" title="一、适配器模式"></a>一、适配器模式</h1><p>适配器模式在Android中比较常见，在ListView中无时无刻不在使用；<br>适配器的思想是将一个类的接口转换成客户希望的另外一个接口。其主要涉及三个角色：<br>模式所涉及的角色有：<br><strong>目标(Target)角色：</strong>这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。<br><strong>源(Adapee)角色：</strong>现在需要适配的接口。<br><strong>适配器(Adaper)角色：</strong>适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。<br>把Adaptee设想成使用ListView时想要加载的数据如ArrayList；<br>目标角色Target即是ListView源码中会用到的BaseAdapter这些;<br>而开发时继承BaseAdater自定义的Adapter即为Adapter角色；</p>
<p>实现适配器的方法有两种，可以分别通过继承和组合来实现适配器效果：<br>一种是类适配器模式；一种是对象适配器模式；</p>
<h2 id="1）类适配器模式"><a href="#1）类适配器模式" class="headerlink" title="1）类适配器模式"></a>1）类适配器模式</h2><p><img src="http://chuantu.biz/t4/13/1463017251x3340468442.png" alt="enter image description here"><br><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reqeust</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">specReqeust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adaptee specReqeust"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为Adaptee适配成Target接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reqeust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        specReqeust();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Target target = <span class="keyword">new</span> Adapter();</span><br><span class="line">        target.reqeust();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Target不为接口时，Java不支持多继承，可以采用组合的形式来实现：</p>
<h2 id="2）对象适配器模式"><a href="#2）对象适配器模式" class="headerlink" title="2）对象适配器模式"></a>2）对象适配器模式</h2><p><img src="http://chuantu.biz/t4/13/1463017302x3340468442.png" alt="enter image description here"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">reqeust</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">specReqeust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adaptee specReqeust"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为Adaptee适配成Target接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reqeust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.specReqeust();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将Adaptee适配成Target来使用</span></span><br><span class="line">        Target target = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee());</span><br><span class="line">        target.reqeust();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3）适配器模式的优点-："><a href="#3）适配器模式的优点-：" class="headerlink" title="3）适配器模式的优点 ："></a>3）适配器模式的优点 ：</h2><p><strong>1）更好的复用性</strong><br>系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。<br><strong>2）更好的扩展性</strong><br>在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。</p>
<p><strong>适配器模式的缺点 ：</strong><br>　　过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</p>
<h1 id="二、装饰者模式"><a href="#二、装饰者模式" class="headerlink" title="二、装饰者模式"></a>二、装饰者模式</h1><p>Java中InputStream，FilterInputStream，DataInputStream这些就是典型的装饰者模式。<br><img src="http://chuantu.biz/t4/13/1463017367x3340468442.png" alt="enter image description here"><br><strong>Decorator模式（别名Wrapper）</strong>：动态将职责附加到对象上，若要扩展功能，装饰者提供了比继承更具弹性的代替方案。<br>意图：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。<br><img src="http://chuantu.biz/t4/13/1463017414x2918527106.png" alt="enter image description here"></p>
<p><strong>适用性</strong>：<br>以下情况使用Decorator模式<br>1）需要扩展一个类的功能，或给一个类添加附加职责。<br>2）需要动态的给一个对象添加功能，这些功能可以再动态的撤销。<br>3）需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。<br>4）当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。 比如如下情况所提供的灵活性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = null;</span><br><span class="line">new BufferedInputStream(new DataInputStream(in));</span><br><span class="line">new DataInputStream(new BufferedInputStream(in));</span><br></pre></td></tr></table></figure>
<p>明显采用继承是比较难以实现的；</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">abstract class Compontent &#123;</span><br><span class="line">    abstract void operation1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConcreteCompontent extends Compontent&#123;</span><br><span class="line">    @Override</span><br><span class="line">    void operation1() &#123;</span><br><span class="line">        System.out.print(&quot;ConcreteCompontent operation1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Decorator extends Compontent &#123;</span><br><span class="line">    Compontent compontent;</span><br><span class="line"></span><br><span class="line">    public Decorator(Compontent compontent) &#123;</span><br><span class="line">        this.compontent = compontent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void operation1() &#123;</span><br><span class="line">        compontent.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConcreteDecorator1 extends Decorator &#123;</span><br><span class="line">    int addedField; // 动态添加的变量</span><br><span class="line"></span><br><span class="line">    public ConcreteDecorator1(Compontent compontent) &#123;</span><br><span class="line">        super(compontent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void operation1() &#123;</span><br><span class="line">        System.out.println(&quot;do other sth&quot;);</span><br><span class="line">        super.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConcreteDecorator2 extends Decorator &#123;</span><br><span class="line"></span><br><span class="line">    public ConcreteDecorator2(Compontent compontent) &#123;</span><br><span class="line">        super(compontent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 动态添加的操作</span><br><span class="line">    void operation2() &#123;</span><br><span class="line">        System.out.print(&quot;ConcreteCompontent operation2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client &#123;</span><br><span class="line">    public void dosth() &#123;</span><br><span class="line">        Compontent co = new ConcreteCompontent();</span><br><span class="line">        Compontent compontent0 = new ConcreteDecorator2(co);</span><br><span class="line">        Compontent compontent1 = new ConcreteDecorator1(new ConcreteDecorator2(co));</span><br><span class="line">        Compontent compontent2 = new ConcreteDecorator2(new ConcreteDecorator1(co));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装饰者模式的优缺点："><a href="#装饰者模式的优缺点：" class="headerlink" title="装饰者模式的优缺点："></a>装饰者模式的优缺点：</h2><h3 id="1）优点："><a href="#1）优点：" class="headerlink" title="1）优点："></a>1）优点：</h3><ol>
<li>通过组合而非继承的方式，实现了动态扩展对象的功能的能力。</li>
<li>有效避免了使用继承的方式扩展对象功能而带来的灵活性差，子类无限制扩张的问题。</li>
<li>充分利用了继承和组合的长处和短处，在灵活性和扩展性之间找到完美的平衡点。</li>
<li>装饰者和被装饰者之间虽然都是同一类型，但是它们彼此是完全独立并可以各自独立任意改变的。</li>
<li>遵守大部分GRASP原则和常用设计原则，高内聚、低偶合。</li>
<li>Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。</li>
<li>通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合<h3 id="2）缺点："><a href="#2）缺点：" class="headerlink" title="2）缺点："></a>2）缺点：</h3></li>
<li>装饰链不能过长，否则会影响效率。</li>
<li>因为所有对象都是Component,所以如果Component内部结构发生改变，则不可避免地影响所有子类(装饰者和被装饰者)，也就是说，通过继承建立的关系总是脆弱地，如果基类改变，势必影响对象的内部，而通过组合(Decoator HAS A Component)建立的关系只会影响被装饰对象的外部特征。</li>
<li>只在必要的时候使用装饰者模式，否则会提高程序的复杂性，增加系统维护难度。</li>
<li>这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。</li>
<li>装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</li>
<li>装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。</li>
</ol>
<p><strong>修饰者模式至少有两个关键利益及两个责任(liability)：</strong><br><strong>1）比静态继承更有弹性：</strong>修饰者模式提供一个较静态（多重）继承更有弹性的方式附加责任到对象上。使用修饰者责任可以在执行期简单的附加或取消，相对的继承需要为每一个新的附加责任建立一个新的类（如BorderedScrollableTextView、BorderedTextView等），如此会造成使用许多类及增加系统复杂度。更进一步；为特定的Component类提供不同的修饰者类让你比较及混合责任。<br>避免在层级架构中增加外貌装载(feature-laden《译注：在类中存有许多有关显示外貌的Component或属性等》)类：修饰者提供一个你要才有(pay-as-you-go)的方式附加责任。相对的不去在一个复杂客制化类中提供一所有可预测外貌；而定义一个简单类并在一个修饰者类逐步增加功能，其结果是一个应用系统无须准备一些不会使用到的外貌。同时也容易从他们所扩充的对象类定义一个新的修饰者类；甚至不在预测内。扩充一个复杂类需要揭露与你要附加责任无关的部分。<br><strong>2）修饰者及其Component不是同一个：</strong>修饰者就像透明的围墙(transparent enclosure)，但从一个对象界定(identity)的观点；一个被修饰的对象与其本身并不需要去区分(identical)，因此当你使用修饰者无区依赖对象界定。<br>有许多小对象：使用修饰这设计时常常产生在一个系统中组合看起来很像的许多小对象的结果。这些对象的差一点只是互动(interconnect)的方式；而非他的类或者其内不变量的值。虽然只要你了解他们就可以方便客制系统；但是可能难以学习及除错。<br>接口一致(conformance)：修饰者对象的接口必须与其修饰的对象接口一致具体修饰指(ConcreteDecorator)类必须继承一个公用(common)类。<br><strong>3）忽略(omitting)抽象修饰者类：</strong>当你只是附加单一责任时无须定义一个抽象修饰者类，这种情形一般是当你使用现存的类层级架构而非构建一个新的，因此你可以将修饰者传递请求到Component的责任融合(merge)至具体修饰者。<br>保持轻量(lightweight)的Component类：要确保接口一致，Component及修饰者必须自一个公用Component类继承，保持这个公用Component类轻量是很重要的，即必须专注于定义一个接口而非储存数据。数据责任的定义必须延缓至子类，否则太复杂的Component类会在数量上使用太过于重(heavyweight)。在Component类中放置太多的功能同时会增加其子类为许多没有必要的外表付出代价的可能性。<br><strong>4）改变对象的外表(skin)或其内部(guts)：</strong>我们可以想象修饰者就像对象的可以改变行为外表，另一种替代方式是改变其内部，策略模式(Strategy)就是改变其内部的作法。当Component类在本质上(intrinsically)太重(heavyweight)时策略模式是一个比较适当的选择，因为以修饰者模式实现成本太高。在策略模式中组件传递(forward)他的部分行为给另外的策略对象，策略模式让我们以替代的策略对象改变或扩充组件的功能。<br><strong>动态和静态的问题：</strong><br>所谓动态是说可以在系统运行时(RunTime)动态给对象增加其它职责而不需要修改代码或重新编译；<br>所谓静态是说必须通过调整代码(DesignTime)才能给对象增加职责,而且系统还需要重新编译；<br>从具体技术层面来说，对象的组合和继承正好对应于前面的动态和静态，因为通过对象组合建立的交互关系不是在代码中(DesignTime)固定死的，而是在运行时(RunTime)动态组合的；而通过继承建立的关系是僵硬的难以改变的，因为它是在代码中(DesignTime)固定死了的，根本不存在运行时(RunTime)改变的可能。换个角度说：我们应该多使用对象组合来保持系统的运行时扩展性，尽量少使继承，因为继承让程序变得僵硬，优先使用对象组合，而非类继承。</p>
<h1 id="三、代理模式"><a href="#三、代理模式" class="headerlink" title="三、代理模式"></a>三、代理模式</h1><p>代理模式就是给一个对象提供一个代理，并由代理对象控制对原对象的引用。<br>在代理模式中，proxy代理主要是起到一个中介的作用，它连接客户端和目标对象。<br>在Android的Binder机制中，代理模式起到很重要的作用。<br><img src="http://chuantu.biz/t4/13/1463017567x2918527106.png" alt="enter image description here"></p>
<p><strong>代理模式适用于：</strong><br>在某些情况下，我们不希望或是不能直接访问对象 A，而是通过访问一个中介对象 B，由 B 去访问 A 达成目的，这种方式我们就称为代理。<br>这里对象 A 所属类我们称为委托类，也称为被代理类，对象 B 所属类称为代理类。<br><strong>代理优点有：</strong><br>1）隐藏委托类的实现<br>2）解耦，不改变委托类代码情况下做一些额外处理，比如添加初始判断及其他公共操作<br><strong>代理模式中有三类角色：</strong><br><strong>抽象主题角色（Object）：</strong>声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。<br><strong>具体主题角色（RealObject)：</strong>也称为委托角色或者被代理角色。定义了代理对象所代表的目标对象。<br><strong>代理主题角色（Proxy)：</strong>也叫代理类。代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。</p>
<p>Java中根据程序运行前代理类是否已经存在，可以将代理分为静态代理和动态代理。 </p>
<h2 id="1）静态代理："><a href="#1）静态代理：" class="headerlink" title="1）静态代理："></a>1）静态代理：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">interface IObject &#123;</span><br><span class="line">    void operation1();</span><br><span class="line">    void operation2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RealObject implements IObject&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operation1() &#123;</span><br><span class="line">        System.out.print(&quot;RealObject operation1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operation2() &#123;</span><br><span class="line">        System.out.print(&quot;RealObject operation2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Proxy implements IObject &#123;</span><br><span class="line">    private RealObject real;</span><br><span class="line"></span><br><span class="line">    public Proxy() &#123;</span><br><span class="line">        real = new RealObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operation1() &#123;</span><br><span class="line">        real.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operation2() &#123;</span><br><span class="line">        real.operation2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client &#123;</span><br><span class="line">    void doSth() &#123;</span><br><span class="line">        Proxy proxy = new Proxy();</span><br><span class="line">        proxy.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上可见，Proxy就相当于生活中的代理，比如买东西的时候，没必要去生产商品的厂家去购买，直接去代理地点也即是超市购买即可；代理通过调用委托类来未用户提供同样的服务，而又避免了用户去直接调用委托类。</p>
<h2 id="2）动态代理："><a href="#2）动态代理：" class="headerlink" title="2）动态代理："></a>2）动态代理：</h2><p>由前所见，每一个委托类需要对应一个代理类，这样在大型项目中将会出现众多的代理类，而这些代理类只是一个中介而已，为了优化代码结果，Java提供了动态代理的方式，使用反射来动态生成相应的代理类来为用户提供服务。</p>
<h3 id="2-1）创建动态代理的流程："><a href="#2-1）创建动态代理的流程：" class="headerlink" title="2.1）创建动态代理的流程："></a>2.1）创建动态代理的流程：</h3><p>1、定义一个代理类和委托类共同使用的接口Operate<br>2、实现一个委托类继承Interface，它是真正实现操作逻辑的类记为Real<br>3、继承一个InvocationHandler，传入委托类实例；重写invoke函数<br>4、使用Proxy.newProxyInstance来动态创建一个代理类，今后的所有操作都通过这个实例proxy来操作；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 创建委托类和代理类统一的接口</span><br><span class="line">interface Operate &#123;</span><br><span class="line">    void do1();</span><br><span class="line">    void do2();</span><br><span class="line">    void do3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体的委托类</span><br><span class="line">class RealImpl implements Operate &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void do1() &#123;</span><br><span class="line">        System. out.println(&quot;Real do1&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void do2() &#123;</span><br><span class="line">        System. out.println(&quot;Real do2&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void do3() &#123;</span><br><span class="line">        System. out.println(&quot;Real do3&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 自定义InvocationHandler</span><br><span class="line">class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">    private Object target ;</span><br><span class="line"></span><br><span class="line">    public MyInvocationHandler(Object target ) &#123;</span><br><span class="line">        this.target = target ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy , Method method, Object[] args)</span><br><span class="line">            throws Throwable &#123;</span><br><span class="line">        // 执行 method之前的一些操作</span><br><span class="line">        Object result = method.invoke( target, args);</span><br><span class="line">        // 执行 method之后的一些自处理操作</span><br><span class="line">        return result ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">publicclassProxyDynamic &#123;</span><br><span class="line">        // 具体的使用</span><br><span class="line">        public void a() &#123;</span><br><span class="line">              Operate proxy = (Operate) Proxy.newProxyInstance(Operate.class.getClassLoader(), new Class&lt;?&gt;[] &#123;Operate.class&#125;,</span><br><span class="line">                            new MyInvocationHandler(new RealImpl()));</span><br><span class="line">               proxy.do1();</span><br><span class="line">               proxy.do2();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2）原理："><a href="#2-2）原理：" class="headerlink" title="2.2）原理："></a>2.2）原理：</h3><p>Proxy这个类根据ClassLoader以及interfaces这个数组，获得一个相应的代理类的名称，一般的格式是packagename+$Proxy+num，然后通过<br> ProxyGenerator.generateProxyClass(proxyName, interfaces , accessFlags );<br>来创建对应的类；最后通过反射调用该类的构造器创建一个具体实例；这个类是继承Proxy的，Proxy持有InvocationHandler的实例h；<br>代理类的所有操作都是通过将Method传递到h的invoke函数，通过invoke函数进行最终的处理；<br>因此InvocationHandler是代理类和委托类之间的中介；</p>
<h4 id="1、来看具体的动态生成的类-Proxy0"><a href="#1、来看具体的动态生成的类-Proxy0" class="headerlink" title="1、来看具体的动态生成的类$Proxy0:"></a>1、来看具体的动态生成的类$Proxy0:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">import com.hust.liuyun.Operate;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line">public final class $Proxy0 extends Proxy</span><br><span class="line">  implements Operate</span><br><span class="line">&#123;</span><br><span class="line">  private static Method m4 ;</span><br><span class="line">  private static Method m1 ;</span><br><span class="line">  private static Method m5 ;</span><br><span class="line">  private static Method m0 ;</span><br><span class="line">  private static Method m3 ;</span><br><span class="line">  private static Method m2 ;</span><br><span class="line"></span><br><span class="line">  public $Proxy0(InvocationHandler paramInvocationHandler)</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    super(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final void operateMethod1()</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      h.invoke( this, m4, null );</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final boolean equals(Object paramObject)</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return ((Boolean)h.invoke( this, m1, new Object[] &#123; paramObject &#125;)).booleanValue();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final void operateMethod2()</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      h.invoke( this, m5, null );</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final int hashCode()</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return ((Integer)h.invoke( this, m0, null )).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final void operateMethod3()</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      h.invoke( this, m3, null );</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final String toString()</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return (String)h.invoke( this, m2, null );</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      m4 = Class.forName(&quot;com.hust.liuyun.Operate&quot;).getMethod( &quot;do1&quot;, new Class[0]);</span><br><span class="line">      m1 = Class.forName(&quot;java.lang.Object&quot; ).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);</span><br><span class="line">      m5 = Class.forName(&quot;com.hust.liuyun.Operate&quot;).getMethod( &quot;do2&quot;, new Class[0]);</span><br><span class="line">      m0 = Class.forName(&quot;java.lang.Object&quot; ).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">      m3 = Class.forName(&quot;com.hust.liuyun.Operate&quot;).getMethod( &quot;do3&quot;, new Class[0]);</span><br><span class="line">      m2 = Class.forName(&quot;java.lang.Object&quot; ).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoSuchMethodError(localNoSuchMethodException .getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoClassDefFoundError(localClassNotFoundException .getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到该生成类是继承Proxy的，在构造函数中将InvocationHandler的实例传递进来；然后通过反射获取到该类中所有相关的Method的实例。<br>相关的所有操作都是通过h.invoke来实现的。</p>
<h4 id="2、Proxy-newProxyInstance："><a href="#2、Proxy-newProxyInstance：" class="headerlink" title="2、Proxy#newProxyInstance："></a>2、Proxy#newProxyInstance：</h4><p>public static Object newProxyInstance(ClassLoader loader,<br>                 Class&lt;?&gt;[] interfaces, InvocationHandler h )<br>                  throws IllegalArgumentException {<br>          Objects. requireNonNull(h);</p>
<pre><code> final Class&lt;?&gt;[] intfs = interfaces .clone();
 final SecurityManager sm = System.getSecurityManager ();
 if (sm != null) {
        checkProxyAccess(Reflection. getCallerClass(), loader, intfs);
}

 /*
 * Look up or generate the designated proxy class.
 */
 // 通过这个重要类，来生成一个动态代理类
Class&lt;?&gt; cl = getProxyClass0(loader, intfs);

 /*
 * Invoke its constructor with the designated invocation handler.
 */
 try {
        if (sm != null) {
              checkNewProxyPermission(Reflection.getCallerClass() , cl);
       }

        // 调用动态代理类的构造器来创建一个具体实例
        final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);
        final InvocationHandler ih = h ;
        if (!Modifier.isPublic( cl.getModifiers())) {
             AccessController. doPrivileged(new PrivilegedAction&lt;Void&gt;() {
                     public Void run() {
                            cons.setAccessible( true);
                            return null ;
                    }
             });
       }
        // 可以看到这里将InvocationHandler这个中介以参数形式加入进来
        return cons .newInstance(new Object[] { h });
} catch (IllegalAccessException | InstantiationException e) {
        throw new InternalError(e.toString(), e);
} catch (InvocationTargetException e ) {
       Throwable t = e.getCause();
        if (t instanceof RuntimeException) {
              throw (RuntimeException) t ;
       } else {
              throw new InternalError(t.toString(), t);
       }
} catch (NoSuchMethodException e ) {
        throw new InternalError(e.toString(), e);
}
</code></pre><p>   }</p>
<p>具体的流程：<br>1）进行一些权限检查之类<br>2）通过getProxyClass0来获得对应的动态代理类（可能是新创建，也可能是从Cache中取出）<br>3）调用代理类的构造器来创建一个具体的代理类；</p>
<h4 id="3、getProxyClass0"><a href="#3、getProxyClass0" class="headerlink" title="3、getProxyClass0"></a>3、getProxyClass0</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static final WeakCache &lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">proxyClassCache = new WeakCache &lt;&gt;(new KeyFactory(), new ProxyClassFactory());</span><br><span class="line">/**</span><br><span class="line"> * Generate a proxy class.  Must call the checkProxyAccess method</span><br><span class="line"> * to perform permission checks before calling this.</span><br><span class="line"> */</span><br><span class="line">private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    if (interfaces.length &gt; 65535) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If the proxy class defined by the given loader implementing</span><br><span class="line">    // the given interfaces exists, this will simply return the cached copy;</span><br><span class="line">    // otherwise, it will create the proxy class via the ProxyClassFactory</span><br><span class="line">    return proxyClassCache.get(loader , interfaces );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个WeakCache来存储相关的代理类信息，通过代理类来获取；</p>
<h4 id="4、WeakCache-get"><a href="#4、WeakCache-get" class="headerlink" title="4、WeakCache#get:"></a>4、WeakCache#get:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public V get(K key , P parameter) &#123;</span><br><span class="line">    Objects.requireNonNull(parameter );</span><br><span class="line"></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    // 根据ClassLoader获取相应的key值</span><br><span class="line">    Object cacheKey = CacheKey.valueOf(key , refQueue);</span><br><span class="line"></span><br><span class="line">    // 根据ClassLoader获得其中的ConcurrentMap</span><br><span class="line">    // lazily install the 2nd level valuesMap for the particular cacheKey</span><br><span class="line">    ConcurrentMap&lt;Object, Supplier&lt; V&gt;&gt; valuesMap = map.get(cacheKey );</span><br><span class="line">    if (valuesMap == null) &#123;</span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt; V&gt;&gt; oldValuesMap</span><br><span class="line">            = map.putIfAbsent(cacheKey,</span><br><span class="line">                              valuesMap = new ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        if (oldValuesMap != null) &#123;</span><br><span class="line">            valuesMap = oldValuesMap ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span><br><span class="line">    // subKey from valuesMap</span><br><span class="line">    // 在ConcurrentMap中，key对应的interfaces，Value则对应着具体的类Class信息&lt;?&gt;</span><br><span class="line">    // 代理类的具体创建逻辑是通过subKeyFactory.apply来实现的</span><br><span class="line">    Object subKey = Objects.requireNonNull(subKeyFactory.apply( key, parameter));</span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap .get(subKey );</span><br><span class="line">    Factory factory = null;</span><br><span class="line"></span><br><span class="line">    while ( true) &#123;</span><br><span class="line">       // 如果已经存在，则直接返回</span><br><span class="line">        if (supplier != null) &#123;</span><br><span class="line">            // supplier might be a Factory or a CacheValue&lt;V&gt; instance</span><br><span class="line">            V value = supplier.get();</span><br><span class="line">            if (value != null) &#123;</span><br><span class="line">                return value ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // else no supplier in cache</span><br><span class="line">        // or a supplier that returned null (could be a cleared CacheValue</span><br><span class="line">        // or a Factory that wasn&apos;t successful in installing the CacheValue)</span><br><span class="line"></span><br><span class="line">        // lazily construct a Factory</span><br><span class="line">        if (factory == null) &#123;</span><br><span class="line">            factory = new Factory( key, parameter, subKey , valuesMap );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (supplier == null) &#123;</span><br><span class="line">            supplier = valuesMap.putIfAbsent(subKey , factory );</span><br><span class="line">            if (supplier == null) &#123;</span><br><span class="line">                // successfully installed Factory</span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125;</span><br><span class="line">            // else retry with winning supplier</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (valuesMap .replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                // successfully replaced</span><br><span class="line">                // cleared CacheEntry / unsuccessful Factory</span><br><span class="line">                // with our Factory</span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // retry with current supplier</span><br><span class="line">                supplier = valuesMap.get(subKey );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的Cache是个两级缓存，通过ClassLoader为key来缓存一个ConcurrentMap；该ConcurrentMap的key对应着传入进来的interface参数；</p>
<p>由前面知道subKeyFactory对应的具体类为：ProxyClassFactory，具体来看其apply函数；</p>
<h4 id="5、ProxyClassFactory-apply"><a href="#5、ProxyClassFactory-apply" class="headerlink" title="5、ProxyClassFactory#apply:"></a>5、ProxyClassFactory#apply:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">private static final class ProxyClassFactory</span><br><span class="line">    implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    // prefix for all proxy class names</span><br><span class="line">    private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;</span><br><span class="line"></span><br><span class="line">    // next number to use for generation of unique proxy class names</span><br><span class="line">    private static final AtomicLong nextUniqueNumber = new AtomicLong();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces .length );</span><br><span class="line">       </span><br><span class="line">        /** 对传递进来的interface进行判断</span><br><span class="line">         * 1、先判断该interface是否是通过传递进来的ClassLoader来加载的</span><br><span class="line">         * 2、判断该interface是否为接口</span><br><span class="line">         * 3、判断该接口数组中是否有重复的类  **/</span><br><span class="line">        for (Class&lt;?&gt; intf : interfaces ) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Verify that the class loader resolves the name of this</span><br><span class="line">             * interface to the same Class object.</span><br><span class="line">             */</span><br><span class="line">            Class&lt;?&gt; interfaceClass = null ;</span><br><span class="line">            try &#123;</span><br><span class="line">                interfaceClass = Class.forName( intf.getName(), false, loader );</span><br><span class="line">            &#125; catch (ClassNotFoundException e ) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            if (interfaceClass != intf ) &#123;</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    intf + &quot; is not visible from class loader&quot; );</span><br><span class="line">            &#125;</span><br><span class="line">            /*</span><br><span class="line">             * Verify that the Class object actually represents an</span><br><span class="line">             * interface.</span><br><span class="line">             */</span><br><span class="line">            if (!interfaceClass .isInterface()) &#123;</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    interfaceClass.getName() + &quot; is not an interface&quot; );</span><br><span class="line">            &#125;</span><br><span class="line">            /*</span><br><span class="line">             * Verify that this interface is not a duplicate.</span><br><span class="line">             */</span><br><span class="line">            if (interfaceSet .put(interfaceClass , Boolean.TRUE) != null) &#123;</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    &quot;repeated interface: &quot; + interfaceClass .getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String proxyPkg = null;     // package to define proxy class in</span><br><span class="line">        int accessFlags = Modifier.PUBLIC | Modifier. FINAL;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Record the package of a non-public proxy interface so that the</span><br><span class="line">         * proxy class will be defined in the same package.  Verify that</span><br><span class="line">         * all non-public proxy interfaces are in the same package.</span><br><span class="line">         */</span><br><span class="line">        /******** 获取该代理类的名称 ********/</span><br><span class="line">        for (Class&lt;?&gt; intf : interfaces ) &#123;</span><br><span class="line">            int flags = intf .getModifiers();</span><br><span class="line">            if (!Modifier.isPublic( flags)) &#123;</span><br><span class="line">                accessFlags = Modifier.FINAL;</span><br><span class="line">                String name = intf.getName();</span><br><span class="line">                int n = name .lastIndexOf(&apos;.&apos;);</span><br><span class="line">                String pkg = (( n == -1) ? &quot;&quot; : name .substring(0, n + 1));</span><br><span class="line">                if (proxyPkg == null) &#123;</span><br><span class="line">                    proxyPkg = pkg;</span><br><span class="line">                &#125; else if (!pkg .equals(proxyPkg )) &#123;</span><br><span class="line">                    throw new IllegalArgumentException(</span><br><span class="line">                        &quot;non-public interfaces from different packages&quot; );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (proxyPkg == null) &#123;</span><br><span class="line">            // if no non-public proxy interfaces, use com.sun.proxy package</span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Choose a name for the proxy class to generate.</span><br><span class="line">         */</span><br><span class="line">        long num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">        // 代理类的名称一般为包名+$ Proxy+num</span><br><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Generate the specified proxy class.</span><br><span class="line">         */</span><br><span class="line">        /** 通过ProxyGenerator.generateProxyClass来具体创建该代理类的二进制码 **/</span><br><span class="line">        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces , accessFlags) ;</span><br><span class="line">        try &#123;</span><br><span class="line">               // 这是一个native类，通过它来具体加载该代理类，返回响应的Class信息</span><br><span class="line">            return defineClass0( loader, proxyName,</span><br><span class="line">                                proxyClassFile, 0, proxyClassFile .length );</span><br><span class="line">        &#125; catch (ClassFormatError e ) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * A ClassFormatError here means that (barring bugs in the</span><br><span class="line">             * proxy class generation code) there was some other</span><br><span class="line">             * invalid aspect of the arguments supplied to the proxy</span><br><span class="line">             * class creation (such as virtual machine limitations</span><br><span class="line">             * exceeded).</span><br><span class="line">             */</span><br><span class="line">            throw new IllegalArgumentException(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）对传递进来的interface进行判断</p>
<ul>
<li>先判断该interface是否是通过传递进来的ClassLoader来加载的</li>
<li>判断该interface是否为接口</li>
<li>判断该接口数组中是否有重复的类<br>2）获取该代理类的名称;代理类的名称一般为包名+$ Proxy+num<br>3）通过ProxyGenerator.generateProxyClass来具体创建该代理类的二进制码<br>4）defineClass0,这是一个native类，通过它来具体加载该代理类，返回响应的Class信息</li>
</ul>
<p>参考博客：<a href="http://blog.csdn.net/u013256816/article/details/51009592" target="_blank" rel="external">http://blog.csdn.net/u013256816/article/details/51009592</a><br><strong>装饰模式和代理模式的区别 ：</strong><br>装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p>
<p><strong>外观模式和代理模式的区别 ：</strong><br>代理与外观的主要区别在于，代理对象代表一个单一对象而外观对象代表一个子系统，代理的客户对象无法直接访问对象，由代理提供单独的目标对象的访问，而通常外观对象提供对子系统各元件功能的简化的共同层次的调用接口。代理是一种原来对象的代表，其他需要与这个对象打交道的操作都是和这个代表交涉的。</p>
<p><strong>适配器模式和代理模式的区别 ：</strong><br>适配器模式改变所考虑的对象的接口，代理模式不能改变所代理对象的接口。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-View机制深入学习（五） 事件处理机制一" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/10/View机制深入学习（五） 事件处理机制一/" class="article-date">
      <time datetime="2016-05-10T09:28:45.538Z" itemprop="datePublished">2016-05-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/10/View机制深入学习（五） 事件处理机制一/">View机制深入学习（五） 事件处理机制一</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>以TouchEvent为主，看一下View和ViewGroup内部是如何处理Input Events的；<br>首先来看事件的产生来源：</p>
<h1 id="一、获取事件"><a href="#一、获取事件" class="headerlink" title="一、获取事件:"></a>一、获取事件:</h1><p>事件的来源可以分为“软件”，“硬件”两种；<br>主要的事件包含有：<br><strong>按键事件（KeyEvent）</strong>    :即物理按键按下产生的事件，相关的常用物理按键一般有HOME,BACK等<br><strong>触摸事件（TouchEvent）</strong>:<br>鼠标事件（MouseEvent）、轨迹球事件（TrackBallEvent）（这两个已经不常见）；</p>
<p>针对所有事件的共性抽象出了InputEvent接口；其有两个子类：KeyEvent,MotionEvent;</p>
<h2 id="1、事件的投递流程："><a href="#1、事件的投递流程：" class="headerlink" title="1、事件的投递流程："></a>1、事件的投递流程：</h2><p><img src="http://chuantu.biz/t4/12/1462870025x3738746571.png" alt="enter image description here"></p>
<p><strong>1&gt;源信息采集</strong><br>    对“硬件源”产生的原始信息进行收集；它需要Linux内核驱动的支持，Android系统通过/dev/input下的节点来访问当前发生的事件。<br><strong>2&gt;前期处理</strong><br>    对收集到信息进行筛选以及格式转化<br><strong>3&gt;WMS分配</strong><br>    WMS是窗口的Manager，同时也是InputEvent的派发者。<br><strong>4&gt;应用程序处理</strong><br>    WMS会先把事件传递到对应ViewRootImpl，ViewRootImpl分发事件，传递给相应的DecorView,DecorView在调用Activity中的Window.Callback将事件传递给Activity；然后Activity在通过dispatchTouchEvent分发事件，下面就来到熟悉的View事件分发机制；具体见<a href="http://blog.csdn.net/woliuyunyicai/article/details/49866177" target="_blank" rel="external">《View机制深入学习（四）View的事件分发机制》</a></p>
<h2 id="2、InputManagerService启动"><a href="#2、InputManagerService启动" class="headerlink" title="2、InputManagerService启动:"></a>2、InputManagerService启动:</h2><p>InputManagerService同样也是有SystemServer进程启动，这个在<a href="http://blog.csdn.net/woliuyunyicai/article/details/47749009" target="_blank" rel="external">Android启动过程——init.rc,Zygote,SystemServer</a>中已经提到过，<br>系统启动后创建init进程（pid=1）,init进程创建出Zygote进程，然后Zygote进程孵化出SystemServer进程，在SystemServer进程中创建IMS：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@path</span>: \frameworks\base\services\java\com\android\server\SystemServer.java */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以看到IMS和WMS是紧密相关的</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// @value InputManagerService inputManager</span></span><br><span class="line">        inputManager = <span class="keyword">new</span> InputManagerService(context, wmHandler);</span><br><span class="line"></span><br><span class="line">        Slog.i(TAG, <span class="string">"Window Manager"</span>);</span><br><span class="line">        <span class="comment">// @value WindowManagerService wm</span></span><br><span class="line">        wm = WindowManagerService.main(context, power, display, inputManager,</span><br><span class="line">                uiHandler, wmHandler,</span><br><span class="line">                factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">                !firstBoot, onlyCore);</span><br><span class="line">        ServiceManager.addService(Context.WINDOW_SERVICE, wm);</span><br><span class="line">        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);</span><br><span class="line"></span><br><span class="line">        ActivityManagerService.self().setWindowManager(wm);</span><br><span class="line"></span><br><span class="line">        inputManager.setWindowManagerCallbacks(wm.getInputMonitor());</span><br><span class="line">        inputManager.start();</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、InputMangerService："><a href="#3、InputMangerService：" class="headerlink" title="3、InputMangerService："></a>3、InputMangerService：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\java\com\android\server\input\InputManagerService.java **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputManagerService</span> <span class="keyword">extends</span> <span class="title">IInputManager</span>.<span class="title">Stub</span> <span class="keyword">implements</span> <span class="title">Watchdog</span>.<span class="title">Monitor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指向native端IMS类对象的地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> mPtr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputManagerService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">        <span class="keyword">this</span>.mHandler = <span class="keyword">new</span> InputManagerHandler(DisplayThread.get().getLooper());</span><br><span class="line"></span><br><span class="line">        mUseDevInputEventForAudioJack = context.getResources().getBoolean(R.bool.config_useDevInputEventForAudioJack);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建native IMS对象</span></span><br><span class="line">        mPtr = nativeInit(<span class="keyword">this</span>, mContext, mHandler.getLooper().getQueue());</span><br><span class="line"></span><br><span class="line">        LocalServices.addService(InputManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到Java层的IMS实际上只是对Native层的InputManager的一层包装；其创建主要是native层进行创建，并把native层的InputManager地址赋值给InputManagerService的mPtr变量；<br>而且注意nativeInit中传入了Looper中的MessageQueue变量；</p>
<h2 id="4、native层的InputManagerService——NativeInputManager类："><a href="#4、native层的InputManagerService——NativeInputManager类：" class="headerlink" title="4、native层的InputManagerService——NativeInputManager类："></a>4、native层的InputManagerService——NativeInputManager类：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span></span><br><span class="line"><span class="keyword">class</span> NativeInputManager : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase,</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> InputReaderPolicyInterface,</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> InputDispatcherPolicyInterface,</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> PointerControllerPolicyInterface</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz,</span><br><span class="line">                        jobject serviceObj, jobject contextObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个Message Queue</span></span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"MessageQueue is not initialized."</span>);</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以看到NativeInputManager中包含有一个Looper，用以进行事件分派</span></span><br><span class="line">    NativeInputManager* im = new NativeInputManager(contextObj, serviceObj,</span><br><span class="line">            messageQueue-&gt;getLooper());</span><br><span class="line">    im-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 返回创建的IMS实例对象的地址（强制转化为long类型）</span></span><br><span class="line">    return <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(im);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到首先通过android_os_MessageQueue_getMessageQueue函数获取到本地端的MessageQueue，这个在Handler机制中的本地解析<a href="http://blog.csdn.net/woliuyunyicai/article/details/50780529" target="_blank" rel="external">《Handler机制深入解析》</a>中已经提到，该NativeMessageQueue对象在java层创建Looper时创建实例，然后将地址指针赋值为Looper对应的MessageQueue中的ptr变量中，这里根据指针来获取该NativeMessageQueue对象；<br>根据NativeMessageQueue对象获取其中对应的Looper（native），用以创建NativeInputManger;来看NativeInputManager的构造函数：</p>
<h2 id="5、NativeInputManager-NativeInputManager"><a href="#5、NativeInputManager-NativeInputManager" class="headerlink" title="5、NativeInputManager#NativeInputManager:"></a>5、NativeInputManager#NativeInputManager:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span></span><br><span class="line">NativeInputManager::NativeInputManager(jobject contextObj,</span><br><span class="line">                                       jobject serviceObj, <span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper) :</span><br><span class="line">        mLooper(looper), mInteractive(<span class="literal">true</span>) &#123;</span><br><span class="line">    JNIEnv* env = jniEnv();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局引用</span></span><br><span class="line">    mContextObj = env-&gt;NewGlobalRef(contextObj);</span><br><span class="line">    mServiceObj = env-&gt;NewGlobalRef(serviceObj);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mLocked.systemUiVisibility = ASYSTEM_UI_VISIBILITY_STATUS_BAR_VISIBLE;</span><br><span class="line">        mLocked.pointerSpeed = <span class="number">0</span>;</span><br><span class="line">        mLocked.pointerGesturesEnabled = <span class="literal">true</span>;</span><br><span class="line">        mLocked.showTouches = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建EventHUb</span></span><br><span class="line">    sp&lt;EventHub&gt; eventHub = new EventHub();</span><br><span class="line">    <span class="comment">// 创建InputManager实例</span></span><br><span class="line">    mInputManager = new InputManager(eventHub, this, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NativeInputManager中保存了Looper(native)实例；并且创建了EventHub，以及InputManager两个重要的对象；<br>EventHub从名字就可以看出，它是用来收集以及存储外部的输入事件的；<br>而InputManager则是对Event事件进行处理分发；<br>先来看EventHub：</p>
<h3 id="（一）EventHub："><a href="#（一）EventHub：" class="headerlink" title="（一）EventHub："></a>（一）EventHub：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*\frameworks\native\services\inputflinger\EventHub*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *DEVICE_PATH = <span class="string">"/dev/input"</span>;</span><br><span class="line">EventHub::EventHub(<span class="keyword">void</span>) :</span><br><span class="line">        mBuiltInKeyboardId(NO_BUILT_IN_KEYBOARD), mNextDeviceId(<span class="number">1</span>), mControllerNumbers(),</span><br><span class="line">        mOpeningDevices(<span class="number">0</span>), mClosingDevices(<span class="number">0</span>),</span><br><span class="line">        mNeedToSendFinishedDeviceScan(<span class="literal">false</span>),</span><br><span class="line">        mNeedToReopenDevices(<span class="literal">false</span>), mNeedToScanDevices(<span class="literal">true</span>),</span><br><span class="line">        mPendingEventCount(<span class="number">0</span>), mPendingEventIndex(<span class="number">0</span>), mPendingINotify(<span class="literal">false</span>) &#123;</span><br><span class="line">    acquire_wake_lock(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建epoll对象</span></span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用inotify机制监听文件或目录的移动、读取、写入或删除等事件</span></span><br><span class="line">    <span class="comment">// 创建一个inotify对象</span></span><br><span class="line">    mINotifyFd = inotify_init();</span><br><span class="line">    <span class="comment">// 把监控项添加到mINotifyFd对象的监控列表中</span></span><br><span class="line">    <span class="comment">// 这里监听的文件路径为"/dev/input"</span></span><br><span class="line">    <span class="keyword">int</span> result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> epoll_event eventItem;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(eventItem));</span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_INOTIFY;</span><br><span class="line">    <span class="comment">// 把inotify对象mINotifyFd添加到epoll对象的兴趣列表中，此处采用inotify与epoll机制结合起来检查文件</span></span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> wakeFds[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 创建pipe</span></span><br><span class="line">    result = pipe(wakeFds);</span><br><span class="line"></span><br><span class="line">    mWakeReadPipeFd = wakeFds[<span class="number">0</span>];</span><br><span class="line">    mWakeWritePipeFd = wakeFds[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 设置为非阻塞</span></span><br><span class="line">    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_WAKE;</span><br><span class="line">    <span class="comment">// 添加到epoll的兴趣列表中</span></span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> major, minor;</span><br><span class="line">    getLinuxRelease(&amp;major, &amp;minor);</span><br><span class="line">    <span class="comment">// EPOLLWAKEUP was introduced in kernel 3.5</span></span><br><span class="line">    mUsingEpollWakeup = major &gt; <span class="number">3</span> || (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面进行了一系列的变量的初始化；<br>然后epoll_create创建了一个epoll对象，可以看到和Handler中一样，IMS中也用到了epoll机制进行监听；<br>而后可以看到IMS是INotify机制和Epoll机制同时使用的：inotify_init创建iNotify对象，inotify_add_watch则将”/dev/input”路径添加到监听列表中；当”/dev/input”中文件发生变化，将会产生响应；<br>了解INotifiy文件系统监听机制：<br><a href="https://www.ibm.com/developerworks/cn/linux/l-inotifynew/" target="_blank" rel="external">《inotify – Linux 2.6 内核中的文件系统变化通知机制》</a><br><a href="http://www.infoq.com/cn/articles/inotify-linux-file-system-event-monitoring" target="_blank" rel="external">《Inotify: 高效、实时的Linux文件系统事件监控框架》</a><br>然后将iNotify对象添加到Epoll的兴趣列表中，进行监听；<br>然后同Handler机制，创建一个Pipe，然后设置为非阻塞形式，然后添加到epoll的兴趣列表中；下面就注意在何时调用epoll_wait来开启监听即可；这里仅进行了初始化；</p>
<h3 id="（二）InputManager："><a href="#（二）InputManager：" class="headerlink" title="（二）InputManager："></a>（二）InputManager：</h3><h4 id="1）构造函数："><a href="#1）构造函数：" class="headerlink" title="1）构造函数："></a>1）构造函数：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputManager.cpp **/</span></span><br><span class="line"><span class="keyword">class</span> InputManagerInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    sp&lt;InputReaderInterface&gt; mReader;</span><br><span class="line">    sp&lt;InputReaderThread&gt; mReaderThread;</span><br><span class="line"></span><br><span class="line">    sp&lt;InputDispatcherInterface&gt; mDispatcher;</span><br><span class="line">    sp&lt;InputDispatcherThread&gt; mDispatcherThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    InputManager::InputManager(</span><br><span class="line">            <span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;</span><br><span class="line">        <span class="comment">// 创建InputDispatcher</span></span><br><span class="line">        mDispatcher = new InputDispatcher(dispatcherPolicy);</span><br><span class="line">        <span class="comment">// 创建InputReader</span></span><br><span class="line">        mReader = new InputReader(eventHub, readerPolicy, mDispatcher);</span><br><span class="line">        initialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 进行初始化 **/</span></span><br><span class="line">    <span class="keyword">void</span> InputManager::initialize() &#123;</span><br><span class="line">        <span class="comment">// 创建两个Thread的实例</span></span><br><span class="line">        mReaderThread = new InputReaderThread(mReader);</span><br><span class="line">        mDispatcherThread = new InputDispatcherThread(mDispatcher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>InputManager中传入了前面创建的EventHub对象；然后初始化了两个中重要的类，InputDispatcher，以及InputReader;<br>显然从名字可以看出 InputReader用来读取EventHub中的事件，然后通过InputDiapatcher进行分发（InputReader中持有InputDisptcher的引用）；</p>
<p><strong>先看InputDispatcher:</strong></p>
<h5 id="1-1）InputDispatcher"><a href="#1-1）InputDispatcher" class="headerlink" title="1.1）InputDispatcher:"></a>1.1）InputDispatcher:</h5><p><strong>继承关系：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> InputDispatcher : <span class="keyword">public</span> InputDispatcherInterface</span><br><span class="line"><span class="keyword">class</span> InputDispatcherInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase, <span class="keyword">public</span> InputListenerInterface</span><br></pre></td></tr></table></figure>
<p><strong>构造函数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line">InputDispatcher::InputDispatcher(<span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy) :</span><br><span class="line">    mPolicy(policy),</span><br><span class="line">    mPendingEvent(<span class="literal">NULL</span>), mAppSwitchSawKeyDown(<span class="literal">false</span>), mAppSwitchDueTime(LONG_LONG_MAX),</span><br><span class="line">    mNextUnblockedEvent(<span class="literal">NULL</span>),</span><br><span class="line">    mDispatchEnabled(<span class="literal">false</span>), mDispatchFrozen(<span class="literal">false</span>), mInputFilterEnabled(<span class="literal">false</span>),</span><br><span class="line">    mInputTargetWaitCause(INPUT_TARGET_WAIT_CAUSE_NONE) &#123;</span><br><span class="line">    <span class="comment">// 可以看到这里创建了一个Looper</span></span><br><span class="line">    mLooper = new Looper(false);</span><br><span class="line"></span><br><span class="line">    mKeyRepeatState.lastKeyEntry = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    policy-&gt;getDispatcherConfiguration(&amp;mConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造函数中创建了一个Looper（native），注意这里是新创建了一个Looper对象，和ThreadLocal中该线程中的Looper是没有关系的；<br>再来看InputReader</p>
<h5 id="1-2）InputReader："><a href="#1-2）InputReader：" class="headerlink" title="1.2）InputReader："></a>1.2）InputReader：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> InputReader : <span class="keyword">public</span> InputReaderInterface</span><br><span class="line"><span class="keyword">class</span> InputReaderInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</span><br></pre></td></tr></table></figure>
<p><strong>构造函数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputReader.cpp **/</span></span><br><span class="line">InputReader::InputReader(<span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub, <span class="comment">// 前面提到的创建的EventHub</span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; policy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) :           <span class="comment">// 即传入进来的InputDispatcher</span></span><br><span class="line">        mContext(<span class="keyword">this</span>), mEventHub(eventHub), mPolicy(policy),   <span class="comment">// 一系列初始化</span></span><br><span class="line">        mGlobalMetaState(<span class="number">0</span>), mGeneration(<span class="number">1</span>),</span><br><span class="line">        mDisableVirtualKeysTimeout(LLONG_MIN), mNextTimeout(LLONG_MAX),</span><br><span class="line">        mConfigurationChangesToRefresh(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个QueuedInputListener对象，赋值给mQueuedListener</span></span><br><span class="line">    mQueuedListener = new QueuedInputListener(listener);</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        refreshConfigurationLocked(<span class="number">0</span>);</span><br><span class="line">        updateGlobalMetaStateLocked();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InputReader中包含了前面创建的EventHub，以及用以分发事件的InputDispatcher;在InputReader内部，将其封装成了QueuedInputListener类；</p>
<p>继续InputManager构造函数中内容，initialize进行初始化：</p>
<h4 id="2）InputManager-initialize"><a href="#2）InputManager-initialize" class="headerlink" title="2）InputManager#initialize:"></a>2）InputManager#initialize:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 进行初始化 **/</span></span><br><span class="line"><span class="keyword">void</span> InputManager::initialize() &#123;</span><br><span class="line"><span class="comment">// 创建两个Thread的实例</span></span><br><span class="line">mReaderThread = new InputReaderThread(mReader);</span><br><span class="line">    mDispatcherThread = new InputDispatcherThread(mDispatcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新创建了两个对象，这两个类都是继承Thread的，即对应地使用InputReader，以及InputDispatcher为参数创建了两个线程；<br>分别来看：</p>
<h5 id="2-1-gt-InputReaderThread："><a href="#2-1-gt-InputReaderThread：" class="headerlink" title="2.1&gt; InputReaderThread："></a>2.1&gt; InputReaderThread：</h5><p><strong>2.1.1）InputReaderThread类：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputReader.h **/</span></span><br><span class="line"><span class="comment">/** 无限循环从event hub中读取event,然后读取processes他们  */</span></span><br><span class="line"><span class="keyword">class</span> InputReaderThread : <span class="keyword">public</span> Thread &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    InputReaderThread(<span class="keyword">const</span> sp&lt;InputReaderInterface&gt;&amp; reader);</span><br><span class="line">    <span class="keyword">virtual</span> ~InputReaderThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    sp&lt;InputReaderInterface&gt; mReader;</span><br><span class="line">    <span class="comment">/** 继承Thread的子类必须实现该函数，因为这个其实是Thread的真正执行函数 **/</span></span><br><span class="line">    <span class="comment">// Derived class must implement threadLoop(). The thread starts its life</span></span><br><span class="line">    <span class="comment">// here. There are two ways of using the Thread object:</span></span><br><span class="line">    <span class="comment">// 1) loop: if threadLoop() returns true, it will be called again if</span></span><br><span class="line">    <span class="comment">//          requestExit() wasn't called.</span></span><br><span class="line">    <span class="comment">// 2) once: if threadLoop() returns false, the thread will exit upon return.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到InputReaderThread是一个Thread类，它的线程函数入口为threadLoop;</p>
<p><strong>2.1.2）InputReaderThread类构造函数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputReader.cpp **/</span></span><br><span class="line">    InputReaderThread::InputReaderThread(<span class="keyword">const</span> sp&lt;InputReaderInterface&gt;&amp; reader) :</span><br><span class="line">    Thread(<span class="comment">/*canCallJava*/</span><span class="literal">true</span>), mReader(reader) &#123;</span><br><span class="line">        <span class="comment">// 这里初始化重要变量sp&lt;InputReaderInterface&gt; mReader</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> InputReaderThread::threadLoop() &#123;</span><br><span class="line">        <span class="comment">// 调用mReader中的loopOnce函数，可以看出InputReaderInterface是该类的核心</span></span><br><span class="line">        mReader-&gt;loopOnce();</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>InputReaderThread的核心逻辑为调用InputReader的loopOnce函数；暂且停在这里，因为Thread只是创建，并未运行，等分析到具体运行代码时再作分析；</p>
<h5 id="2-2-gt-InputDispatcherThread"><a href="#2-2-gt-InputDispatcherThread" class="headerlink" title="2.2&gt;InputDispatcherThread"></a>2.2&gt;InputDispatcherThread</h5><p>/<strong> \frameworks\native\services\inputflinger\InputDispatcher.h </strong>/</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> InputDispatcherThread : <span class="keyword">public</span> Thread &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">InputDispatcherThread</span><span class="params">(<span class="keyword">const</span> sp&lt;InputDispatcherInterface&gt;&amp; dispatcher)</span></span>;</span><br><span class="line">    ~InputDispatcherThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">boolthreadLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    sp&lt;InputDispatcherInterface&gt; mDispatcher;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> InputDispatcherThread::threadLoop() &#123;</span><br><span class="line">    mDispatcher-&gt;dispatchOnce();</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 该类同样是一个Thread，其主要运行逻辑即调用InputDispatcher中的dispatchOnce函数；</p>
<p>回到InputManagerService在SystemServer进程中的创建过程知道，接下来创建WindowManagerService，然后将InputManagerService实例传递给WMS，然后调用InputManagerService.start开始工作。</p>
<h2 id="7、InputManagerService-start"><a href="#7、InputManagerService-start" class="headerlink" title="7、InputManagerService#start:"></a>7、InputManagerService#start:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\java\com\android\server\input\InputManagerService.java **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    nativeStart(mPtr);</span><br><span class="line">    <span class="comment">// Add ourself to the Watchdog monitors.</span></span><br><span class="line">    Watchdog.getInstance().addMonitor(<span class="keyword">this</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以看到start仅是对nativeStart本地方法进行封装，继续通过JNI来调用本地端的start函数；注意这里创建了WatchDog看门狗线程，并且把InputManagerService实例添加到WatchDog的监听；系统创建看门狗线程，每隔一段时间向管道中写入数据唤醒InputReader线程（后面会提到）去读取事件，看门狗WatchDog实际上也是一个线程，只不过会定时发送消息给InputReader线程读取输入事件。</p>
<h2 id="8、NativeInputManager-nativeStart"><a href="#8、NativeInputManager-nativeStart" class="headerlink" title="8、NativeInputManager#nativeStart:"></a>8、NativeInputManager#nativeStart:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ptr为创建的IMS实例的地址，这里将其强制转化成为NativeInputManager类</span></span><br><span class="line">    NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里进一步调用InputManager的star方法</span></span><br><span class="line">    <span class="keyword">status_t</span> result = im-&gt;getInputManager()-&gt;start();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Input manager could not be started."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @value sp&lt;InputManager&gt; mInputManager;</span></span><br><span class="line"><span class="keyword">inline</span> sp&lt;InputManager&gt; getInputManager() <span class="keyword">const</span> &#123; return mInputManager; &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里进一步调用了InputManager的start方法；IMS在Native层的主要实现实体其实是InputManager。</p>
<h2 id="9、InputManager-start："><a href="#9、InputManager-start：" class="headerlink" title="9、InputManager#start："></a>9、InputManager#start：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputManager.cpp **/</span></span><br><span class="line"><span class="keyword">class</span> InputManagerInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    sp&lt;InputReaderInterface&gt; mReader;</span><br><span class="line">    sp&lt;InputReaderThread&gt; mReaderThread;</span><br><span class="line"></span><br><span class="line">    sp&lt;InputDispatcherInterface&gt; mDispatcher;</span><br><span class="line">    sp&lt;InputDispatcherThread&gt; mDispatcherThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start函数</span></span><br><span class="line">    <span class="keyword">status_t</span> InputManager::start() &#123;</span><br><span class="line">        <span class="comment">// 可以看到这里会开启两个线程mDispatcherThread，与mReaderThread</span></span><br><span class="line">        <span class="comment">// 分别对应InputReaderThread，InputDispatcherThread</span></span><br><span class="line">        <span class="keyword">status_t</span> result = mDispatcherThread-&gt;run(<span class="string">"InputDispatcher"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">        ......</span><br><span class="line">        result = mReaderThread-&gt;run(<span class="string">"InputReader"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            mDispatcherThread-&gt;requestExit();</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        return OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  回到InputManager中来，来看start函数中所做的工作，在start中调用两个thread的run函数正是开启线程；由Thread的线程入口为threadLoop；前面已经提到了这两个Thread的入口函数，这里来看其中的具体工作逻辑；</p>
<h2 id="10、InputDispatcherThread-amp-InputReaderThread"><a href="#10、InputDispatcherThread-amp-InputReaderThread" class="headerlink" title="10、InputDispatcherThread&amp;InputReaderThread"></a>10、InputDispatcherThread&amp;InputReaderThread</h2><p><strong>InputDispatcherThread#threadLoop:</strong><br>由前面知InputDispatcherThread中主要通过调用InputDispatcher的dispathOnce来实现的；</p>
<h3 id="1）InputDispatcher-dispatchOnce"><a href="#1）InputDispatcher-dispatchOnce" class="headerlink" title="1）InputDispatcher::dispatchOnce:"></a>1）InputDispatcher::dispatchOnce:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mDispatcherIsAliveCondition.broadcast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在没有等待的commands事运行一个dispatch loop，这个loop之后可能enqueue commands</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有等待的commands的话，就运行所有的commands</span></span><br><span class="line">        <span class="comment">// If any commands were run then force the next poll to wake up immediately.</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始状态下是没有事件的，来到mLooper-&gt;pollOnce，了解Handler机制的native层知道，在pollOnce中调用epoll_wait对前面设置的兴趣事件进行监听，然后InputDispatchThread进入休眠等待唤醒；可想而知下面策略是InputReaderThread来对其进行唤醒；</p>
<p><strong>InputReaderThread#threadLoop:</strong><br>InputReaderThread中的主要逻辑是调用InputReader中的loopOnce函数</p>
<h3 id="1）InputReader-loopOnce"><a href="#1）InputReader-loopOnce" class="headerlink" title="1）InputReader#loopOnce :"></a>1）InputReader#loopOnce :</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** \frameworks\native\services\inputflinger\InputReader.h **/</span></span><br><span class="line">    <span class="keyword">class</span> InputReaderInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</span><br><span class="line">    <span class="keyword">class</span> InputReader : <span class="keyword">public</span> InputReaderInterface</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** \frameworks\native\services\inputflinger\InputReader.cpp **/</span></span><br><span class="line"><span class="comment">// loopOnce即事件处理函数</span></span><br><span class="line">    <span class="keyword">void</span> InputReader::loopOnce() &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 其实是通过mEventHub来获取Events的</span></span><br><span class="line">        <span class="comment">// @value sp&lt;EventHubInterface&gt; mEventHub;</span></span><br><span class="line">        <span class="keyword">size_t</span> count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// @value sp&lt;QueuedInputListener&gt; mQueuedListener;</span></span><br><span class="line">        mQueuedListener-&gt;flush();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到这里通过EventHub的getEvents来获取/dev/input中的Event事件，然后用到前面提到的封装了InputDispatcher的QueueListener来分发事件；<br>EventHub获取Events的具体流程：<a href="http://www.feeyan.cn/?p=280" target="_blank" rel="external">Android按键事件传递流程(一)</a><br>主要工作流程是注册这些监听的devices，然后调用epoll_wait使得InputReaderThread等待唤醒；<br>获取Events的过于复杂，直接跳过，来看事件的传递；当获取到Event之后，调用mQueuedListener的flush来传递消息；</p>
<h1 id="二、事件分发"><a href="#二、事件分发" class="headerlink" title="二、事件分发"></a>二、事件分发</h1><p>前面提到使用EventHub的getEvents来获取Events之后，通过mQueuedListener的flush开始消息的分发；</p>
<h2 id="1、QueueInputListener-flush"><a href="#1、QueueInputListener-flush" class="headerlink" title="1、QueueInputListener#flush:"></a>1、QueueInputListener#flush:</h2><h3 id="1）先看QueueInputListener的定义："><a href="#1）先看QueueInputListener的定义：" class="headerlink" title="1）先看QueueInputListener的定义："></a>1）先看QueueInputListener的定义：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputListener.h **/</span></span><br><span class="line"><span class="keyword">class</span> QueuedInputListener : <span class="keyword">public</span> InputListenerInterface &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~QueuedInputListener();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    QueuedInputListener(<span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; innerListener);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyConfigurationChanged</span><span class="params">(<span class="keyword">const</span> NotifyConfigurationChangedArgs* args)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyKey</span><span class="params">(<span class="keyword">const</span> NotifyKeyArgs* args)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyMotion</span><span class="params">(<span class="keyword">const</span> NotifyMotionArgs* args)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifySwitch</span><span class="params">(<span class="keyword">const</span> NotifySwitchArgs* args)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyDeviceReset</span><span class="params">(<span class="keyword">const</span> NotifyDeviceResetArgs* args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    sp&lt;InputListenerInterface&gt; mInnerListener;<span class="comment">// mInnerListner即是InputDispatcher</span></span><br><span class="line">    Vector&lt;NotifyArgs*&gt; mArgsQueue; <span class="comment">// 后面flush函数中将会用到</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在InputReader的构造函数中，传递进来的mInnerListener即为InputDispatcher；</p>
<h3 id="2）flush函数："><a href="#2）flush函数：" class="headerlink" title="2）flush函数："></a>2）flush函数：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputListener.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> QueuedInputListener::flush() &#123;</span><br><span class="line">    <span class="keyword">size_t</span> count = mArgsQueue.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        NotifyArgs* args = mArgsQueue[i];</span><br><span class="line">        <span class="comment">// 调用NotifyArgs。notify函数</span></span><br><span class="line">        args-&gt;notify(mInnerListener);</span><br><span class="line">        <span class="keyword">delete</span> args;</span><br><span class="line">    &#125;</span><br><span class="line">    mArgsQueue.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里仅是一个封装函数，最终调用InputListenerInterface的notifyKey函数</span></span><br><span class="line"><span class="keyword">void</span> NotifyKeyArgs::notify(<span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) <span class="keyword">const</span> &#123;</span><br><span class="line">    listener-&gt;notifyKey(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>前面最终调用InputListenerInterface（即InputDispatcher）的notifyKey回调函数；
总结前面的流程即InputReaderThread通过EventHub不断读取获取event信息，获得事件后，调用InputDispather的notifyKey函数来通知InputDispathcer进行处理。注意这里调用InputDispatcher的notifyKey函数依然是在InputReaderThread线程中进行的，此时InputDispathcerThread仍然是epoll_wait阻塞状态中；
</code></pre><h2 id="2、InputDispatcher-notifyKey："><a href="#2、InputDispatcher-notifyKey：" class="headerlink" title="2、InputDispatcher::notifyKey："></a>2、InputDispatcher::notifyKey：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::notifyKey(<span class="keyword">const</span> NotifyKeyArgs* args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!validateKeyEvent(args-&gt;action)) &#123; <span class="comment">// 判断event是否合法</span></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 初始化KeyEvent</span></span><br><span class="line">    KeyEvent event;</span><br><span class="line">    event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action,</span><br><span class="line">                     flags, keyCode, args-&gt;scanCode, metaState, <span class="number">0</span>,</span><br><span class="line">                     args-&gt;downTime, args-&gt;eventTime);</span><br><span class="line">    <span class="keyword">bool</span> needWake;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        mLock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldSendKeyToInputFilterLocked(args)) &#123;</span><br><span class="line">            mLock.unlock();</span><br><span class="line"></span><br><span class="line">            policyFlags |= POLICY_FLAG_FILTERED;</span><br><span class="line">            <span class="keyword">if</span> (!mPolicy-&gt;filterInputEvent(&amp;event, policyFlags)) &#123;</span><br><span class="line">                return; <span class="comment">// event was consumed by the filter</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mLock.lock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> repeatCount = <span class="number">0</span>;</span><br><span class="line">        KeyEntry* newEntry = new KeyEntry(args-&gt;eventTime,</span><br><span class="line">                                          args-&gt;deviceId, args-&gt;source, policyFlags,</span><br><span class="line">                                          args-&gt;action, flags, keyCode, args-&gt;scanCode,</span><br><span class="line">                                          metaState, repeatCount, args-&gt;downTime);</span><br><span class="line"></span><br><span class="line">        needWake = enqueueInboundEventLocked(newEntry);</span><br><span class="line">        mLock.unlock();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒InputDispatcherThread线程</span></span><br><span class="line">    <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">        mLooper-&gt;wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 该部分对传递过来的按键事件进行检查、验证，之后处理特殊按键，将原始按键信息封装成KeyEntry，再调用enqueueInboundEventLocked函数把KeyEntry添加到InboundQueue队列中，最后调用Looper对象的wake往管道中写入字符唤醒InputDispatcherThread线程（类似于Handler机制中的唤醒）；<br>先来看enqueueInboundEventLocked添加事件到InboundQueue队列中：</p>
<h3 id="1）InputDispatcher-enqueueInboundEventLocked："><a href="#1）InputDispatcher-enqueueInboundEventLocked：" class="headerlink" title="1）InputDispatcher::enqueueInboundEventLocked："></a>1）InputDispatcher::enqueueInboundEventLocked：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">bool</span> InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) &#123;</span><br><span class="line">    <span class="comment">// @value Queue&lt;EventEntry&gt; mInboundQueue;</span></span><br><span class="line">    <span class="keyword">bool</span> needWake = mInboundQueue.isEmpty();</span><br><span class="line">    <span class="comment">// 将entry入队列</span></span><br><span class="line">    mInboundQueue.enqueueAtTail(entry);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> (entry-&gt;type) &#123; <span class="comment">// 如前面所述，InputEvent分为KeyEvent和MotionEvent进行分别处理</span></span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_KEY: ......</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_MOTION: .....</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return needWake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将entry添加到InboundQueue队列尾部；然后判断是否需要唤醒，即needWake是否为true；当mInboundQueue不为空，则明显InputDispathcerThread仍处于运行状态来分发事件，因而不用进行唤醒；而当mInboundQueue为空时，测试InputDispatcherThread进行休眠状态，使用wake对其来唤醒；<br>    InputDispatcherThread之前调用Looper的poolOnce函数阻塞休眠，这里调用wake将其唤醒；因为InputDispatcherThread的threadLoop返回值为true，表示该Thread是循环执行的，故继续调用其dispatchOnce函数；</p>
<h2 id="3、InputDispatcher-dispatchOnce"><a href="#3、InputDispatcher-dispatchOnce" class="headerlink" title="3、InputDispatcher::dispatchOnce:"></a>3、InputDispatcher::dispatchOnce:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mDispatcherIsAliveCondition.broadcast();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 在没有等待的commands事运行一个dispatch loop，这个loop之后可能enqueue commands</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果有等待的commands的话，就运行所有的commands</span></span><br><span class="line">        <span class="comment">// If any commands were run then force the next poll to wake up immediately.</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来到dispatchOnceInnerLocked：</p>
<h2 id="4、InputDispathcer-dispatchOnceInnerLocked"><a href="#4、InputDispathcer-dispatchOnceInnerLocked" class="headerlink" title="4、InputDispathcer#dispatchOnceInnerLocked:"></a>4、InputDispathcer#dispatchOnceInnerLocked:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnceInnerLocked(<span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! mPendingEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInboundQueue.isEmpty()) &#123; <span class="comment">// 当前mInboundQueue已经存在元素</span></span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inbound queue has at least one entry.</span></span><br><span class="line">            mPendingEvent = mInboundQueue.dequeueAtHead();</span><br><span class="line">            traceInboundQueueLengthLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now we have an event to dispatch.</span></span><br><span class="line">    <span class="comment">// All events are eventually dequeued and processed this way, even if we intend to drop them.</span></span><br><span class="line">    ALOG_ASSERT(mPendingEvent != <span class="literal">NULL</span>);</span><br><span class="line">    .......</span><br><span class="line">    <span class="comment">// 根据mPendingEvent的Type的不同分别进行处理</span></span><br><span class="line">    <span class="keyword">switch</span> (mPendingEvent-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_CONFIGURATION_CHANGED: &#123;</span><br><span class="line">            ......</span><br><span class="line">            done = dispatchConfigurationChangedLocked(currentTime, typedEntry);</span><br><span class="line">            dropReason = DROP_REASON_NOT_DROPPED; <span class="comment">// configuration changes are never dropped</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// KeyEvent采用dispatchKeyLocked进行处理</span></span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">            KeyEntry* typedEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(mPendingEvent);</span><br><span class="line">            ......</span><br><span class="line">            done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// MotionEvent采用dispatchMotionLocked进行处理</span></span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">            ......</span><br><span class="line">            done = dispatchMotionLocked(currentTime, typedEntry,</span><br><span class="line">                                        &amp;dropReason, nextWakeupTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOG_ASSERT(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dropReason != DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">            dropInboundEventLocked(mPendingEvent, dropReason);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        releasePendingEventLocked();</span><br><span class="line">        *nextWakeupTime = LONG_LONG_MIN;  <span class="comment">// force next poll to wake up immediately</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到是事件处理机制中常用的处理模式，类似于Handler机制，这里先dequeueAtHead使得InBoundQueue事件队列中的事件出队列（FIFO）；然后根据事件的类似进行不同的处理；如TYPE_KEY类型事件采用dispatchKeyLocked；TYPE_MOTION类型事件采用dispatchMotionLocked处理<br> 下面以KeyEvent为例进行分析,下面忽略对event的具体处理细节，具体来看事件是如何传递的；</p>
<h2 id="5、InputDispatcher-dispatchKeyLocked"><a href="#5、InputDispatcher-dispatchKeyLocked" class="headerlink" title="5、InputDispatcher::dispatchKeyLocked:"></a>5、InputDispatcher::dispatchKeyLocked:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">bool</span> InputDispatcher::dispatchKeyLocked(<span class="keyword">nsecs_t</span> currentTime, KeyEntry* entry,</span><br><span class="line">        DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/** 确定事件的接收方（Target） **/</span></span><br><span class="line">    Vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">            entry, inputTargets, nextWakeupTime);</span><br><span class="line"> </span><br><span class="line">    setInjectionResultLocked(entry, injectionResult);</span><br><span class="line">    addMonitoringTargetsLocked(inputTargets);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** 将消息dispatch给Target **/</span></span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面对event的处理细节忽略，重点来看系统是如何查找event对应的接收方（Target）的，这里的InputTarget指定一个输入事件如何被分发到一个特定窗口。该结构体包含了很多特征变量：x,y坐标，输入事件通道InputChannel等；<br>这里通过findFocusedWindowTargetsLocked来确定InputTarget的，然后调用dispatchEventLocked来将Event分发给具体的Target；<br>接下来分析函数findFocusedWindowTargetsLocked；</p>
<h2 id="6、InputDispatcher-findFocusedWindowTargetsLocked"><a href="#6、InputDispatcher-findFocusedWindowTargetsLocked" class="headerlink" title="6、InputDispatcher::findFocusedWindowTargetsLocked:"></a>6、InputDispatcher::findFocusedWindowTargetsLocked:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">int32_t</span> InputDispatcher::findFocusedWindowTargetsLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> EventEntry* entry, Vector&lt;InputTarget&gt;&amp; inputTargets, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult;</span><br><span class="line">    String8 reason;</span><br><span class="line">    <span class="comment">// mFocusedWindowHandle表示当前焦点窗口的句柄</span></span><br><span class="line">    <span class="comment">// @value sp&lt;InputWindowHandle&gt; mFocusedWindowHandle;</span></span><br><span class="line">    <span class="comment">/** 当获得焦点的窗口为null时，会丢弃这一事件 **/</span></span><br><span class="line">    <span class="keyword">if</span> (mFocusedWindowHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFocusedApplicationHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有焦点窗口，但焦点窗口所在的应用程序进程存在，说明该应程序还在启动过程中，故等待nextWakeupTime后再重试</span></span><br><span class="line">            injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                    mFocusedApplicationHandle, NULL, nextWakeupTime,</span><br><span class="line">                    <span class="string">"Waiting because no window has focus but there is a "</span></span><br><span class="line">                    <span class="string">"focused application that may eventually add a window "</span></span><br><span class="line">                    <span class="string">"when it finishes starting up."</span>);</span><br><span class="line">            <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        injectionResult = INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 如果执行到这里说明当前有焦点窗口 **/</span></span><br><span class="line">    <span class="comment">// 先判断权限</span></span><br><span class="line">    <span class="keyword">if</span> (! checkInjectionPermission(mFocusedWindowHandle, entry-&gt;injectionState)) &#123;</span><br><span class="line">        injectionResult = INPUT_EVENT_INJECTION_PERMISSION_DENIED;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前焦点窗口正在处理上一个事件，采取和最上面一样的作法，等待一段时间后重试</span></span><br><span class="line">    reason = checkWindowReadyForMoreInputLocked(currentTime,</span><br><span class="line">            mFocusedWindowHandle, entry, <span class="string">"focused"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!reason.isEmpty()) &#123;</span><br><span class="line">        injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                mFocusedApplicationHandle, mFocusedWindowHandle, nextWakeupTime, reason.string());</span><br><span class="line">        <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功找到匹配的窗口，通过addWindowTargetLocked添加到inputTargets变量中</span></span><br><span class="line">    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;</span><br><span class="line">    addWindowTargetLocked(mFocusedWindowHandle,</span><br><span class="line">            InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS, BitSet32(<span class="number">0</span>),</span><br><span class="line">            inputTargets);</span><br><span class="line"></span><br><span class="line">Failed:</span><br><span class="line">Unresponsive:</span><br><span class="line">    <span class="keyword">nsecs_t</span> timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);</span><br><span class="line">    updateDispatchStatisticsLocked(currentTime, entry,</span><br><span class="line">            injectionResult, timeSpentWaitingForApplication);</span><br><span class="line">    return injectionResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面查找焦点窗口的逻辑很清晰， 当mFocusedWindowHandle为null时，如果mFocusedApplicationHandle不为null，表示当前没有焦点窗口，但焦点窗口所在的应用程序进程存在，说明该应程序还在启动过程中，故等待nextWakeupTime后再重试；如果mFocusedApplicationHandle为null，则丢弃该事件，因为没有能够接收该事件的窗口；<br>    如果mFocusedWindowHandle不为null，先判断当前窗口是否locked，如果是表示正在处理其他输入事件，这时采用和上面相同的策略，等待一段时间后，然后重试。<br>    当找到匹配的目标窗口之后，赋值给InputTarget；先来看InputTarget的定义：</p>
<h2 id="7、InputTarget"><a href="#7、InputTarget" class="headerlink" title="7、InputTarget:"></a>7、InputTarget:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.h **/</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * An input target specifies how an input event is to be dispatched to a particular window</span><br><span class="line"> * including the window's input channel, control flags, a timeout, and an X / Y offset to</span><br><span class="line"> * be added to input event coordinates to compensate for the absolute position of the</span><br><span class="line"> * window area.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> InputTarget &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; <span class="comment">// 该枚举类列举个关于目标窗口的各种属性值描述</span></span><br><span class="line">        <span class="comment">/* This flag indicates that the event is being delivered to a foreground application. */</span></span><br><span class="line">        FLAG_FOREGROUND = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">// 说明目标窗口是前台应用</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** InputDispatcher与WMS建立关联通信的地方 */</span></span><br><span class="line">    sp&lt;InputChannel&gt; inputChannel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里引出了重要的类InputChannel，InputDispatcher与WMS之间的通信，正是通过InputChannel来实现的。</p>
<p>继续前面的dispatchKeyLocked函数，接下来会调用dispatchEventLocked来传递消息；</p>
<h2 id="8、InputDispatcher-dispatchEventLocked"><a href="#8、InputDispatcher-dispatchEventLocked" class="headerlink" title="8、InputDispatcher#dispatchEventLocked"></a>8、InputDispatcher#dispatchEventLocked</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchEventLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        EventEntry* eventEntry, <span class="keyword">const</span> Vector&lt;InputTarget&gt;&amp; inputTargets) &#123;</span><br><span class="line">    ALOG_ASSERT(eventEntry-&gt;dispatchInProgress); <span class="comment">// should already have been set to true</span></span><br><span class="line"></span><br><span class="line">    pokeUserActivityLocked(eventEntry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputTargets.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> InputTarget&amp; inputTarget = inputTargets.itemAt(i);</span><br><span class="line">        <span class="comment">// 根据inputChannel（其中的fd）来获取对应的Connection</span></span><br><span class="line">        <span class="keyword">ssize_t</span> connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);</span><br><span class="line">        <span class="keyword">if</span> (connectionIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);</span><br><span class="line">            <span class="comment">// 继续向下调用</span></span><br><span class="line">            prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里根据InputChannel的fd值来获取对应的Connection对象，InputChannel以及Connection的相关知识可以西安看第三章；Connection是用来管理InputChannel的变量；然后接着调用 prepareDispatchCycleLocked；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::prepareDispatchCycleLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Split a motion event if needed.</span></span><br><span class="line">    <span class="keyword">if</span> (inputTarget-&gt;flags &amp; InputTarget::FLAG_SPLIT) &#123;</span><br><span class="line">        ALOG_ASSERT(eventEntry-&gt;type == EventEntry::TYPE_MOTION);</span><br><span class="line"></span><br><span class="line">        MotionEntry* originalMotionEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);</span><br><span class="line">        <span class="keyword">if</span> (inputTarget-&gt;pointerIds.count() != originalMotionEntry-&gt;pointerCount) &#123;</span><br><span class="line">            MotionEntry* splitMotionEntry = splitMotionEvent(</span><br><span class="line">                    originalMotionEntry, inputTarget-&gt;pointerIds);</span><br><span class="line">            <span class="keyword">if</span> (!splitMotionEntry) &#123;</span><br><span class="line">                return; <span class="comment">// split event was dropped</span></span><br><span class="line">            &#125;</span><br><span class="line">            enqueueDispatchEntriesLocked(currentTime, connection,</span><br><span class="line">                    splitMotionEntry, inputTarget);</span><br><span class="line">            splitMotionEntry-&gt;release();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not splitting.  Enqueue dispatch entries for the event as is.</span></span><br><span class="line">    enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后接着调用 enqueueDispatchEntriesLocked函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::enqueueDispatchEntriesLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget) &#123;</span><br><span class="line">    <span class="keyword">bool</span> wasEmpty = connection-&gt;outboundQueue.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue dispatch entries for the requested modes.</span></span><br><span class="line">    <span class="comment">// 将dispatch entries入队列</span></span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_OUTSIDE);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_IS);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the outbound queue was previously empty, start the dispatch cycle going.</span></span><br><span class="line">    <span class="comment">// 开始分发事件</span></span><br><span class="line">    <span class="keyword">if</span> (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        startDispatchCycleLocked(currentTime, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enqueueDispatchEntryLocked创建DispatchEntry（按键事件对象），并且把该对象作为一个发送数据包加入到outboundQueue队列中；<br>startDispatchCycleLocked取出outboundQueue队列头元素，赋给dispatchEntry，再取出事件对象KeyEntry，根据事件类型确定case语句分支，如果是按键事件，就调用connection的InputPublisher的publishKeyEvent函数发送到inputchannel中，如果publishKeyEvent返回0，表示按键事件发送成功；<br><strong>InputDispathcer#enqueueDispatchEntryLocked：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::enqueueDispatchEntryLocked(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget,</span><br><span class="line">        <span class="keyword">int32_t</span> dispatchMode) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> inputTargetFlags = inputTarget-&gt;flags;</span><br><span class="line">    <span class="comment">// 如果inputTargetFlags和dispatchMode不匹配</span></span><br><span class="line">    <span class="keyword">if</span> (!(inputTargetFlags &amp; dispatchMode)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    inputTargetFlags = (inputTargetFlags &amp; ~InputTarget::FLAG_DISPATCH_MASK) | dispatchMode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建DispatchEntry</span></span><br><span class="line">    DispatchEntry* dispatchEntry = new DispatchEntry(eventEntry, <span class="comment">// increments ref</span></span><br><span class="line">            inputTargetFlags, inputTarget-&gt;xOffset, inputTarget-&gt;yOffset,</span><br><span class="line">            inputTarget-&gt;scaleFactor);</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue the dispatch entry.</span></span><br><span class="line">    <span class="comment">// 添加到outboundQueue中</span></span><br><span class="line">    connection-&gt;outboundQueue.enqueueAtTail(dispatchEntry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9、InputDispathcer-startDispatchCycleLocked"><a href="#9、InputDispathcer-startDispatchCycleLocked" class="headerlink" title="9、InputDispathcer#startDispatchCycleLocked:"></a>9、InputDispathcer#startDispatchCycleLocked:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::startDispatchCycleLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (connection-&gt;status == Connection::STATUS_NORMAL</span><br><span class="line">            &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 取出outboundQueue的首部元素</span></span><br><span class="line">        DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head;</span><br><span class="line">        dispatchEntry-&gt;deliveryTime = currentTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Publish the event.</span></span><br><span class="line">        <span class="keyword">status_t</span> status;</span><br><span class="line">        EventEntry* eventEntry = dispatchEntry-&gt;eventEntry;</span><br><span class="line">        <span class="comment">// 根据EventEntry的Type类型进行处理</span></span><br><span class="line">        <span class="keyword">switch</span> (eventEntry-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">            KeyEntry* keyEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(eventEntry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Publish the key event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    keyEntry-&gt;deviceId, keyEntry-&gt;source,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags,</span><br><span class="line">                    keyEntry-&gt;keyCode, keyEntry-&gt;scanCode,</span><br><span class="line">                    keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime,</span><br><span class="line">                    keyEntry-&gt;eventTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">            MotionEntry* motionEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);</span><br><span class="line">            ....</span><br><span class="line">            <span class="comment">// Publish the motion event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishMotionEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    motionEntry-&gt;deviceId, motionEntry-&gt;source,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags,</span><br><span class="line">                    motionEntry-&gt;edgeFlags, motionEntry-&gt;metaState, motionEntry-&gt;buttonState,</span><br><span class="line">                    xOffset, yOffset,</span><br><span class="line">                    motionEntry-&gt;xPrecision, motionEntry-&gt;yPrecision,</span><br><span class="line">                    motionEntry-&gt;downTime, motionEntry-&gt;eventTime,</span><br><span class="line">                    motionEntry-&gt;pointerCount, motionEntry-&gt;pointerProperties,</span><br><span class="line">                    usingCoords);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Re-enqueue the event on the wait queue.</span></span><br><span class="line">        <span class="comment">// 事件处理完，将该Entry移除队列</span></span><br><span class="line">        connection-&gt;outboundQueue.dequeue(dispatchEntry);</span><br><span class="line">        traceOutboundQueueLengthLocked(connection);</span><br><span class="line">        connection-&gt;waitQueue.enqueueAtTail(dispatchEntry);</span><br><span class="line">        traceWaitQueueLengthLocked(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>典型的事件处理函数，从outBoundQueue中取出EventEntry，然后根据其Type，是TypeEvent，还是MotionEvent分别进行处理；可以看到KeyEvent使用publishKeyEvent来处理；而MotionEvent采用publishMotionEvent来处理；</p>
<h2 id="10、InputPublisher-publishMotionEvent："><a href="#10、InputPublisher-publishMotionEvent：" class="headerlink" title="10、InputPublisher#publishMotionEvent："></a>10、InputPublisher#publishMotionEvent：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\libs\input\InputTransport.cpp **/</span> </span><br><span class="line"><span class="keyword">status_t</span> InputPublisher::publishMotionEvent(</span><br><span class="line">        <span class="keyword">uint32_t</span> seq,</span><br><span class="line">        <span class="keyword">int32_t</span> deviceId,</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">const</span> PointerProperties* pointerProperties,</span><br><span class="line">        <span class="keyword">const</span> PointerCoords* pointerCoords) &#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="comment">// 一系列的赋值操作</span></span><br><span class="line">    InputMessage msg;</span><br><span class="line">    msg.header.type = InputMessage::TYPE_MOTION;</span><br><span class="line">    msg.body.motion.seq = seq;</span><br><span class="line">    msg.body.motion.deviceId = deviceId;</span><br><span class="line">    ......</span><br><span class="line">    return mChannel-&gt;sendMessage(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InputPublisher的publishMotionEvent中创建一个InputMessage，然后根据传递进来的EventEntry中的值进行赋值，然后调用InputChannel的sendMessage进行事件发送；这里的InputChannel即是下面将会提到的在ViewRootImpl中创建的Server端的InputChannel；</p>
<h2 id="11、InputChannel-sendMessage"><a href="#11、InputChannel-sendMessage" class="headerlink" title="11、InputChannel#sendMessage:"></a>11、InputChannel#sendMessage:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\libs\input\InputTransport.cpp **/</span></span><br><span class="line"><span class="keyword">status_t</span> InputChannel::sendMessage(<span class="keyword">const</span> InputMessage* msg) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> msgLength = msg-&gt;size();</span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// mFd对应socket fd;则例相当于往服务器socket中发送消息</span></span><br><span class="line">        nWrite = ::send(mFd, msg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送失败</span></span><br><span class="line">    <span class="keyword">if</span> (nWrite &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       .....</span><br><span class="line">        return -error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送成功</span></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InputChannel的sendMessage操作即是使用服务器socket send一个Message；下面将会提到socket服务端没有往inputchannel中写入数据时，客户端暂时处于阻塞状态，一旦服务端有了数据后，客户端也被唤醒了。</p>
<p>这里先来了解下这个重要类InputChannel是如何被初始化的；</p>
<h1 id="三、重要的类InputChannel"><a href="#三、重要的类InputChannel" class="headerlink" title="三、重要的类InputChannel:"></a>三、重要的类InputChannel:</h1><h2 id="1、InputChannel定义"><a href="#1、InputChannel定义" class="headerlink" title="1、InputChannel定义:"></a>1、InputChannel定义:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\include\input\InputTransport.h **/</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * An input channel consists of a local unix domain socket used to send and receive</span><br><span class="line"> * input messages across processes.  Each channel has a descriptive name for debugging purposes.</span><br><span class="line"> *</span><br><span class="line"> * Each endpoint has its own InputChannel object that specifies its file descriptor.</span><br><span class="line"> *</span><br><span class="line"> * The input channel is closed when all references to it are released.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// 上面提到InputChannel是使用unix domain socket（UDS）进行通信的，而非Binder</span></span><br><span class="line"><span class="keyword">class</span> InputChannel : <span class="keyword">public</span> RefBase &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span>~InputChannel();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    InputChannel(<span class="keyword">const</span> String8&amp; name, <span class="keyword">int</span> fd); <span class="comment">// fd类似设备描述符</span></span><br><span class="line">    <span class="comment">// 用于打开一个InputChannel对（Pair）,用以实现双向通信</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> status_t <span class="title">openInputChannelPair</span><span class="params">(<span class="keyword">const</span> String8&amp; name,</span><br><span class="line">            sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> String8 <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; returnmName; &#125;</span><br><span class="line">    <span class="function">inlineint <span class="title">getFd</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; returnmFd; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 发送接收信息</span></span><br><span class="line">    <span class="keyword">status_t</span> sendMessage(<span class="keyword">const</span> InputMessage* msg);</span><br><span class="line">    <span class="keyword">status_t</span> receiveMessage(InputMessage* msg);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Returns a new object that has a duplicate of this channel's fd. */</span></span><br><span class="line">    sp&lt;InputChannel&gt; dup() <span class="keyword">const</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    String8 mName;</span><br><span class="line">    <span class="keyword">int</span> mFd;  <span class="comment">// 重点要弄清该变量代表的含义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>InputChannel是可以双向通信的，它通过openInputChannelPair来打开一个InputChannel对，然后sendMessage或者receiveMessage来发送接收消息；<br>InputChannel是通过UDS来实现通信的，Android系统中最为常用的进程间通信时Binder通信，其次便是UDS进行单机内的进程间通信，也称IPC Socket。<br>来看InputChannel的初始化：<br>了解Window的创建过程后，之后有一个重要的对象ViewRootImpl，这里从其setView开始探索：</p>
<h2 id="2、ViewRootImpl-setView"><a href="#2、ViewRootImpl-setView" class="headerlink" title="2、ViewRootImpl#setView:"></a>2、ViewRootImpl#setView:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\core\java\android\view\ViewRootImpl.java **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        .....</span><br><span class="line">        <span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">                &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">            mInputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在Session addToDisplay时，传入mInputChannel</span></span><br><span class="line">            res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                    getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                    mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mInputChannel);</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实Java层的InputChannel只是对native层的封装，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\core\java\android\view\InputChannel.java **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InputChannel</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mPtr; <span class="comment">// used by native code</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> InputChannel[] nativeOpenInputChannelPair(String name);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeDispose</span><span class="params">(<span class="keyword">boolean</span> finalized)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeTransferTo</span><span class="params">(InputChannel other)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeReadFromParcel</span><span class="params">(Parcel parcel)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeWriteToParcel</span><span class="params">(Parcel parcel)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeDup</span><span class="params">(InputChannel target)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> String <span class="title">nativeGetName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WindowSession的具体细节参见<a href="http://blog.csdn.net/woliuyunyicai/article/details/48419135" target="_blank" rel="external">《View机制深入学习（一）》</a>，addToDisplay会继续调用WindowManagerService的addWindow函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\core\java\android\view\WindowManagerService.java **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span><br><span class="line">                     WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span><br><span class="line">                     Rect outContentInsets, Rect outStableInsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">if</span> (outInputChannel != <span class="keyword">null</span> &amp;&amp; (attrs.inputFeatures</span><br><span class="line">            &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">        String name = win.makeInputChannelName();</span><br><span class="line">        <span class="comment">// 打开InputChannel对</span></span><br><span class="line">        InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);</span><br><span class="line">        <span class="comment">// WindowState设置inputChannel变量</span></span><br><span class="line">        win.setInputChannel(inputChannels[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 设置outputChannel</span></span><br><span class="line">        inputChannels[<span class="number">1</span>].transferTo(outInputChannel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// InputManager注册InputChannel</span></span><br><span class="line">        mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在这里通过openInputChannelPair打开InputChannel，前面提到openInputChannelPair就是调用native端InputChannel的openInputChannelPair函数；<br>从这里面还可以看到，创建的InputChannel对，一个用来设置给WindowState，即供Window使用；一个设置给InputManagerService，其实是设置给native端的InputDispatcher，用以分发相应的事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\core\java\android\view\InputChannel.java **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InputChannel[] openInputChannelPair(String name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"name must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nativeOpenInputChannelPair(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> InputChannel[] nativeOpenInputChannelPair(String name);</span><br></pre></td></tr></table></figure>
<p>下面来看native端的InputChannel；</p>
<h2 id="3、InputChannel-openInputChannelPair"><a href="#3、InputChannel-openInputChannelPair" class="headerlink" title="3、InputChannel::openInputChannelPair:"></a>3、InputChannel::openInputChannelPair:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\libs\input\InputTransport.cpp **/</span></span><br><span class="line"><span class="keyword">status_t</span> InputChannel::openInputChannelPair(<span class="keyword">const</span> String8&amp; name,</span><br><span class="line">                                            sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel) &#123;</span><br><span class="line">    <span class="comment">// 建立UDS</span></span><br><span class="line">    <span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 创建一个饱含2个元素的socket数组，socketpair创建一对socket对象，SOCK_SEQPACKET表示创建连续可靠的数据包连接，如果创建成功，返回0，如果返回-1，出错。</span></span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets)) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> result = -errno;</span><br><span class="line">        outServerChannel.clear();</span><br><span class="line">        outClientChannel.clear();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置缓冲区大小</span></span><br><span class="line">    <span class="keyword">int</span> bufferSize = SOCKET_BUFFER_SIZE;</span><br><span class="line">    setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Server与Client端实例</span></span><br><span class="line">    String8 serverChannelName = name;</span><br><span class="line">    serverChannelName.append(<span class="string">" (server)"</span>);</span><br><span class="line">    outServerChannel = new InputChannel(serverChannelName, sockets[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    String8 clientChannelName = name;</span><br><span class="line">    clientChannelName.append(<span class="string">" (client)"</span>);</span><br><span class="line">    outClientChannel = new InputChannel(clientChannelName, sockets[<span class="number">1</span>]);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面创建了一对InputChannel：分别为服务端管道对象outServerChannel和客户端管道对象outClientChannel;inputChannels[0]作为服务端管道提供给InputDispatcher使用，用来发送按键事件；inputChannels[1]作为客户端管道提供给应用程序主线程使用，用来接收、消费按键事件。</p>
<p>创建好InputChannel之后，继续来看addWindow中的InputManagerService注册InputChannel的过程；前面提到，创建的inputChannels[0]即outServerChannel是供IMS中的InputDispatcher使用的，因此这里需要进行注册；</p>
<h2 id="4、InputManagerService-registerInputChannel："><a href="#4、InputManagerService-registerInputChannel：" class="headerlink" title="4、InputManagerService#registerInputChannel："></a>4、InputManagerService#registerInputChannel：</h2><p>直接来到本地端的nativeRegisterInputChannel，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span>  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeRegisterInputChannel</span><span class="params">(JNIEnv* env, jclass clazz,</span><br><span class="line">        jlong ptr, jobject inputChannelObj, jobject inputWindowHandleObj, jboolean monitor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将Java端存储的ptr指针地址转化为NativeInputManager对象</span></span><br><span class="line">    NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据传输进来的inputChannelObj获取InputChannel对象</span></span><br><span class="line">    sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env, inputChannelObj);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 根据传递进来的inputWindowHandleObj来获取InputWindowHandle对象</span></span><br><span class="line">    sp&lt;InputWindowHandle&gt; inputWindowHandle = android_server_InputWindowHandle_getHandle(env, inputWindowHandleObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用NativeInputManager的registerInputChannel进行注册</span></span><br><span class="line">    <span class="keyword">status_t</span> status = im-&gt;registerInputChannel(env, inputChannel, inputWindowHandle, monitor);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的逻辑很清晰，通过java层传递进来的inputChannelObj,inputWindowHandleObj来获取相对应的InputChannel以及InputWindowHandle对象。<br>然后将获得的实例传入到NativeInputManager中的registerInputChannel进行注册；</p>
<h2 id="5、NativeInputManager-registerInputChannel"><a href="#5、NativeInputManager-registerInputChannel" class="headerlink" title="5、NativeInputManager#registerInputChannel:"></a>5、NativeInputManager#registerInputChannel:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span>  </span><br><span class="line"><span class="keyword">status_t</span> NativeInputManager::registerInputChannel(JNIEnv* env,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="keyword">bool</span> monitor) &#123;</span><br><span class="line">    return mInputManager-&gt;getDispatcher()-&gt;registerInputChannel(</span><br><span class="line">            inputChannel, inputWindowHandle, monitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里最终是调用InputManager中的InputDispatcher的registerInputChannel进行注册，这也验证了前面所叙述的服务器端的InputChannel是供以InputDispatcher来使用的。</p>
<h2 id="6、InputDispatcher-registerInputChannel"><a href="#6、InputDispatcher-registerInputChannel" class="headerlink" title="6、InputDispatcher#registerInputChannel:"></a>6、InputDispatcher#registerInputChannel:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span>  </span><br><span class="line"><span class="keyword">status_t</span> InputDispatcher::registerInputChannel(<span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="keyword">bool</span> monitor) &#123;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getConnectionIndexLocked(inputChannel) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            return BAD_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Connection来管理对应的InputChannel以及WindowHandler</span></span><br><span class="line">        sp&lt;Connection&gt; connection = new Connection(inputChannel, inputWindowHandle, monitor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取InputChannel对应的socket Fd;</span></span><br><span class="line">        <span class="keyword">int</span> fd = inputChannel-&gt;getFd();</span><br><span class="line">        <span class="comment">// 类似于key,value形式，将connection与inputChannel的fd建立起关联</span></span><br><span class="line">        mConnectionsByFd.add(fd, connection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (monitor) &#123;</span><br><span class="line">            mMonitoringChannels.push(inputChannel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将InputChannel的fd添加到Looper中epoll的兴趣事件列表中</span></span><br><span class="line">        mLooper-&gt;addFd(fd, <span class="number">0</span>, ALOOPER_EVENT_INPUT, handleReceiveCallback, <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wake the looper because some connections have changed.</span></span><br><span class="line">    <span class="comment">// 因为connection已经发生了变化，则唤醒Looper</span></span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过InputChannel以及InputWindowHandle来创建相对应的Connection；Connetction是用来管理InputChannel的，Connection存储在 mConnectionsByFd的，它通过key-value形式进行存储，Connection的关键字使用InputChannel创建时的socket的fd来标识。</p>
<p>然后将InputChannel的fd添加到Looper的epoll兴趣列表中，注意这里的Looper对应的是InputDispatcherThread中的Looper；当server端的InputChannel有事件传递时，这时Looper会被唤醒，执行handleReceiveCallback回调；</p>
<p>服务器端InputChannel使用InputManagerService的registerInputChannel来实现，而客户端的InputChannel则通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputChannels[1].transferTo(outInputChannel);</span><br></pre></td></tr></table></figure>
<p>来实现；</p>
<h2 id="7、InputChannel-transferTo："><a href="#7、InputChannel-transferTo：" class="headerlink" title="7、InputChannel#transferTo："></a>7、InputChannel#transferTo：</h2><p>直接来到对应的native层的transferTo:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @path: \frameworks\base\core\jni\android_view_InputChannel.cpp */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_view_InputChannel_nativeTransferTo</span><span class="params">(JNIEnv* env, jobject obj,</span><br><span class="line">        jobject otherObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (android_view_InputChannel_getNativeInputChannel(env, otherObj) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>,</span><br><span class="line">                <span class="string">"Other object already has a native input channel."</span>);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建InputChannel</span></span><br><span class="line">    NativeInputChannel* nativeInputChannel =</span><br><span class="line">            android_view_InputChannel_getNativeInputChannel(env, obj);</span><br><span class="line">    android_view_InputChannel_setNativeInputChannel(env, otherObj, nativeInputChannel);</span><br><span class="line">    android_view_InputChannel_setNativeInputChannel(env, obj, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意函数中出现的几个变量对应的含义：<br>obj：本地方法所在对象的引用，对应inputChannels[1]客户端对象的引用<br>otherObj：在ViewRootImpl中创建的InputChannel对象<br>具体不再细述，就是将本地端的InputChannel[1]赋值给Java端的outInputChannel对象；</p>
<p>在前面第二章末已经提出，使用InputPublisher来将Message传递给InputChannel，这里是发送事件；而相对应的，会有一个是用来接收事件的，其类名为InputConsumer；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Retrofit源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/06/Retrofit源码解析/" class="article-date">
      <time datetime="2016-05-06T13:23:44.358Z" itemprop="datePublished">2016-05-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/06/Retrofit源码解析/">Retrofit源码解析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="一、gradle添加依赖"><a href="#一、gradle添加依赖" class="headerlink" title="一、gradle添加依赖"></a>一、gradle添加依赖</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'com.squareup.okhttp:okhttp:2.4.0'</span></span><br><span class="line">compile <span class="string">'com.squareup.okhttp:okhttp-urlconnection:2.4.0'</span></span><br><span class="line">compile <span class="string">'com.squareup.okio:okio:1.5.0'</span></span><br><span class="line">compile <span class="string">'com.google.code.gson:gson:2.2.4'</span></span><br><span class="line"></span><br><span class="line">compile <span class="string">'com.squareup.retrofit:retrofit:2.0.0-beta2'</span></span><br><span class="line">compile <span class="string">'com.squareup.retrofit:adapter-rxjava:2.0.0-beta2'</span></span><br><span class="line">compile <span class="string">'com.squareup.retrofit:converter-gson:2.0.0-beta2'</span></span><br><span class="line"></span><br><span class="line">compile <span class="string">'io.reactivex:rxandroid:1.1.0'</span></span><br><span class="line">compile <span class="string">'io.reactivex:rxjava:1.1.0'</span></span><br></pre></td></tr></table></figure>
<p><strong>盗两张网上的图：</strong><br>下面是从创建Retrofit出发，具体的使用流程；Retrofit最终的请求操作都是交由okHttp去执行的，执行的结果返回Response，再根据转换器进行解析成相对应的返回类型T;<br>Retrofit中使用了动态代理，方便了使用；通过retrofit.create返回的其实是个动态代理类，所有具体的处理逻辑交由MethodHandler进行处理；<br><img src="http://chuantu.biz/t4/9/1462541755x3738746535.png" alt="Alt text"></p>
<p>下面是Retrofit系统中的整个类图，有点像外观模式，Retrofit持有所有子系统的引用；Retrofit比较重要的是两个Factory，一个使用来生成CallAdapter的CallAdapterFactory；一个是用来转换结果的ConvertFactory；这两个都可以用户自己进行添加。<br>在自定义的Service中，每一个method对应一个MethodHandler,MethodHandler持有retrofit，前面两个Factory以及生成Request的RequestFactory；在okHttp中，Request需要自己进行定义创建，而Retrofit简化了这个操作，进行了相应的封装，使用注解的方式来定义Request的相关参数信息；注解信息的解析则在RequestFactory中完成，通过RequestFactoryParser对注解信息进行简单解析，RequestBuilderAction是解析method中参数中的注解如@Path这些产生的中间产物，最终通过RequestBuilder来具体产生一个Request，RequestBuilder中持有okHttp中的Request.Builder类的引用，其创建Request过程其实都是交给okHttp来操作的；<br>生成的Request最终封装成为一个OkHttpCall，OkHttpCall则可以看做是对okHttp中Call的通过，它的enqueue等网络请求操作都是委托个给okHttp来操作的；同时对okHttp的返回Response进行解析，使用convertFactory，将其解析为用户所期望的返回类型；<br><img src="http://chuantu.biz/t4/9/1462541864x3738746535.png" alt="Alt text"></p>
<h1 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h1><h2 id="（一）使用Call形式"><a href="#（一）使用Call形式" class="headerlink" title="（一）使用Call形式"></a>（一）使用Call形式</h2><h3 id="1、定义请求接口："><a href="#1、定义请求接口：" class="headerlink" title="1、定义请求接口："></a>1、定义请求接口：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetrofirHttpService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"&#123;user&#125;"</span>)</span><br><span class="line">    <span class="function">Call&lt;UserInfo&gt; <span class="title">getData</span><span class="params">(@Path(<span class="string">"user"</span>)</span> String user)</span>;</span><br><span class="line">&#125;</span><br><span class="line">注：UserInfo是自己定义的解析类：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">    String username;</span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、使用GET获取信息："><a href="#2、使用GET获取信息：" class="headerlink" title="2、使用GET获取信息："></a>2、使用GET获取信息：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始的CallBack方式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getUseCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加拦截器</span></span><br><span class="line">    OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    client.interceptors().add(<span class="keyword">new</span> LoggingInterceptor());</span><br><span class="line"></span><br><span class="line">    Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="string">"http://115.156.187.146/TransferServer/"</span>)</span><br><span class="line">            .client(client)                                     <span class="comment">// 添加okHttp</span></span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create()) <span class="comment">// GSON进行转换</span></span><br><span class="line">            .build();</span><br><span class="line">    RetrofirHttpService apiStores = retrofit.create(RetrofirHttpService.class);</span><br><span class="line">    Call&lt;UserInfo&gt; call = apiStores.getData(<span class="string">"ServerMain.php"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步调用</span></span><br><span class="line">    call.enqueue(<span class="keyword">new</span> Callback&lt;UserInfo&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Response&lt;UserInfo&gt; response, Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">            UserInfo data = response.body();</span><br><span class="line">            LogUtils.i(<span class="string">"Call Result:"</span> + data.m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            LogUtils.e(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="（二）使用RxJava形式"><a href="#（二）使用RxJava形式" class="headerlink" title="（二）使用RxJava形式"></a>（二）使用RxJava形式</h2><h3 id="1、定义请求接口"><a href="#1、定义请求接口" class="headerlink" title="1、定义请求接口"></a>1、定义请求接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RxHttpService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"&#123;path&#125;"</span>)</span><br><span class="line">    <span class="function">Observable&lt;UserInfo&gt; <span class="title">getData</span><span class="params">(@Path(<span class="string">"path"</span>)</span> String path)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、具体使用"><a href="#2、具体使用" class="headerlink" title="2、具体使用"></a>2、具体使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用RxJava方式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getUseRxJava</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加拦截器</span></span><br><span class="line">    OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    client.interceptors().add(<span class="keyword">new</span> LoggingInterceptor());</span><br><span class="line"></span><br><span class="line">    Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="string">"http://115.156.187.146/TransferServer/"</span>)</span><br><span class="line">            .client(client)  <span class="comment">// 添加okHttp</span></span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create()) <span class="comment">// GSON进行转换</span></span><br><span class="line">            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    RxHttpService apiStores = retrofit.create(RxHttpService.class);</span><br><span class="line">    Observable&lt;UserInfo&gt; observable = apiStores.getData(<span class="string">"ServerMain.php"</span>);</span><br><span class="line">    observable.subscribeOn(Schedulers.io())</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Observer&lt;UserInfo&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(UserInfo user)</span> </span>&#123;</span><br><span class="line">                    LogUtils.i(<span class="string">"Call Result:"</span> + user.m);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">                    LogUtils.e(error.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、源码分析："><a href="#三、源码分析：" class="headerlink" title="三、源码分析："></a>三、源码分析：</h1><h2 id="（一）先来看创建动态代理类的过程："><a href="#（一）先来看创建动态代理类的过程：" class="headerlink" title="（一）先来看创建动态代理类的过程："></a>（一）先来看创建动态代理类的过程：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RxHttpService apiStores = retrofit.create(RxHttpService.class);</span><br></pre></td></tr></table></figure>
<h3 id="1）Retrofit-create"><a href="#1）Retrofit-create" class="headerlink" title="1）Retrofit#create:"></a>1）Retrofit#create:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Create an implementation of the API defined by the &#123;<span class="doctag">@code</span> service&#125; interface. */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) <span class="comment">// Single-interface proxy creation guarded by parameter safety.</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    Utils.validateServiceInterface(service);</span><br><span class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">        eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;service&#125;,</span><br><span class="line">            <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span><br><span class="line">                        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">                    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">                        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> loadMethodHandler(method).invoke(args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准的动态代理创建过程；<br>来看代理类和委托类之间的中间InvocationHandler类的invoke函数具体执行逻辑；<br><code>loadMethodHandler(method).invoke(args);</code></p>
<h3 id="2）Retrofit-loadMethodHandler"><a href="#2）Retrofit-loadMethodHandler" class="headerlink" title="2）Retrofit#loadMethodHandler:"></a>2）Retrofit#loadMethodHandler:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MethodHandler&lt;?&gt;&gt; methodHandlerCache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">MethodHandler&lt;?&gt; loadMethodHandler(Method method) &#123;</span><br><span class="line">    MethodHandler&lt;?&gt; handler;</span><br><span class="line">    <span class="keyword">synchronized</span> (methodHandlerCache) &#123;</span><br><span class="line">        handler = methodHandlerCache.get(method);</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handler = MethodHandler.create(<span class="keyword">this</span>, method);</span><br><span class="line">            methodHandlerCache.put(method, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Retrofit维护了一个method对应的Map，这里将method都封装成一个MethodHandler类（可以当作是委托类）；调用代理类，其实就是调用MethodHandler的invoke;所以具体的实现逻辑都在MethodHanlder中；</p>
<h2 id="（二）MethodHanlder"><a href="#（二）MethodHanlder" class="headerlink" title="（二）MethodHanlder"></a>（二）MethodHanlder</h2><h3 id="1）MethodHandler类："><a href="#1）MethodHandler类：" class="headerlink" title="1）MethodHandler类："></a>1）MethodHandler类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// MethodHandler持有一个retrofit对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Retrofit retrofit;</span><br><span class="line">    <span class="comment">// 类似于Volley中的 Request ，包含了HTTP请求的Url、Header信息，MediaType、Method以及RequestAction数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestFactory requestFactory;</span><br><span class="line">    <span class="comment">// HTTP请求返回数据的类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;T&gt; callAdapter;</span><br><span class="line">    <span class="comment">// 对返回数据进行转换的类型转换器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;ResponseBody, T&gt; responseConverter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MethodHandler</span><span class="params">(Retrofit retrofit, RequestFactory requestFactory,</span><br><span class="line">                          CallAdapter&lt;T&gt; callAdapter, Converter&lt;ResponseBody, T&gt; responseConverter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">        <span class="keyword">this</span>.requestFactory = requestFactory;</span><br><span class="line">        <span class="keyword">this</span>.callAdapter = callAdapter;</span><br><span class="line">        <span class="keyword">this</span>.responseConverter = responseConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一次请求的最终具体调用的函数</span></span><br><span class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以发现最终是调用callAdapter的adapt函数</span></span><br><span class="line">        <span class="comment">// 并且将相应的请求事务封装成一个OkHttpCall类进行处理</span></span><br><span class="line">        <span class="keyword">return</span> callAdapter.adapt(<span class="keyword">new</span> OkHttpCall&lt;&gt;(retrofit, requestFactory, responseConverter, args));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用该静态类创建一个MethodHandler实例</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">static</span> MethodHandler&lt;?&gt; create(Retrofit retrofit, Method method) &#123;</span><br><span class="line">        <span class="comment">// 创建CallAdapter</span></span><br><span class="line">        CallAdapter&lt;Object&gt; callAdapter = (CallAdapter&lt;Object&gt;) createCallAdapter(method, retrofit);</span><br><span class="line">        <span class="comment">// 根据callAdapter来获取相应的返回类型</span></span><br><span class="line">        Type responseType = callAdapter.responseType();</span><br><span class="line">        <span class="comment">// 创建结果类型转换器</span></span><br><span class="line">        Converter&lt;ResponseBody, Object&gt; responseConverter =</span><br><span class="line">                (Converter&lt;ResponseBody, Object&gt;) createResponseConverter(method, retrofit, responseType);</span><br><span class="line">        <span class="comment">// 创建RequestFactory</span></span><br><span class="line">        RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodHandler&lt;&gt;(retrofit, requestFactory, callAdapter, responseConverter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建相应的CallAdapter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CallAdapter&lt;?&gt; createCallAdapter(Method method, Retrofit retrofit) &#123;</span><br><span class="line">        <span class="comment">// 这个method即为service中自定义的一个方法，一般返回都是泛型类</span></span><br><span class="line">        Type returnType = method.getGenericReturnType();</span><br><span class="line">        <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Utils.methodError(method,</span><br><span class="line">                    <span class="string">"Method return type must not include a type variable or wildcard: %s"</span>, returnType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Utils.methodError(method, <span class="string">"Service methods cannot return void."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取Method上对应的注解即（GET这些）</span></span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据注解来获取相应的Adapter</span></span><br><span class="line">            <span class="keyword">return</span> retrofit.callAdapter(returnType, annotations);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">            <span class="keyword">throw</span> Utils.methodError(e, method, <span class="string">"Unable to create call adapter for %s"</span>, returnType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后也是调用retrofit来实现的；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Converter&lt;ResponseBody, ?&gt; createResponseConverter(Method method,</span><br><span class="line">                                                                      Retrofit retrofit, Type responseType) &#123;</span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> retrofit.responseConverter(responseType, annotations);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">            <span class="keyword">throw</span> Utils.methodError(e, method, <span class="string">"Unable to create converter for %s"</span>, responseType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MethodHandler是系统为定义的每一个Service中的method中创建的一个具体执行类，通过调用其invoke函数，来执行具体的请求的逻辑；<br>它主要包含四个变量：<br>// MethodHandler持有一个retrofit对象<br><code>private final Retrofit retrofit;</code><br>// 类似于Volley中的 Request ，包含了HTTP请求的Url、Header信息，MediaType、Method以及RequestAction数组<br><code>private final RequestFactory requestFactory;</code><br>// HTTP请求返回数据的类型<br><code>private final CallAdapter&lt;T&gt; callAdapter;</code><br>// 对返回数据进行转换的类型转换器<br><code>private final Converter&lt;ResponseBody, T&gt; responseConverter;</code><br>具体来看每个变量的创建；</p>
<h3 id="2）Retrofit-callAdapter"><a href="#2）Retrofit-callAdapter" class="headerlink" title="2）Retrofit#callAdapter:"></a>2）Retrofit#callAdapter:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; adapterFactories;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;</span><br><span class="line">    <span class="keyword">return</span> nextCallAdapter(<span class="keyword">null</span>, returnType, annotations);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns the &#123;<span class="doctag">@link</span> CallAdapter&#125; for &#123;<span class="doctag">@code</span> returnType&#125; from the available &#123;<span class="doctag">@linkplain</span></span><br><span class="line"> * #callAdapterFactories() factories&#125; except &#123;<span class="doctag">@code</span> skipPast&#125;.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// 返回相关的可用的CallAdapter（除了指定跳过的skipPast）</span></span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?&gt; nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,</span><br><span class="line">                                      Annotation[] annotations) &#123;</span><br><span class="line">    checkNotNull(returnType, <span class="string">"returnType == null"</span>);</span><br><span class="line">    checkNotNull(annotations, <span class="string">"annotations == null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = adapterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历adapterFactories中所有的Factory</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">        CallAdapter&lt;?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 如果找到，则返回该Adapter</span></span><br><span class="line">        <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> adapter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果获取不到相应的CallAdapter，则抛出异常</span></span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"Could not locate call adapter for "</span>)</span><br><span class="line">            .append(returnType)</span><br><span class="line">            .append(<span class="string">". Tried:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">        builder.append(<span class="string">"\n * "</span>).append(adapterFactories.get(i).getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (skipPast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        builder.append(<span class="string">"\nSkipped:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; start; i++) &#123;</span><br><span class="line">            builder.append(<span class="string">"\n * "</span>).append(adapterFactories.get(i).getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RetroFit中有一个adapterFactories保存了所有CallAdapter.Factory,通过遍历这些factory来获取相应符合的CallAdapter;<br>先来看adapterFactories都保存了哪些Factory；从Retrofit创建开始</p>
<h2 id="（三）Retrofit的创建"><a href="#（三）Retrofit的创建" class="headerlink" title="（三）Retrofit的创建"></a>（三）Retrofit的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BaseUrl baseUrl;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; adapterFactories;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Retrofit</span><span class="params">(OkHttpClient client, BaseUrl baseUrl, List&lt;Converter.Factory&gt; converterFactories,</span><br><span class="line">                 List&lt;CallAdapter.Factory&gt; adapterFactories, Executor callbackExecutor,</span><br><span class="line">                 <span class="keyword">boolean</span> validateEagerly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">    <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">    <span class="keyword">this</span>.converterFactories = converterFactories;</span><br><span class="line">    <span class="keyword">this</span>.adapterFactories = adapterFactories;</span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    <span class="keyword">this</span>.validateEagerly = validateEagerly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Create the &#123;<span class="doctag">@link</span> Retrofit&#125; instances. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base URL required."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认使用OkhttpClient</span></span><br><span class="line">    OkHttpClient client = <span class="keyword">this</span>.client;</span><br><span class="line">    <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">        client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向adapterFactories添加了一个默认的CallAdapterFactory</span></span><br><span class="line">    <span class="comment">// 如果前面add了CallAdpterfactory（如RxJavaCallAdapterFactory），则可以看到默认的Factory会添加到用户指定的Factory后面</span></span><br><span class="line">    <span class="comment">// 则在遍历的时候，会优先遍历用户指定的Factory</span></span><br><span class="line">    List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.adapterFactories);</span><br><span class="line">    adapterFactories.add(Platform.get().defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make a defensive copy of the converters.</span></span><br><span class="line">    List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.converterFactories);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(client, baseUrl, converterFactories, adapterFactories, callbackExecutor,</span><br><span class="line">            validateEagerly);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 用户添加自定义的CallAdapterFactory</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">addCallAdapterFactory</span><span class="params">(CallAdapter.Factory factory)</span> </span>&#123;</span><br><span class="line">    adapterFactories.add(checkNotNull(factory, <span class="string">"factory == null"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续来看系统默认的CallAdapterFactory；<br>Platform.get()是根据系统不同来创建不同的运行环境，比如是再Android上还是Java上运行时由区别的，如下所示：</p>
<h3 id="1）Platform"><a href="#1）Platform" class="headerlink" title="1）Platform:"></a>1）Platform:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Platform PLATFORM = findPlatform();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Platform <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PLATFORM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Platform <span class="title">findPlatform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是Android系统</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"android.os.Build"</span>);</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Android();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是Java系统</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"java.util.Optional"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Java8();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是其他系统</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Platform();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建默认的CallAdapterFactory过程</span></span><br><span class="line">        <span class="meta">@Override</span> CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果没有指定callbackExecutor，或者为null，则新创建一个MainThreadExecutor</span></span><br><span class="line">                callbackExecutor = <span class="keyword">new</span> MainThreadExecutor();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该Executor的主要工作逻辑就是调用主线程的Looper来创建一个对应的Handler</span></span><br><span class="line">        <span class="comment">// 执行execute就是操作Handler进行post事件（Runnable）</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                handler.post(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到对应不同的系统平台，Retrofit提供了不同的Platform版本； 默认的CallAdapterFactory是个ExecutorCallAdapterFactory，它是通过callbackExecutor来创建的；<br>如果用户没有执行相应的callbackExecutor，系统或创建一个默认的MainThreadExecutor，该MainThreadExecutor的主要执行逻辑就是使用主线程的Handler来post Runnable消息；<br>然后Retrofit把ExecutorCallAdapterFactory实例添加到adapterFactories中；</p>
<h3 id="2）继续二中MethodHandler的查找CallAdapter的逻辑："><a href="#2）继续二中MethodHandler的查找CallAdapter的逻辑：" class="headerlink" title="2）继续二中MethodHandler的查找CallAdapter的逻辑："></a>2）继续二中MethodHandler的查找CallAdapter的逻辑：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CallAdapter&lt;?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallAdapterFactory</span> <span class="keyword">implements</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">    ExecutorCallAdapterFactory(Executor callbackExecutor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CallAdapter&lt;Call&lt;?&gt;&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">        <span class="comment">// 根据returnType获得具体的返回类型</span></span><br><span class="line">        <span class="keyword">if</span> (Utils.getRawType(returnType) != Call.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Type responseType = Utils.getCallResponseType(returnType);</span><br><span class="line">        <span class="comment">// 返回一个CallAdapter</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> responseType;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用adapt返回一个ExecutorCallbackCall类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;R&gt; <span class="function">Call&lt;R&gt; <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 将前面所有的逻辑串在一起，使用动态代理创建的代理类使用的InvokeHandler，调用其invoke来实现一个具体的方法调用；委托类是系统自定义创建的MethodHandler，系统根据method来创建相应的MethodHandler;MethodHandler中持有对CallAdapter的引用，CallAdapter是通过相应的CallAdpterFactory来创建的，如果加入了自定义的比如RxJava，最终会添加到Retrofit中的一个factory链表中，系统通过扫描链表来获取合适的CallAdpterFactory来创建CallAdapter;<br>如果没有自定义CallAdapterFactory，则会默认生成一个CallAdapterFactory;通过这个默认的Factory会创建一个默认的CallAdapter；<br>代理类的方法实现，是通过InvokeHandler的invoke来实现的；在系统定义的Invokehandler中进而调用MethodHandler的invoke函数，该invoke函数会继续调用CallAdpter的adapt,由上知，最终返回一个ExecutorCallbackCall类；</p>
<p>继续来看ExecutorCallbackCall类：</p>
<h3 id="3）ExecutorCallbackCall类："><a href="#3）ExecutorCallbackCall类：" class="headerlink" title="3）ExecutorCallbackCall类："></a>3）ExecutorCallbackCall类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallAdapterFactory</span> <span class="keyword">implements</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这里的Call传递进来的是一个封装好的OkHttpCall类</span></span><br><span class="line">        ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">            <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">            <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">            delegate.enqueue(<span class="keyword">new</span> ExecutorCallback&lt;&gt;(callbackExecutor, callback));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> delegate.execute();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            delegate.cancel();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"CloneDoesntCallSuperClone"</span>) <span class="comment">// Performing deep clone.</span></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;T&gt; <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallback</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Callback&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">        ExecutorCallback(Executor callbackExecutor, Callback&lt;T&gt; delegate) &#123;</span><br><span class="line">            <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">            <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(<span class="keyword">final</span> Response&lt;T&gt; response, <span class="keyword">final</span> Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">            callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    delegate.onResponse(response, retrofit);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">            callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    delegate.onFailure(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来ExecutorCallbackCall也是一个代理类，它的委托类是OkHttpCall；所以使用默认的CallAdapterFactory返回的是一个封装了OkHttpCall的一个Call类，其具体的类型是ExecutorCallbackCall；</p>
<h3 id="4）OkHttpCall"><a href="#4）OkHttpCall" class="headerlink" title="4）OkHttpCall:"></a>4）OkHttpCall:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Retrofit retrofit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestFactory requestFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;ResponseBody, T&gt; responseConverter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> com.squareup.okhttp.Call rawCall;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> executed; <span class="comment">// Guarded by this.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled;</span><br><span class="line"></span><br><span class="line">    OkHttpCall(Retrofit retrofit, RequestFactory requestFactory,</span><br><span class="line">               Converter&lt;ResponseBody, T&gt; responseConverter, Object[] args) &#123;</span><br><span class="line">        <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">        <span class="keyword">this</span>.requestFactory = requestFactory;</span><br><span class="line">        <span class="keyword">this</span>.responseConverter = responseConverter;</span><br><span class="line">        <span class="keyword">this</span>.args = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"CloneDoesntCallSuperClone"</span>)</span><br><span class="line">    <span class="comment">// We are a final type &amp; this saves clearing state.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OkHttpCall&lt;T&gt; <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OkHttpCall&lt;&gt;(retrofit, requestFactory, responseConverter, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看enqueue操作；在用户代码中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;UserInfo&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Response&lt;UserInfo&gt; response, Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">        UserInfo data = response.body();</span><br><span class="line">        LogUtils.i(<span class="string">"Call Result:"</span> + data.m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        LogUtils.e(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>由前面知这里的Call对应的是一个ExecutorCallbackCall，来看起enqueue操作：</p>
<h3 id="5）ExecutorCallbackCall-enqueue"><a href="#5）ExecutorCallbackCall-enqueue" class="headerlink" title="5）ExecutorCallbackCall#enqueue:"></a>5）ExecutorCallbackCall#enqueue:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    delegate.enqueue(<span class="keyword">new</span> ExecutorCallback&lt;&gt;(callbackExecutor, callback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delegate对应的即是OkHttpCall,先来看其enqueue传入的参数： ExecutorCallback<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallback</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callback&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    ExecutorCallback(Executor callbackExecutor, Callback&lt;T&gt; delegate) &#123;</span><br><span class="line">        <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(<span class="keyword">final</span> Response&lt;T&gt; response, <span class="keyword">final</span> Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">        callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                delegate.onResponse(response, retrofit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">        callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                delegate.onFailure(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ExecutorCallback也是一个代理类，用来封装用户定义的Callback，即类内部的变量delegate；callbackExecutor是查找Platform过程中new Android时创建的，其execute的逻辑较为简单，就是使用主线程对应的Handler来将Runnable事件post出去；可以看到，这里最终的响应都会在主线程中，而且调用用户自定义的onResponse和onFailure;<br>ExecutorCallback的主要作用就是封装Callback，将Callback的响应切换到主线程中；</p>
<h3 id="6）继续来看对应的OkHttpCall的enqueue操作："><a href="#6）继续来看对应的OkHttpCall的enqueue操作：" class="headerlink" title="6）继续来看对应的OkHttpCall的enqueue操作："></a>6）继续来看对应的OkHttpCall的enqueue操作：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意okHttp的call和retrofit的Call是不同</span></span><br><span class="line">    com.squareup.okhttp.Call rawCall;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个okhttp类型的Call</span></span><br><span class="line">        rawCall = createRawCall();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        callback.onFailure(t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果取消</span></span><br><span class="line">    <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">        rawCall.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.rawCall = rawCall;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Call中事务全部委托给okHttp来操作</span></span><br><span class="line">    <span class="comment">// 调用okHttp的enqueue，使用okHttp的Callback来封装retrofit中的Callback</span></span><br><span class="line">    rawCall.enqueue(<span class="keyword">new</span> com.squareup.okhttp.Callback() &#123;</span><br><span class="line">        <span class="comment">// 请求失败的响应</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailure</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                callback.onFailure(e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 请求成功的响应</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callSuccess</span><span class="params">(Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                callback.onResponse(response, retrofit);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Request request, IOException e)</span> </span>&#123;</span><br><span class="line">            callFailure(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(com.squareup.okhttp.Response rawResponse)</span> </span>&#123;</span><br><span class="line">            Response&lt;T&gt; response;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获得结果，并且解析结果</span></span><br><span class="line">                response = parseResponse(rawResponse);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                callFailure(e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            callSuccess(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OkHttpCall是对OkHttp里面的Call的封装，将所有的操作都委托给该Call进行操作；这里主要的是通过retrofit的call来创建一个okHttp的Call类；这里通过createRawCall来创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> com.squareup.okhttp.<span class="function">Call <span class="title">createRawCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> retrofit.client().newCall(requestFactory.create(args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里是通过okHttpClient来创建的一个Call；首先来看 requestFactory是如何根据args参数来创建一个相应的Call的；<br>先来看requestFactory，它是MethodHandler中创建传递过来的；<br><code>RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);</code></p>
<h2 id="（四）RequestFactory："><a href="#（四）RequestFactory：" class="headerlink" title="（四）RequestFactory："></a>（四）RequestFactory：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestFactoryParser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> RequestFactory <span class="title">parse</span><span class="params">(Method method, Type responseType, Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">        RequestFactoryParser parser = <span class="keyword">new</span> RequestFactoryParser(method);</span><br><span class="line">        <span class="comment">// Method对应的注解这里解析</span></span><br><span class="line">        parser.parseMethodAnnotations(responseType);</span><br><span class="line">        parser.parseParameters(retrofit);</span><br><span class="line">        <span class="comment">// 创建一个RequestFactory</span></span><br><span class="line">        <span class="keyword">return</span> parser.toRequestFactory(retrofit.baseUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RequestFactoryParser</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RequestFactoryParser主要是根据method对应的注解及返回类型进行相应解析，得出相应的解析结果，然后创建一个RequestFactory来保存所有解析后结果，供创建OkHttpCall来使用。</p>
<h3 id="lt-一-gt-parseMethodAnnotations："><a href="#lt-一-gt-parseMethodAnnotations：" class="headerlink" title="&lt;一&gt;parseMethodAnnotations："></a>&lt;一&gt;parseMethodAnnotations：</h3><h4 id="1）RequestFactoryParser-parseMethodAnnotations："><a href="#1）RequestFactoryParser-parseMethodAnnotations：" class="headerlink" title="1）RequestFactoryParser#parseMethodAnnotations："></a>1）RequestFactoryParser#parseMethodAnnotations：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是对注解进行解析的核心代码</span></span><br><span class="line"><span class="comment">// 根据注解类型的不同（即请求类型类型的不同进行相应解析）</span></span><br><span class="line"><span class="comment">// 这里也对应的retrofit的基本用法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseMethodAnnotations</span><span class="params">(Type responseType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : method.getAnnotations()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> DELETE) &#123;</span><br><span class="line">            parseHttpMethodAndPath(<span class="string">"DELETE"</span>, ((DELETE) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> GET) &#123;</span><br><span class="line">            parseHttpMethodAndPath(<span class="string">"GET"</span>, ((GET) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HEAD) &#123;</span><br><span class="line">            parseHttpMethodAndPath(<span class="string">"HEAD"</span>, ((HEAD) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (!Void.class.equals(responseType)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> methodError(method, <span class="string">"HEAD method must use Void as response type."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PATCH) &#123;</span><br><span class="line">            parseHttpMethodAndPath(<span class="string">"PATCH"</span>, ((PATCH) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> POST) &#123;</span><br><span class="line">            parseHttpMethodAndPath(<span class="string">"POST"</span>, ((POST) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PUT) &#123;</span><br><span class="line">            parseHttpMethodAndPath(<span class="string">"PUT"</span>, ((PUT) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HTTP) &#123;</span><br><span class="line">            HTTP http = (HTTP) annotation;</span><br><span class="line">            parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Headers) &#123;</span><br><span class="line">            <span class="comment">// 只有Headers是通过parseHeaders来解析的</span></span><br><span class="line">            String[] headersToParse = ((Headers) annotation).value();</span><br><span class="line">            <span class="keyword">if</span> (headersToParse.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> methodError(method, <span class="string">"@Headers annotation is empty."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            headers = parseHeaders(headersToParse);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Multipart) &#123;</span><br><span class="line">            <span class="comment">// 可以看到Multipart和FormUrlEncoded不能同时定义</span></span><br><span class="line">            <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">                <span class="keyword">throw</span> methodError(method, <span class="string">"Only one encoding annotation is allowed."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            isMultipart = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> FormUrlEncoded) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">                <span class="keyword">throw</span> methodError(method, <span class="string">"Only one encoding annotation is allowed."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            isFormEncoded = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">"HTTP method annotation is required (e.g., @GET, @POST, etc.)."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不存在实体，但是用户定义为isMultipart或者isFormEncoded类型，则会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!hasBody) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">            <span class="keyword">throw</span> methodError(method,</span><br><span class="line">                    <span class="string">"Multipart can only be specified on HTTP methods with request body (e.g., @POST)."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">            <span class="keyword">throw</span> methodError(method,</span><br><span class="line">                    <span class="string">"FormUrlEncoded can only be specified on HTTP methods with request body "</span></span><br><span class="line">                            + <span class="string">"(e.g., @POST)."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是对注解进行解析的核心代码 ，根据注解类型的不同（即请求类型类型的不同） 进行相应解析，这里也对应的retrofit的基本用法；<br>可以看到除了headers使用的parseheader进行解析外，其他都是通过 parseHttpMethodAndPath进行解析的；这里来重点分析下parseHttpMethodAndPath；</p>
<h4 id="2）parseHttpMethodAndPath："><a href="#2）parseHttpMethodAndPath：" class="headerlink" title="2）parseHttpMethodAndPath："></a>2）parseHttpMethodAndPath：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数只是先做了一个前期判断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseHttpMethodAndPath</span><span class="params">(String httpMethod, String value, <span class="keyword">boolean</span> hasBody)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">"Only one HTTP method is allowed. Found: %s and %s."</span>,</span><br><span class="line">                <span class="keyword">this</span>.httpMethod, httpMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对应"GET","POST"等</span></span><br><span class="line">    <span class="keyword">this</span>.httpMethod = httpMethod;</span><br><span class="line">    <span class="comment">// 标注有没有实体</span></span><br><span class="line">    <span class="keyword">this</span>.hasBody = hasBody;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注解值为空直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断URL是否已经有查询字符串query string</span></span><br><span class="line">    <span class="comment">// Get the relative URL path and existing query string, if present.</span></span><br><span class="line">    <span class="keyword">int</span> question = value.indexOf(<span class="string">'?'</span>);</span><br><span class="line">    <span class="keyword">if</span> (question != -<span class="number">1</span> &amp;&amp; question &lt; value.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 保证URL的查询字符串中没有&#123;...&#125;之类的字符</span></span><br><span class="line">        <span class="comment">// Ensure the query string does not have any named parameters.</span></span><br><span class="line">        String queryParams = value.substring(question + <span class="number">1</span>);</span><br><span class="line">        Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);</span><br><span class="line">        <span class="keyword">if</span> (queryParamMatcher.find()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> methodError(method, <span class="string">"URL query string \"%s\" must not have replace block. "</span></span><br><span class="line">                    + <span class="string">"For dynamic query parameters use @Query."</span>, queryParams);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体的解析继续由parsePathParameters来完成</span></span><br><span class="line">    <span class="keyword">this</span>.relativeUrl = value;</span><br><span class="line">    <span class="keyword">this</span>.relativeUrlParamNames = parsePathParameters(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数仅是做了一个简单的前期判断，将method对应的请求类型（httpMethod） ，注解值（relativeUrl），以及是否包含实体信息（hasBody）赋值给该RequestFactoryParser;<br>来看POST和GET的简单调用实例：<br><code>parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);</code><br><code>parseHttpMethodAndPath(&quot;POST&quot;, ((POST) annotation).value(), true);</code><br>继续来看解析函数parsePathParameters :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM = <span class="string">"[a-zA-Z][a-zA-Z0-9_-]*"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PARAM_URL_REGEX = Pattern.compile(<span class="string">"\\&#123;("</span> + PARAM + <span class="string">")\\&#125;"</span>);</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Gets the set of unique path parameters used in the given URI. If a parameter is used twice</span><br><span class="line"> * in the URI, it will only show up once in the set.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// 检测出路径中所有&#123;..&#125;的字段，如&#123;user&#125;等，添加到一个Set中（因此不会重复添加）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Set&lt;String&gt; <span class="title">parsePathParameters</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    Matcher m = PARAM_URL_REGEX.matcher(path);</span><br><span class="line">    Set&lt;String&gt; patterns = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">        patterns.add(m.group(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> patterns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一步仅是根据正则表达式获取URL中所有{…}类型的数据，添加到patterns这个Set中，然后返回给RequestFactoryParser，对relativeUrlParamNames进行赋值；</p>
<p>第一步解析完毕，来到第二步parseParameters：</p>
<h3 id="lt-二-gt-parseParameters："><a href="#lt-二-gt-parseParameters：" class="headerlink" title="&lt;二&gt;parseParameters："></a>&lt;二&gt;parseParameters：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseParameters</span><span class="params">(Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">    Type[] methodParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">    <span class="comment">// 获取method所有参数中的所有的注解信息</span></span><br><span class="line">    Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> gotField = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> gotPart = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> gotBody = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> gotPath = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> gotQuery = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> gotUrl = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = methodParameterAnnotationArrays.length;</span><br><span class="line">    <span class="comment">// 这里是一个重要的类</span></span><br><span class="line">    RequestBuilderAction[] requestBuilderActions = <span class="keyword">new</span> RequestBuilderAction[count];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Type methodParameterType = methodParameterTypes[i];</span><br><span class="line">        Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i];</span><br><span class="line">        <span class="keyword">if</span> (methodParameterAnnotations != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Annotation methodParameterAnnotation : methodParameterAnnotations) &#123;</span><br><span class="line">                RequestBuilderAction action = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 解析URL</span></span><br><span class="line">                <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Url) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (gotUrl) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"Multiple @Url method annotations found."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (gotPath) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Path parameters may not be used with @Url."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (gotQuery) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"A @Url parameter must not come after a @Query"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (methodParameterType != String.class) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Url must be String type."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (relativeUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Url cannot be used with @%s URL"</span>, httpMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                    gotUrl = <span class="keyword">true</span>;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Url();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Path) &#123; <span class="comment">// 解析Path注解</span></span><br><span class="line">                    <span class="keyword">if</span> (gotQuery) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"A @Path parameter must not come after a @Query."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (gotUrl) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Path parameters may not be used with @Url."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (relativeUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Path can only be used with relative url on @%s"</span>,</span><br><span class="line">                                httpMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                    gotPath = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    Path path = (Path) methodParameterAnnotation;</span><br><span class="line">                    String name = path.value();</span><br><span class="line">                    validatePathName(i, name);</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Path(name, path.encoded());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Query) &#123; <span class="comment">// 解析Query注解</span></span><br><span class="line">                    Query query = (Query) methodParameterAnnotation;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Query(query.value(), query.encoded());</span><br><span class="line">                    gotQuery = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> QueryMap) &#123; <span class="comment">// 解析QueryMap注解</span></span><br><span class="line">                    <span class="keyword">if</span> (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@QueryMap parameter type must be Map."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    QueryMap queryMap = (QueryMap) methodParameterAnnotation;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.QueryMap(queryMap.encoded());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Header) &#123; <span class="comment">// 解析header注解</span></span><br><span class="line">                    Header header = (Header) methodParameterAnnotation;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Header(header.value());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Field) &#123; <span class="comment">// 解析Field注解</span></span><br><span class="line">                    <span class="keyword">if</span> (!isFormEncoded) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Field parameters can only be used with form encoding."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Field field = (Field) methodParameterAnnotation;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Field(field.value(), field.encoded());</span><br><span class="line">                    gotField = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> FieldMap) &#123; <span class="comment">// 解析FieldMap</span></span><br><span class="line">                    <span class="keyword">if</span> (!isFormEncoded) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@FieldMap parameters can only be used with form encoding."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@FieldMap parameter type must be Map."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    FieldMap fieldMap = (FieldMap) methodParameterAnnotation;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.FieldMap(fieldMap.encoded());</span><br><span class="line">                    gotField = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Part) &#123; <span class="comment">// 解析Part</span></span><br><span class="line">                    <span class="keyword">if</span> (!isMultipart) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Part parameters can only be used with multipart encoding."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Part part = (Part) methodParameterAnnotation;</span><br><span class="line">                    com.squareup.okhttp.Headers headers = com.squareup.okhttp.Headers.of(</span><br><span class="line">                            <span class="string">"Content-Disposition"</span>, <span class="string">"form-data; name=\""</span> + part.value() + <span class="string">"\""</span>,</span><br><span class="line">                            <span class="string">"Content-Transfer-Encoding"</span>, part.encoding());</span><br><span class="line">                    Converter&lt;?, RequestBody&gt; converter;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        converter =</span><br><span class="line">                                retrofit.requestConverter(methodParameterType, methodParameterAnnotations);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">                        <span class="keyword">throw</span> parameterError(e, i, <span class="string">"Unable to create @Part converter for %s"</span>,</span><br><span class="line">                                methodParameterType);</span><br><span class="line">                    &#125;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Part&lt;&gt;(headers, converter);</span><br><span class="line">                    gotPart = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> PartMap) &#123; <span class="comment">//解析PartMap</span></span><br><span class="line">                    <span class="keyword">if</span> (!isMultipart) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i,</span><br><span class="line">                                <span class="string">"@PartMap parameters can only be used with multipart encoding."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@PartMap parameter type must be Map."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    PartMap partMap = (PartMap) methodParameterAnnotation;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.PartMap(retrofit, partMap.encoding(),</span><br><span class="line">                            methodParameterAnnotations);</span><br><span class="line">                    gotPart = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Body) &#123; <span class="comment">// 解析Body</span></span><br><span class="line">                    <span class="keyword">if</span> (isFormEncoded || isMultipart) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i,</span><br><span class="line">                                <span class="string">"@Body parameters cannot be used with form or multi-part encoding."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (gotBody) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"Multiple @Body method annotations found."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Converter&lt;?, RequestBody&gt; converter;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        converter =</span><br><span class="line">                                retrofit.requestConverter(methodParameterType, methodParameterAnnotations);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">                        <span class="keyword">throw</span> parameterError(e, i, <span class="string">"Unable to create @Body converter for %s"</span>,</span><br><span class="line">                                methodParameterType);</span><br><span class="line">                    &#125;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Body&lt;&gt;(converter);</span><br><span class="line">                    gotBody = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (action != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (requestBuilderActions[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"Multiple Retrofit annotations found, only one allowed."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    requestBuilderActions[i] = action;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (requestBuilderActions[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> parameterError(i, <span class="string">"No Retrofit annotation found."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (relativeUrl == <span class="keyword">null</span> &amp;&amp; !gotUrl) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">"Missing either @%s URL or @Url parameter."</span>, httpMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">"Non-body HTTP method cannot contain @Body."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">"Form-encoded method must contain at least one @Field."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">"Multipart method must contain at least one @Part."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.requestBuilderActions = requestBuilderActions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是根据method里面对应的参数中的注解比如<code>@(Url,Path,Query,QueryMap,Header,Field,FieldMap,Part,PartMap,Body)</code>，它们的解析操作都是通过创建一个RequestBuilderAction类进行相应的解析，比如@Path，解析则调用的是创建一个RequestBuilderAction.Path，Path类是RequestBuilderAction的静态内部类，继承了RequestBuilderAction；最后所有参数中的注解对应一个RequestBuilderAction数组requestBuilderActions，把这个数组赋值给RequestFactoryParser;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBuilderAction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(RequestBuilder builder, Object value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RequestBuilderAction是个抽象类，它内部有一个perform的抽象方法；还有一些具体的内部类继承该方法，根据不同的注解，来创建不同的静态内部类，这些静态内部类都继承了RequestBuilderAction，并且重写了自己的perform方法；<br>如Path:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Path</span> <span class="keyword">extends</span> <span class="title">RequestBuilderAction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> encoded;</span><br><span class="line"></span><br><span class="line">  Path(String name, <span class="keyword">boolean</span> encoded) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = checkNotNull(name, <span class="string">"name == null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.encoded = encoded;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">perform</span><span class="params">(RequestBuilder builder, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">          <span class="string">"Path parameter \""</span> + name + <span class="string">"\" value must not be null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.addPathParam(name, value.toString(), encoded);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这里涉及到一个 RequestBuilder的概念，等到具体使用的时候再进行分析；</p>
<h3 id="lt-三-gt-parser-toRequestFactory-retrofit-baseUrl"><a href="#lt-三-gt-parser-toRequestFactory-retrofit-baseUrl" class="headerlink" title="&lt;三&gt;parser.toRequestFactory(retrofit.baseUrl())"></a>&lt;三&gt;parser.toRequestFactory(retrofit.baseUrl())</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RequestFactory <span class="title">toRequestFactory</span><span class="params">(BaseUrl baseUrl)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RequestFactory(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody,</span><br><span class="line">      isFormEncoded, isMultipart, requestBuilderActions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一步将所有解析完的信息封装成一个 RequestFactory；<br>则继续来看第（三）步中okHttp创建Call是传递进来的参数：requestFactory.create(args)</p>
<h4 id="1）RequestFactory-create"><a href="#1）RequestFactory-create" class="headerlink" title="1）RequestFactory#create:"></a>1）RequestFactory#create:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BaseUrl baseUrl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String relativeUrl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Headers headers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MediaType contentType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> hasBody;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isFormEncoded;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isMultipart;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestBuilderAction[] requestBuilderActions;</span><br><span class="line"></span><br><span class="line">    RequestFactory(String method, BaseUrl baseUrl, String relativeUrl, Headers headers,</span><br><span class="line">                   MediaType contentType, <span class="keyword">boolean</span> hasBody, <span class="keyword">boolean</span> isFormEncoded, <span class="keyword">boolean</span> isMultipart,</span><br><span class="line">                   RequestBuilderAction[] requestBuilderActions) &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">        <span class="keyword">this</span>.relativeUrl = relativeUrl;</span><br><span class="line">        <span class="keyword">this</span>.headers = headers;</span><br><span class="line">        <span class="keyword">this</span>.contentType = contentType;</span><br><span class="line">        <span class="keyword">this</span>.hasBody = hasBody;</span><br><span class="line">        <span class="keyword">this</span>.isFormEncoded = isFormEncoded;</span><br><span class="line">        <span class="keyword">this</span>.isMultipart = isMultipart;</span><br><span class="line">        <span class="keyword">this</span>.requestBuilderActions = requestBuilderActions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Request <span class="title">create</span><span class="params">(Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个RequestBuilder，它是真正创建Request的类</span></span><br><span class="line">        RequestBuilder requestBuilder =</span><br><span class="line">                <span class="keyword">new</span> RequestBuilder(method, baseUrl.url(), relativeUrl, headers, contentType, hasBody,</span><br><span class="line">                        isFormEncoded, isMultipart);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 前面解析method参数中的注解获取到的RequestBuilderAction</span></span><br><span class="line">            RequestBuilderAction[] actions = requestBuilderActions;</span><br><span class="line">            <span class="keyword">if</span> (actions.length != args.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Argument count ("</span></span><br><span class="line">                        + args.length</span><br><span class="line">                        + <span class="string">") doesn't match action count ("</span></span><br><span class="line">                        + actions.length</span><br><span class="line">                        + <span class="string">")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = args.length; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="comment">// 这里调用RequestBuilderAction的perform进行创建</span></span><br><span class="line">                actions[i].perform(requestBuilder, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建造者模型，返回一个build</span></span><br><span class="line">        <span class="keyword">return</span> requestBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到RequestFactory在create时创建了一个RequestBuilder，它是一个典型的Builder模式，也就是类似OkHttp的Request Buidler模式，由用户调用builder自定义来转化为通过注解方式进行定义，而Retrofit通过解析注解信息，分析用户行为，然后将解析信息添加到requestBuidler中来自行构造Request；它暴漏出注解定义的方式，而将具体的Request Builder细节隐藏了。<br>这里终点来看RequestBuidler，前面分析method参数类型获得的RequestBuilderAction，其具体的perform也是通过RequestBuilderAction来实现的；</p>
<h3 id="lt-四-gt-RequestBuilder："><a href="#lt-四-gt-RequestBuilder：" class="headerlink" title="&lt;四&gt;RequestBuilder："></a>&lt;四&gt;RequestBuilder：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBuilder</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注意这里的Request对应的是okHttp的request</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Request.Builder requestBuilder;</span><br><span class="line">    RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,</span><br><span class="line">                   MediaType contentType, <span class="keyword">boolean</span> hasBody, <span class="keyword">boolean</span> isFormEncoded, <span class="keyword">boolean</span> isMultipart) &#123;</span><br><span class="line"><span class="keyword">this</span>.method = method;</span><br><span class="line"><span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line"><span class="keyword">this</span>.relativeUrl = relativeUrl;</span><br><span class="line"><span class="keyword">this</span>.requestBuilder = <span class="keyword">new</span> Request.Builder();</span><br><span class="line"><span class="keyword">this</span>.contentType = contentType;</span><br><span class="line"><span class="keyword">this</span>.hasBody = hasBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (headers != <span class="keyword">null</span>) &#123;</span><br><span class="line">requestBuilder.headers(headers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line"><span class="comment">// Will be set to 'body' in 'build'.</span></span><br><span class="line">formEncodingBuilder = <span class="keyword">new</span> FormEncodingBuilder();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line"><span class="comment">// Will be set to 'body' in 'build'.</span></span><br><span class="line">multipartBuilder = <span class="keyword">new</span> MultipartBuilder();</span><br><span class="line">            multipartBuilder.type(MultipartBuilder.FORM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Retrofit默认是通过okHttp来实现的，RequestBuidler其实将所有Request创建的任务交给真正的类Okhttp中的Request.Builder进行构造器request；相应的FormEncodingBuilder以及MultipartBuilder也都是okHttp内部的；<br>RequestBuilderAction中的perform也都是通过RequestBuidler的函数来实现的，比如@Path:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Path</span> <span class="keyword">extends</span> <span class="title">RequestBuilderAction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> encoded;</span><br><span class="line"></span><br><span class="line">    Path(String name, <span class="keyword">boolean</span> encoded) &#123;</span><br><span class="line">       <span class="keyword">this</span>.name = checkNotNull(name, <span class="string">"name == null"</span>);</span><br><span class="line">       <span class="keyword">this</span>.encoded = encoded;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">perform</span><span class="params">(RequestBuilder builder, Object value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">       <span class="string">"Path parameter \""</span> + name + <span class="string">"\" value must not be null."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       builder.addPathParam(name, value.toString(), encoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到调用的RequestBuilder的addPathParam方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addPathParam</span><span class="params">(String name, String value, <span class="keyword">boolean</span> encoded)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (relativeUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// The relative URL is cleared when the first query parameter is set.</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">     &#125;</span><br><span class="line">    relativeUrl = relativeUrl.replace(<span class="string">"&#123;"</span> + name + <span class="string">"&#125;"</span>, canonicalize(value, encoded));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再来看RequestFactory#create的返回值，即RequestBuilder.builder:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Request <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  HttpUrl url;</span><br><span class="line">  HttpUrl.Builder urlBuilder = <span class="keyword">this</span>.urlBuilder;</span><br><span class="line">  <span class="keyword">if</span> (urlBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    url = urlBuilder.build();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No query parameters triggered builder creation, just combine the relative URL and base URL.</span></span><br><span class="line">    url = baseUrl.resolve(relativeUrl);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RequestBody body = <span class="keyword">this</span>.body;</span><br><span class="line">  <span class="keyword">if</span> (body == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Try to pull from one of the builders.</span></span><br><span class="line">    <span class="keyword">if</span> (formEncodingBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      body = formEncodingBuilder.build();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (multipartBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      body = multipartBuilder.build();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasBody) &#123;</span><br><span class="line">      <span class="comment">// Body is absent, make an empty body.</span></span><br><span class="line">      body = RequestBody.create(<span class="keyword">null</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MediaType contentType = <span class="keyword">this</span>.contentType;</span><br><span class="line">  <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">      body = <span class="keyword">new</span> ContentTypeOverridingRequestBody(body, contentType);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      requestBuilder.addHeader(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> requestBuilder</span><br><span class="line">      .url(url)</span><br><span class="line">      .method(method, body)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可想而知最后调用的是okHttp总的builder来具体创建一个Request,具体的创建细节见okHttp源码解析；<br>因此返回的是一个okHttp中的Request；来看具体的创建：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">retrofit.client().newCall(requestFactory.create(args));</span><br><span class="line">OkHttpClient#newCall:</span><br><span class="line">/**</span><br><span class="line"> * Prepares the &#123;@code request&#125; to be executed at some point in the future.</span><br><span class="line"> */</span><br><span class="line">public Call newCall(Request request) &#123;</span><br><span class="line">    return new Call(this, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将Request封装成一个Call；因此，接下来的所有网络请求操作都交由okHttp进行处理；</p>
<h3 id="（五）这里来看具体的对返回结果的转换："><a href="#（五）这里来看具体的对返回结果的转换：" class="headerlink" title="（五）这里来看具体的对返回结果的转换："></a>（五）这里来看具体的对返回结果的转换：</h3><p>在调用OkHttpCall的enqueue时，可以看到Callback中会对结果Response(okHttp中的)进行进一步解析，然后将解析后的结果通过Retrofit中定义的callback进行返回，返回的结果为Response<t>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">rawCall.enqueue(<span class="keyword">new</span> com.squareup.okhttp.Callback() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailure</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                callback.onFailure(e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callSuccess</span><span class="params">(Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            callback.onResponse(response, retrofit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Request request, IOException e)</span> </span>&#123;</span><br><span class="line">        callFailure(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(com.squareup.okhttp.Response rawResponse)</span> </span>&#123;</span><br><span class="line">        Response&lt;T&gt; response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response = parseResponse(rawResponse);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            callFailure(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        callSuccess(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></t></p>
<p>可以看到主要解析过程则在于parseResponse中；</p>
<h4 id="1）OkHttpCall-parseResponse："><a href="#1）OkHttpCall-parseResponse：" class="headerlink" title="1）OkHttpCall#parseResponse："></a>1）OkHttpCall#parseResponse：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(com.squareup.okhttp.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ResponseBody rawBody = rawResponse.body();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove the body's source (the only stateful object) so we can pass the response along.</span></span><br><span class="line">    rawResponse = rawResponse.newBuilder()</span><br><span class="line">            .body(<span class="keyword">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> code = rawResponse.code();</span><br><span class="line">    <span class="comment">// 如果请求失败</span></span><br><span class="line">    <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">            ResponseBody bufferedBody = Utils.readBodyToBytesIfNecessary(rawBody);</span><br><span class="line">            <span class="keyword">return</span> Response.error(bufferedBody, rawResponse);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeQuietly(rawBody);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有数据返回情况，则不用进行解析</span></span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Response.success(<span class="keyword">null</span>, rawResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ExceptionCatchingRequestBody是对okHttp的RequestBody类的一个封装</span></span><br><span class="line">    ExceptionCatchingRequestBody catchingBody = <span class="keyword">new</span> ExceptionCatchingRequestBody(rawBody);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 利用变换器进行转换</span></span><br><span class="line">        T body = responseConverter.convert(catchingBody);</span><br><span class="line">        <span class="comment">// 将转换后的实体结果和原Response封装成一个Response&lt;T&gt;</span></span><br><span class="line">        <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></span><br><span class="line">        <span class="comment">// a runtime exception.</span></span><br><span class="line">        catchingBody.throwIfCaught();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当请求发生错误，获取204情况没有实体返回时，自然不用对实体进行转化；而对于实体的转换是通过最初定义的转换器来（这里用的是GSON）来进行covert的；然后将转换后的结果同原始okHttp返回的Response封装成一个Response<t>进行返回；<br>先来看传递进来的转换器：</t></p>
<h4 id="2）ConverterFactory："><a href="#2）ConverterFactory：" class="headerlink" title="2）ConverterFactory："></a>2）ConverterFactory：</h4><p>是通过在build retrofit的时候添加的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">        .baseUrl("http://115.156.187.146/TransferServer/")</span><br><span class="line">        .client(client)                                     // 添加okHttp</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create()) // GSON进行转换</span><br><span class="line">        .build();</span><br><span class="line">Retrofit#ConverterFactory:</span><br><span class="line">/** Add converter factory for serialization and deserialization of objects. */</span><br><span class="line">public Builder addConverterFactory(Converter.Factory converterFactory) &#123;</span><br><span class="line">    converterFactories.add(checkNotNull(converterFactory, "converterFactory == null"));</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由前面的分析知，在创建MethodHandler时，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MethodHandler&lt;?&gt; create(Retrofit retrofit, Method method) &#123;</span><br><span class="line">    CallAdapter&lt;Object&gt; callAdapter = (CallAdapter&lt;Object&gt;) createCallAdapter(method, retrofit);</span><br><span class="line">    Type responseType = callAdapter.responseType();</span><br><span class="line">    <span class="comment">// 创建转换器</span></span><br><span class="line">    Converter&lt;ResponseBody, Object&gt; responseConverter =</span><br><span class="line">            (Converter&lt;ResponseBody, Object&gt;) createResponseConverter(method, retrofit, responseType);</span><br><span class="line">    RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MethodHandler&lt;&gt;(retrofit, requestFactory, callAdapter, responseConverter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Converter&lt;ResponseBody, ?&gt; createResponseConverter(Method method,</span><br><span class="line">                                                                  Retrofit retrofit, Type responseType) &#123;</span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> retrofit.responseConverter(responseType, annotations);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">        <span class="keyword">throw</span> Utils.methodError(e, method, <span class="string">"Unable to create converter for %s"</span>, responseType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进而根据返回数据类型调用Retrofit.responseConverter来创建；下面基本上和CallAdapterFactory基本相同的流程；通过遍历converterFactories链表进行获取相应的解析Converter:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">responseConverter</span><span class="params">(Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">    checkNotNull(type, <span class="string">"type == null"</span>);</span><br><span class="line">    checkNotNull(annotations, <span class="string">"annotations == null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 重点看这个解析函数</span></span><br><span class="line">        Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">                converterFactories.get(i).fromResponseBody(type, annotations);</span><br><span class="line">        <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            <span class="keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"Could not locate ResponseBody converter for "</span>)</span><br><span class="line">            .append(type)</span><br><span class="line">            .append(<span class="string">". Tried:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (Converter.Factory converterFactory : converterFactories) &#123;</span><br><span class="line">        builder.append(<span class="string">"\n * "</span>).append(converterFactory.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要的逻辑在：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重点看这个解析函数</span></span><br><span class="line">        Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">                converterFactories.get(i).fromResponseBody(type, annotations);</span><br><span class="line">这里的converterFactories.get(i)即是通过GsonConverterFactory.create()创建的GSON转换器；来看其具体细节；</span><br></pre></td></tr></table></figure></p>
<h4 id="3）GsonConverterFactory："><a href="#3）GsonConverterFactory：" class="headerlink" title="3）GsonConverterFactory："></a>3）GsonConverterFactory：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonConverterFactory</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Create an instance using a default &#123;<span class="doctag">@link</span> Gson&#125; instance for conversion. Encoding to JSON and</span><br><span class="line">   * decoding from JSON (when no charset is specified by a header) will use UTF-8.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GsonConverterFactory <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> Gson());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Create an instance using &#123;<span class="doctag">@code</span> gson&#125; for conversion. Encoding to JSON and</span><br><span class="line">   * decoding from JSON (when no charset is specified by a header) will use UTF-8.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GsonConverterFactory <span class="title">create</span><span class="params">(Gson gson)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GsonConverterFactory(gson);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">GsonConverterFactory</span><span class="params">(Gson gson)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (gson == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"gson == null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.gson = gson;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; fromResponseBody(Type type, Annotation[] annotations) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GsonResponseBodyConverter&lt;&gt;(gson, type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Converter&lt;?, RequestBody&gt; toRequestBody(Type type, Annotation[] annotations) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GsonRequestBodyConverter&lt;&gt;(gson, type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这个Factory很简单，就是持有了一个GSON实例对象；<br>上面调用了fromResponseBody，这里根据returntype来创建一个GsonRequestBodyConverter：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonRequestBodyConverter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">T</span>, <span class="title">RequestBody</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE = MediaType.parse(<span class="string">"application/json; charset=UTF-8"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset UTF_8 = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line"></span><br><span class="line">    GsonRequestBodyConverter(Gson gson, Type type) &#123;</span><br><span class="line">        <span class="keyword">this</span>.gson = gson;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestBody <span class="title">convert</span><span class="params">(T value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Buffer buffer = <span class="keyword">new</span> Buffer();</span><br><span class="line">        Writer writer = <span class="keyword">new</span> OutputStreamWriter(buffer.outputStream(), UTF_8);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            gson.toJson(value, type, writer);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e); <span class="comment">// Writing to Buffer does no I/O.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RequestBody.create(MEDIA_TYPE, buffer.readByteString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其转换函数convert逻辑也较为简单，将工作交给gson就可以了；所以Retrofit的解析工作在okHttp的Call返回结果时，在其okHttp的Callback中进行解析，解析过程也较为简单，通过获取返回类型Returntype，然后使用gson进行解析即可；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ArrayMapy、SparseArray源码学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/06/ArrayMapy、SparseArray源码学习/" class="article-date">
      <time datetime="2016-05-06T08:39:33.378Z" itemprop="datePublished">2016-05-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/06/ArrayMapy、SparseArray源码学习/">ArrayMapy、SparseArray源码学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>ArrayMap和SparseArray是Android中提供用来替代HashMap实现内存优化的集合类，来具体看下其源码实现：</p>
<h1 id="ArrayMap简单分析"><a href="#ArrayMap简单分析" class="headerlink" title="ArrayMap简单分析"></a>ArrayMap简单分析</h1><h2 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a>存储原理</h2><p>HashMap是使用一个table数组来存储；发生冲突时采用链地址法以链表或者红黑树的形式进行存储；<br>而ArrayMap使用的是两个数组，mHash数组用来存储hash值（顺序存储）；mArray在对应位置存储（比如mHash存储位置为index），偶数位（index&lt;&lt;1）存储key;奇数位(index&lt;&lt;+1)存储value;<br>发生冲突时，mHash把相同的hash组放在一起存储（因为mHash是按照hash值大小顺序来存储的）；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] mHashes;</span><br><span class="line">    Object[] mArray;</span><br><span class="line">    <span class="keyword">int</span> mSize;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayMap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">            mHashes = EmptyArray.INT;</span><br><span class="line">            mArray = EmptyArray.OBJECT;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            allocArrays(capacity);</span><br><span class="line">        &#125;</span><br><span class="line">        mSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加元素put操作"><a href="#添加元素put操作" class="headerlink" title="添加元素put操作"></a>添加元素put操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        hash = <span class="number">0</span>;</span><br><span class="line">        index = indexOfNull();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 根据hash值查找key对应的位置</span></span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = indexOf(key, hash);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 大于0表示该元素已经存在，这里直接覆盖即可</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        index = (index&lt;&lt;<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> V old = (V)mArray[index];</span><br><span class="line">        mArray[index] = value;</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;0表示不存在，取反得到插入位置</span></span><br><span class="line">    index = ~index;</span><br><span class="line">    <span class="comment">// 插入前判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (mSize &gt;= mHashes.length) &#123;</span><br><span class="line">        <span class="comment">// 重新分配空间大小</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = mSize &gt;= (BASE_SIZE*<span class="number">2</span>) ? (mSize+(mSize&gt;&gt;<span class="number">1</span>))</span><br><span class="line">                : (mSize &gt;= BASE_SIZE ? (BASE_SIZE*<span class="number">2</span>) : BASE_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] ohashes = mHashes;</span><br><span class="line">        <span class="keyword">final</span> Object[] oarray = mArray;</span><br><span class="line">        <span class="comment">// 分配数组空间</span></span><br><span class="line">        allocArrays(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原始数组拷贝到新分配的数组中</span></span><br><span class="line">        <span class="keyword">if</span> (mHashes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"put: copy 0-"</span> + mSize + <span class="string">" to 0"</span>);</span><br><span class="line">            System.arraycopy(ohashes, <span class="number">0</span>, mHashes, <span class="number">0</span>, ohashes.length);</span><br><span class="line">            System.arraycopy(oarray, <span class="number">0</span>, mArray, <span class="number">0</span>, oarray.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的空间</span></span><br><span class="line">        freeArrays(ohashes, oarray, mSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单的插入操作</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; mSize) &#123;</span><br><span class="line">        System.arraycopy(mHashes, index, mHashes, index + <span class="number">1</span>, mSize - index);</span><br><span class="line">        System.arraycopy(mArray, index &lt;&lt; <span class="number">1</span>, mArray, (index + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>, (mSize - index) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应位置进行赋值</span></span><br><span class="line">    mHashes[index] = hash;</span><br><span class="line">    mArray[index&lt;&lt;<span class="number">1</span>] = key;</span><br><span class="line">    mArray[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] = value;</span><br><span class="line">    mSize++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>查找插入位置：</strong><br>HashMap是根据key的hashcode，然后将其高低十六位相与hash&amp;（hash&gt;&gt;&gt;16）,进而与table数组的长度length相与（hash&amp;(length-1)）来找到对应的table数组插入位置；<br>而ArrayMap是通过ContainerHelpers的binarySearch即二分查找的方法，根据key的hash值来查找mHash数组（顺序数组），找到对应的index；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分法查找对应位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object key, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = mSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Important fast case: if nothing is in here, nothing to look for.</span></span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ~<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找，查找结果</span></span><br><span class="line">    <span class="keyword">int</span> index = ContainerHelpers.binarySearch(mHashes, N, hash);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the hash code wasn't found, then we have no entry for this key.</span></span><br><span class="line">    <span class="comment">// &lt;0表示没有查找到</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决冲突，双向进行查找一次相同的hash值，比较key值是否匹配</span></span><br><span class="line">    <span class="comment">// If the key at the returned index matches, that's what we want.</span></span><br><span class="line">    <span class="keyword">if</span> (key.equals(mArray[index&lt;&lt;<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search for a matching key after the index.</span></span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">for</span> (end = index + <span class="number">1</span>; end &lt; N &amp;&amp; mHashes[end] == hash; end++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.equals(mArray[end &lt;&lt; <span class="number">1</span>])) <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search for a matching key before the index.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; mHashes[i] == hash; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.equals(mArray[i &lt;&lt; <span class="number">1</span>])) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Key not found -- return negative value indicating where a</span></span><br><span class="line">    <span class="comment">// new entry for this key should go.  We use the end of the</span></span><br><span class="line">    <span class="comment">// hash chain to reduce the number of array entries that will</span></span><br><span class="line">    <span class="comment">// need to be copied when inserting.</span></span><br><span class="line">    <span class="keyword">return</span> ~end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>简单的二分查找：</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is Arrays.binarySearch(), but doesn't do any argument validation.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> size, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> midVal = array[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (midVal &lt; value) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; value) &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;  <span class="comment">// value found</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ~lo;  <span class="comment">// value not present</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>冲突解决：</strong><br>HashMap是采用遍历链表来实现；而ArrayMap的mHash表中可能存在多个相同的hash值，即冲突；它通过二分查找，找到相应的一个相等值，然后以这个值为中心，分别向前向后遍历，比较对应的key值是否相等；</p>
<p><strong>继续看前面的put过程：</strong><br>未找到情况：当没有找到对应的hash值，或者相同的hash，但没有找到相等的key的情况，这个时候，查找结果index表示待插入的位置，未找到返回index的取反（~index）;便于插入操作判断是进行插入还是重写；</p>
<p><strong>覆盖操作：</strong><br>如果index&gt;=0表示当期key值已存在，则需要进行覆盖，将mArray[(index&lt;&lt;1) + 1]即value赋值为新的value值，然后返回old value值；<br>如果index&lt;0，表示需要执行插入操作，~index即为新元素要插入的位置；</p>
<p><strong>扩充容量：</strong><br>再插入之前，首先判断当前存储空间是否足够，HashMap的扩容时机是总空间超过容量<em>状态因子时，而ArrayMap是当mHash的大小超过MAX_SIZE，即进行扩容，扩容的算法为：<br>n = mSize &gt;= (BASE_SIZE</em>2) ? (mSize+(mSize&gt;&gt;1))<br>        : (mSize &gt;= BASE_SIZE ? (BASE_SIZE*2) : BASE_SIZE);<br>BASE_SIZE=4;即容量大于8的时候，扩容1.5倍；容量大于4小于8时，直接分配空间为8；否则分配空间为4；<br>扩充容量的操作和ArrayList差不多，都是操作数组进行复制。注意这里mHash和mArray都要复制；</p>
<p><strong>插入操作：</strong><br>插入操作也是简单的数组已知index进行插入问题，简单的arraycopy；</p>
<h2 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h2><p>较为简单，通过mHash数组获取存储位置，&lt;0表示没有找到，否则返回value值即可；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = indexOfKey(key);</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> ? (V)mArray[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="remove操作"><a href="#remove操作" class="headerlink" title="remove操作"></a>remove操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找对应的index进行remove</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = indexOfKey(key);</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> removeAt(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Remove the key/value mapping at the given index.</span><br><span class="line"> * <span class="doctag">@param</span> index The desired index, must be between 0 and &#123;<span class="doctag">@link</span> #size()&#125;-1.</span><br><span class="line"> * <span class="doctag">@return</span> Returns the value that was stored at this index.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object old = mArray[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (mSize &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Now empty.</span></span><br><span class="line">        <span class="comment">// 删除之后数组中元素就为空了，所以进行空间释放</span></span><br><span class="line">        freeArrays(mHashes, mArray, mSize);</span><br><span class="line">        mHashes = EmptyArray.INT;</span><br><span class="line">        mArray = EmptyArray.OBJECT;</span><br><span class="line">        mSize = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果空余空间过多，将要收缩空间</span></span><br><span class="line">        <span class="keyword">if</span> (mHashes.length &gt; (BASE_SIZE*<span class="number">2</span>) &amp;&amp; mSize &lt; mHashes.length/<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// Shrunk enough to reduce size of arrays.  We don't allow it to</span></span><br><span class="line">            <span class="comment">// shrink smaller than (BASE_SIZE*2) to avoid flapping between</span></span><br><span class="line">            <span class="comment">// that and BASE_SIZE.</span></span><br><span class="line">            <span class="comment">// 收缩空间大小</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> n = mSize &gt; (BASE_SIZE*<span class="number">2</span>) ? (mSize + (mSize&gt;&gt;<span class="number">1</span>)) : (BASE_SIZE*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] ohashes = mHashes;</span><br><span class="line">            <span class="keyword">final</span> Object[] oarray = mArray;</span><br><span class="line">            allocArrays(n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 简单的数组元素删除操作</span></span><br><span class="line">            mSize--;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"remove: copy from 0-"</span> + index + <span class="string">" to 0"</span>);</span><br><span class="line">                System.arraycopy(ohashes, <span class="number">0</span>, mHashes, <span class="number">0</span>, index);</span><br><span class="line">                System.arraycopy(oarray, <span class="number">0</span>, mArray, <span class="number">0</span>, index &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; mSize) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"remove: copy from "</span> + (index+<span class="number">1</span>) + <span class="string">"-"</span> + mSize</span><br><span class="line">                        + <span class="string">" to "</span> + index);</span><br><span class="line">                System.arraycopy(ohashes, index + <span class="number">1</span>, mHashes, index, mSize - index);</span><br><span class="line">                System.arraycopy(oarray, (index + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>, mArray, index &lt;&lt; <span class="number">1</span>,</span><br><span class="line">                        (mSize - index) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mSize--;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; mSize) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"remove: move "</span> + (index+<span class="number">1</span>) + <span class="string">"-"</span> + mSize</span><br><span class="line">                        + <span class="string">" to "</span> + index);</span><br><span class="line">                System.arraycopy(mHashes, index + <span class="number">1</span>, mHashes, index, mSize - index);</span><br><span class="line">                System.arraycopy(mArray, (index + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>, mArray, index &lt;&lt; <span class="number">1</span>,</span><br><span class="line">                        (mSize - index) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mArray[mSize &lt;&lt; <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">            mArray[(mSize &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (V)old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayMap的remove操作，除了将元素从数组指定位置删除之外；当数组的空余空间过多时，还需要对空间进行紧缩。<br>紧缩的时机是mHashes.length &gt; (BASE_SIZE*2) &amp;&amp; mSize &lt; mHashes.length/3；<br>即mHash数组的容量大于8，并且当前存储的元素不足总空间的三分之一，则进行紧缩，来节省内存使用。</p>
<h1 id="SparseArray简单分析："><a href="#SparseArray简单分析：" class="headerlink" title="SparseArray简单分析："></a>SparseArray简单分析：</h1><p>SparseArray是用来替代HashpMap<integer,xxx>的，即key的类型为Integer，ArrayMap避免了int的自动装箱操作，和ArrayMap的原理大致相同，也是使用了两个数组mKeys、mValues来分别存储key值和value值。避免了对int类型的key再进行Hash。<br>同样查找元素的操作也是通过二分法，基本原理和ArrayMap大致相同；这里有个区别是，当删除元素时，并不立即将对应key删除，然后占一个空位便于以后今后复用；当空间紧张时，再进行统一删除，避免了频繁的数组移动操作；<br><strong>1）put操作：</strong></integer,xxx></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 二分查找位置</span></span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到对应元素</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mValues[i] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = ~i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里是进行复用之前已经删过的元素</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class="line">            mKeys[i] = key;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果数组空间不够继续存储时，对原数组进行GC</span></span><br><span class="line">        <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">            gc();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Search again because indices may have changed.</span></span><br><span class="line">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行插入操作</span></span><br><span class="line">        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</span><br><span class="line">        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">        mSize++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到和ArrayMap基本相同，也是通过二分查找找到对应的存储位置，然后执行插入，只不过这里多个一个删除元素复用的情况；来看一下删除的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    delete(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mValues[i] != DELETED) &#123;</span><br><span class="line">            mValues[i] = DELETED;</span><br><span class="line">            mGarbage = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Removes the mapping at the specified index.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mValues[index] != DELETED) &#123;</span><br><span class="line">        mValues[index] = DELETED;</span><br><span class="line">        mGarbage = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到删除逻辑中只是将要删除的元素的value值设置成了一个DELETE的空对象，并未进行移位删除操作；它的移位删除操作统一放在了put里面数组空间不够用时进行的gc函数中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Log.e("SparseArray", "gc start with " + mSize);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = mSize;</span><br><span class="line">    <span class="keyword">int</span> o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] keys = mKeys;</span><br><span class="line">    Object[] values = mValues;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Object val = values[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val != DELETED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != o) &#123;</span><br><span class="line">                keys[o] = keys[i];</span><br><span class="line">                values[o] = val;</span><br><span class="line">                values[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            o++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mGarbage = <span class="keyword">false</span>;</span><br><span class="line">    mSize = o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Log.e("SparseArray", "gc end with " + mSize);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的数组紧缩操作，从前往后扫描，将非DELETE元素通过交换紧缩到前面空间中来；</p>
<p>因此综上来看，ArrayMap和SparseMap都是通过数组来实现的，一个数组存储hash值（key值），用以通过二分查找查找key对应的存储位置；相对于HashMap的查询效率O(1)而言，ArrayMap和 SparseMap的查询效率O(lgn)并不出色，而且涉及到大量的数组移位操作；但是ArrayMap和 SparseMap最大的好处是节省空间，而且提供了良好的及时进行空间紧缩，特别适合Android这些内存空间比较紧张的开发环境。而SparseMap是对应HashMap特殊情况的优化，在key为Integer时，避免了装箱操作。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016 流云易采
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8">
  
  <title>Liuyunyicai</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Liuyunyicai">
<meta property="og:url" content="http://liuyunyicai.github.io/index.html">
<meta property="og:site_name" content="Liuyunyicai">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Liuyunyicai">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Liuyunyicai" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
      <link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet">
  
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
      <style> .article { opacity: 0;} </style>
  
  <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/clipboard.js/1.5.9/clipboard.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
          fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
          scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.0.9/scrollreveal.min.js"
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/liuyunyicai.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">流云易采</a></h1>
        </hgroup>

        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">文章列表</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/979724798@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" target="_blank" href="http://blog.csdn.net/woliuyunyicai" title="CSDN"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">Android,Java</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">流云易采</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/liuyunyicai.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">流云易采</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">文章列表</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/979724798@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" target="_blank" href="http://blog.csdn.net/woliuyunyicai" title="CSDN"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-Fragment源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/16/Fragment源码解析/" class="article-date">
      <time datetime="2016-05-16T09:04:34.825Z" itemprop="datePublished">2016-05-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/16/Fragment源码解析/">Fragment源码解析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="一、Fragment的简单使用："><a href="#一、Fragment的简单使用：" class="headerlink" title="一、Fragment的简单使用："></a>一、Fragment的简单使用：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();</span><br><span class="line">transaction.add(R.id.radio1, tabFourFragment, tabFourFragment.getTag());</span><br><span class="line">transaction.remove(tabFourFragment);</span><br><span class="line">transaction.replace(R.id.radio1, tabFourFragment);</span><br><span class="line">transaction.addToBackStack(tabFourFragment.getTag());</span><br><span class="line">transaction.commit();</span><br></pre></td></tr></table></figure>
<p>主要涉及到的类如下图所示：<br><img src="http://img.blog.csdn.net/20160525164207857" alt="这里写图片描述"></p>
<p>通过FragmentActivity来获取FragmentManager，FragmentActivity内部有一个FragmentController对象mFragments，它看起来像是其内部类HostCallBack（继承自FragmentHostCallback）的代理类，代理HostCallback处理众多回调事件；<br>HostCallBack持有FragmentManager(实际类型为FragmentManagerImpl)对象，用户通过getFragmentManager获取到的即为该对象；<br>调用FragmentManagerImpl的beginTransaction返回的是一个FragmentTransaction（实际类型为BackStackRecord,它是一个Runnbale），后面的一切add,replace等事务处理操作，都是BackStackRecord创建一个特定类型的Op（Op是一个记录操作事务事件类型的双向链表），然后添加到事件队列中，每一个add等事件对应一个Op；然后在commit时统一通过FragmentManager进行处理，处理的关键函数为moveToState。</p>
<h1 id="二、来看FragmentTransaction的实际类型："><a href="#二、来看FragmentTransaction的实际类型：" class="headerlink" title="二、来看FragmentTransaction的实际类型："></a>二、来看FragmentTransaction的实际类型：</h1><p><strong> FragmentActivity#getSupportFragmentManager： </strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> FragmentController mFragments = FragmentController.createController(<span class="keyword">new</span> HostCallbacks());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> FragmentManager <span class="title">getSupportFragmentManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mFragments.getSupportFragmentManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> HostCallbacks主要实现了像onAttachFragment、onStartActivityFromFragment、onFindViewById等回调方法，并且持有FragmentActivity的Activity、Context、Handler等引用，并且为它所持有的FragmentManager提供资源。<br>FragmentController负责将生命周期分发给它持有的FragmentHostCallback中的FragmentManager。</p>
<h2 id="1、HostCallbacks："><a href="#1、HostCallbacks：" class="headerlink" title="1、HostCallbacks："></a>1、HostCallbacks：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HostCallbacks</span> <span class="keyword">extends</span> <span class="title">FragmentHostCallback</span>&lt;<span class="title">FragmentActivity</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HostCallbacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(FragmentActivity.<span class="keyword">this</span> <span class="comment">/*fragmentActivity*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDump</span><span class="params">(String prefix, FileDescriptor fd, PrintWriter writer, String[] args)</span> </span>&#123;</span><br><span class="line">        FragmentActivity.<span class="keyword">this</span>.dump(prefix, fd, writer, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onHasWindowAnimations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getWindow() != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onGetWindowAnimations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Window w = getWindow();</span><br><span class="line">        <span class="keyword">return</span> (w == <span class="keyword">null</span>) ? <span class="number">0</span> : w.getAttributes().windowAnimations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttachFragment</span><span class="params">(Fragment fragment)</span> </span>&#123;</span><br><span class="line">        FragmentActivity.<span class="keyword">this</span>.onAttachFragment(fragment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onFindViewById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FragmentActivity.<span class="keyword">this</span>.findViewById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onHasView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Window w = getWindow();</span><br><span class="line">        <span class="keyword">return</span> (w != <span class="keyword">null</span> &amp;&amp; w.peekDecorView() != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续来看<strong>FragmentHostCallback：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentHostCallback</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">FragmentContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Activity mActivity;</span><br><span class="line">    <span class="keyword">final</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mHandler;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mWindowAnimations;</span><br><span class="line">    <span class="keyword">final</span> FragmentManagerImpl mFragmentManager = <span class="keyword">new</span> FragmentManagerImpl();</span><br><span class="line">    <span class="keyword">private</span> SimpleArrayMap&lt;String, LoaderManager&gt; mAllLoaderManagers;</span><br><span class="line">    <span class="keyword">private</span> LoaderManagerImpl mLoaderManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mCheckedForLoaderManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mLoadersStarted;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FragmentHostCallback</span><span class="params">(Context context, Handler handler, <span class="keyword">int</span> windowAnimations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, context, handler, windowAnimations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入进来的构造函数</span></span><br><span class="line">    FragmentHostCallback(FragmentActivity activity) &#123;</span><br><span class="line">        <span class="keyword">this</span>(activity, activity , activity.mHandler, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FragmentHostCallback(Activity activity, Context context, Handler handler,</span><br><span class="line">                         <span class="keyword">int</span> windowAnimations) &#123;</span><br><span class="line">        mActivity = activity;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mHandler = handler;</span><br><span class="line">        mWindowAnimations = windowAnimations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">FragmentManagerImpl <span class="title">getFragmentManagerImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mFragmentManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 FragmentHostCallback持有FragmentActivity的activity,Handler,Context的引用，并且创建一个FragmentManagerImpl，它是FragmentManager的具体实现类，这是Android常见的用法。</p>
<h2 id="2、FragmentController-createController："><a href="#2、FragmentController-createController：" class="headerlink" title="2、FragmentController#createController："></a>2、FragmentController#createController：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FragmentHostCallback&lt;?&gt; mHost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Returns a &#123;<span class="doctag">@link</span> FragmentController&#125;.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FragmentController <span class="title">createController</span><span class="params">(FragmentHostCallback&lt;?&gt; callbacks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FragmentController(callbacks);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FragmentController</span><span class="params">(FragmentHostCallback&lt;?&gt; callbacks)</span> </span>&#123;</span><br><span class="line">        mHost = callbacks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Returns a &#123;<span class="doctag">@link</span> FragmentManager&#125; for this controller.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FragmentManager <span class="title">getSupportFragmentManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mHost.getFragmentManagerImpl();</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到FragmentController提供的很多方法都是通过FragmentHostCallback来实现的，而之前调用getSupportFragmentManager获取到的也就是在HostCallback中创建的FragmentManagerImpl对象；<br>下面调用</p>
<h2 id="3、FragmentManagerImpl-beginTransaction："><a href="#3、FragmentManagerImpl-beginTransaction：" class="headerlink" title="3、FragmentManagerImpl#beginTransaction："></a>3、FragmentManagerImpl#beginTransaction：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">beginTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BackStackRecord(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、BackStackRecord："><a href="#4、BackStackRecord：" class="headerlink" title="4、BackStackRecord："></a>4、BackStackRecord：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BackStackRecord</span> <span class="keyword">extends</span> <span class="title">FragmentTransaction</span> <span class="keyword">implements</span></span><br><span class="line">        <span class="title">FragmentManager</span>.<span class="title">BackStackEntry</span>, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> FragmentManagerImpl mManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BackStackRecord</span><span class="params">(FragmentManagerImpl manager)</span> </span>&#123;</span><br><span class="line">        mManager = manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BackStackRecord是FragmentTransaction的具体实现类，从名称可以看出，它是用来记录BackStack的；而且它集成了Runnable,是一个线程；后面的一系列操作也是基于该类来实现的；<br>故综上所述：FragmentTransaction的实际类型为BackStackRecord；</p>
<h1 id="三、接下来看FragmentTransaction的操作："><a href="#三、接下来看FragmentTransaction的操作：" class="headerlink" title="三、接下来看FragmentTransaction的操作："></a>三、接下来看FragmentTransaction的操作：</h1><h2 id="1、BackStackRecord-add"><a href="#1、BackStackRecord-add" class="headerlink" title="1、BackStackRecord#add:"></a>1、BackStackRecord#add:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">add</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment, String tag)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意传入的动作类型对应为OP_ADD</span></span><br><span class="line">    doAddOp(containerViewId, fragment, tag, OP_ADD);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAddOp</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment, String tag, <span class="keyword">int</span> opcmd)</span> </span>&#123;</span><br><span class="line">    fragment.mFragmentManager = mManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置fragment的tag</span></span><br><span class="line">    <span class="keyword">if</span> (tag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果fragment的mTag已经设置</span></span><br><span class="line">        <span class="keyword">if</span> (fragment.mTag != <span class="keyword">null</span> &amp;&amp; !tag.equals(fragment.mTag)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can't change tag of fragment "</span></span><br><span class="line">                    + fragment + <span class="string">": was "</span> + fragment.mTag</span><br><span class="line">                    + <span class="string">" now "</span> + tag);</span><br><span class="line">        &#125;</span><br><span class="line">        fragment.mTag = tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置fragment的ContainerId </span></span><br><span class="line">    <span class="keyword">if</span> (containerViewId != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fragment.mFragmentId != <span class="number">0</span> &amp;&amp; fragment.mFragmentId != containerViewId) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can't change container ID of fragment "</span></span><br><span class="line">                    + fragment + <span class="string">": was "</span> + fragment.mFragmentId</span><br><span class="line">                    + <span class="string">" now "</span> + containerViewId);</span><br><span class="line">        &#125;</span><br><span class="line">        fragment.mContainerId = fragment.mFragmentId = containerViewId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重要类Op,主要的操作都是基于此的</span></span><br><span class="line">    Op op = <span class="keyword">new</span> Op();</span><br><span class="line">    op.cmd = opcmd;</span><br><span class="line">    op.fragment = fragment;</span><br><span class="line">    addOp(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面涉及到简单的fragment赋值操作，最重要的引出了一个Op类，FragmentTransaction的所有操作都是基于此来实现的。</p>
<h2 id="2、Op"><a href="#2、Op" class="headerlink" title="2、Op:"></a>2、Op:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BackStackRecord</span> <span class="keyword">extends</span> <span class="title">FragmentTransaction</span> <span class="keyword">implements</span></span><br><span class="line">        <span class="title">FragmentManager</span>.<span class="title">BackStackEntry</span>, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对应Transaction的各种操作</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_NULL = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ADD = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_REPLACE = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_REMOVE = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_HIDE = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_SHOW = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_DETACH = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ATTACH = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BackStackRecord的静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Op</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 明显的双向链表结构</span></span><br><span class="line">        Op next;</span><br><span class="line">        Op prev;</span><br><span class="line">        <span class="comment">// 执行操作类型</span></span><br><span class="line">        <span class="keyword">int</span> cmd;</span><br><span class="line">        <span class="comment">// 执行的fragment</span></span><br><span class="line">        Fragment fragment;</span><br><span class="line">        <span class="keyword">int</span> enterAnim;</span><br><span class="line">        <span class="keyword">int</span> exitAnim;</span><br><span class="line">        <span class="keyword">int</span> popEnterAnim;</span><br><span class="line">        <span class="keyword">int</span> popExitAnim;</span><br><span class="line">        ArrayList&lt;Fragment&gt; removed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Op链表的头节点和尾节点</span></span><br><span class="line">    Op mHead;</span><br><span class="line">    Op mTail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Op是 BackStackRecord 的静态内部类，是个明显的双向链表结构，其中保存了操作的Fragment引用及操作类型；一个add事件，会创建一个Op对象与之对应，并且调用addOp操作。</p>
<h2 id="3、BackStackRecord-addOp"><a href="#3、BackStackRecord-addOp" class="headerlink" title="3、BackStackRecord#addOp:"></a>3、BackStackRecord#addOp:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录op的总数目</span></span><br><span class="line"><span class="keyword">int</span> mNumOp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表的插入操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addOp</span><span class="params">(Op op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mHead = mTail = op;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        op.prev = mTail;</span><br><span class="line">        mTail.next = op;</span><br><span class="line">        mTail = op;</span><br><span class="line">    &#125;</span><br><span class="line">    op.enterAnim = mEnterAnim;</span><br><span class="line">    op.exitAnim = mExitAnim;</span><br><span class="line">    op.popEnterAnim = mPopEnterAnim;</span><br><span class="line">    op.popExitAnim = mPopExitAnim;</span><br><span class="line">    mNumOp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到FragmentTransaction执行add操作，就是创建一个Op对象，该Op对象记录了要操作的fragmen及操作类型，然后插入到 BackStackRecord中维护的链表中；<br>那么类似的来看remove等操作：</p>
<h2 id="4、remove-replace等操作："><a href="#4、remove-replace等操作：" class="headerlink" title="4、remove,replace等操作："></a>4、remove,replace等操作：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">replace</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment, String tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (containerViewId == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must use non-zero containerViewId"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doAddOp(containerViewId, fragment, tag, OP_REPLACE);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">remove</span><span class="params">(Fragment fragment)</span> </span>&#123;</span><br><span class="line">    Op op = <span class="keyword">new</span> Op();</span><br><span class="line">    op.cmd = OP_REMOVE;</span><br><span class="line">    op.fragment = fragment;</span><br><span class="line">    addOp(op);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">hide</span><span class="params">(Fragment fragment)</span> </span>&#123;</span><br><span class="line">    Op op = <span class="keyword">new</span> Op();</span><br><span class="line">    op.cmd = OP_HIDE;</span><br><span class="line">    op.fragment = fragment;</span><br><span class="line">    addOp(op);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑基本一致，只不过修改了Op的cmd变量，即操作类型不同而已；可想而知，最后是通过commit来统一进行处理，这样也维护了事件的原子性。</p>
<h1 id="四、FragmentTransaction的commit操作："><a href="#四、FragmentTransaction的commit操作：" class="headerlink" title="四、FragmentTransaction的commit操作："></a>四、FragmentTransaction的commit操作：</h1><h2 id="1、先来看addToBackStack："><a href="#1、先来看addToBackStack：" class="headerlink" title="1、先来看addToBackStack："></a>1、先来看addToBackStack：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">addToBackStack</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mAllowAddToBackStack) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"This FragmentTransaction is not allowed to be added to the back stack."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mAddToBackStack = <span class="keyword">true</span>;</span><br><span class="line">    mName = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只是将mAddToBackStack赋值为true，也并未进行实际的处理；来看commit.</p>
<h2 id="2、commit"><a href="#2、commit" class="headerlink" title="2、commit:"></a>2、commit:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commitInternal(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">commitAllowingStateLoss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commitInternal(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">commitInternal</span><span class="params">(<span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一次transaction只能commit一次</span></span><br><span class="line">    <span class="keyword">if</span> (mCommitted) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"commit already called"</span>);</span><br><span class="line">    <span class="comment">// 记录该transaction的提交状态</span></span><br><span class="line">    mCommitted = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// mAddToBackStack就是addToBackStack所设置的</span></span><br><span class="line">    <span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">        <span class="comment">// 这里是添加到BackStack的处理逻辑</span></span><br><span class="line">        mIndex = mManager.allocBackStackIndex(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mIndex = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体的处理逻辑</span></span><br><span class="line">    mManager.enqueueAction(<span class="keyword">this</span>, allowStateLoss);</span><br><span class="line">    <span class="keyword">return</span> mIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个transaction 显然只能commit一次，重复提交就会抛出异常；<br>allocBackStackIndex是用来处理addToBackStack事件的；<br>enqueueAction用来处理前面的执行逻辑；<br>这里先来看enqueueAction，这里的mManager是传递进来的FragmentManagerImpl对象。</p>
<h2 id="3、FragmentManagerImpl-enqueueAction："><a href="#3、FragmentManagerImpl-enqueueAction：" class="headerlink" title="3、FragmentManagerImpl#enqueueAction："></a>3、FragmentManagerImpl#enqueueAction：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">FragmentHostCallback mHost; <span class="comment">// 前面创建的FragmentHostCallback</span></span><br><span class="line"><span class="keyword">boolean</span> mDestroyed;</span><br><span class="line">ArrayList&lt;Runnable&gt; mPendingActions;</span><br><span class="line"></span><br><span class="line">Runnable mExecCommit = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        execPendingActions();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueAction</span><span class="params">(Runnable action, <span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个是和onSavedInstanceState异常恢复相关的</span></span><br><span class="line">    <span class="keyword">if</span> (!allowStateLoss) &#123;</span><br><span class="line">        checkStateLoss();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDestroyed || mHost == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Activity has been destroyed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mPendingActions == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mPendingActions = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前面提到BackStackRecord是个Runnbale，这里将其添加到一个等待链表中mPendingActions</span></span><br><span class="line">        mPendingActions.add(action);</span><br><span class="line">        <span class="keyword">if</span> (mPendingActions.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// mHost.getHandler()前面已经提到这里对应Fragment中的Handler</span></span><br><span class="line">            mHost.getHandler().removeCallbacks(mExecCommit);</span><br><span class="line">            mHost.getHandler().post(mExecCommit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面提到BackStackRecord是个Runnbale，这里将其添加到一个等待链表中mPendingActions中；然后使用FragmentActivity中Handler将mExecCommit这个Runnable Post出去；其主要执行逻辑为execPendingActions方法；继续来看：</p>
<h2 id="3、execPendingActions："><a href="#3、execPendingActions：" class="headerlink" title="3、execPendingActions："></a>3、execPendingActions：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">FragmentHostCallback mHost; <span class="comment">// 前面创建的FragmentHostCallback</span></span><br><span class="line">ArrayList&lt;Runnable&gt; mPendingActions;</span><br><span class="line">Runnable[] mTmpActions;</span><br><span class="line"><span class="keyword">boolean</span> mExecutingActions;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execPendingActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mExecutingActions) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Recursive entry to executePendingTransactions"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (Looper.myLooper() != mHost.getHandler().getLooper()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Must be called from main thread of process"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> numActions;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mPendingActions == <span class="keyword">null</span> || mPendingActions.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            numActions = mPendingActions.size();</span><br><span class="line">            <span class="keyword">if</span> (mTmpActions == <span class="keyword">null</span> || mTmpActions.length &lt; numActions) &#123;</span><br><span class="line">                mTmpActions = <span class="keyword">new</span> Runnable[numActions];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将mPendingActions中保存的Action一次性转移到mTmpActions中，然后清空</span></span><br><span class="line">            mPendingActions.toArray(mTmpActions);</span><br><span class="line">            mPendingActions.clear();</span><br><span class="line">            mHost.getHandler().removeCallbacks(mExecCommit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mExecutingActions = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 执行操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numActions; i++) &#123;</span><br><span class="line">            mTmpActions[i].run();</span><br><span class="line">            mTmpActions[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mExecutingActions = <span class="keyword">false</span>;</span><br><span class="line">        didSomething = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHavePendingDeferredStart) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> loadersRunning = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mActive.size(); i++) &#123;</span><br><span class="line">            Fragment f = mActive.get(i);</span><br><span class="line">            <span class="keyword">if</span> (f != <span class="keyword">null</span> &amp;&amp; f.mLoaderManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                loadersRunning |= f.mLoaderManager.hasRunningLoaders();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!loadersRunning) &#123;</span><br><span class="line">            mHavePendingDeferredStart = <span class="keyword">false</span>;</span><br><span class="line">            startPendingDeferredFragments();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段逻辑必须在主线程中运行；而且最后调用BackStackRecord的run方法，这里才是真正的逻辑处理的地方。</p>
<h2 id="4、BackStackRecord-run"><a href="#4、BackStackRecord-run" class="headerlink" title="4、BackStackRecord#run:"></a>4、BackStackRecord#run:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"addToBackStack() called after commit()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bumpBackStackNesting(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    TransitionState state = <span class="keyword">null</span>;</span><br><span class="line">    SparseArray&lt;Fragment&gt; firstOutFragments = <span class="keyword">null</span>;</span><br><span class="line">    SparseArray&lt;Fragment&gt; lastInFragments = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (SUPPORTS_TRANSITIONS) &#123;</span><br><span class="line">        firstOutFragments = <span class="keyword">new</span> SparseArray&lt;Fragment&gt;();</span><br><span class="line">        lastInFragments = <span class="keyword">new</span> SparseArray&lt;Fragment&gt;();</span><br><span class="line"></span><br><span class="line">        calculateFragments(firstOutFragments, lastInFragments);</span><br><span class="line"></span><br><span class="line">        state = beginTransition(firstOutFragments, lastInFragments, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> transitionStyle = state != <span class="keyword">null</span> ? <span class="number">0</span> : mTransitionStyle;</span><br><span class="line">    <span class="keyword">int</span> transition = state != <span class="keyword">null</span> ? <span class="number">0</span> : mTransition;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环处理这个BackStackRecord中的Op链表中的所有Op</span></span><br><span class="line">    Op op = mHead;</span><br><span class="line">    <span class="keyword">while</span> (op != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> enterAnim = state != <span class="keyword">null</span> ? <span class="number">0</span> : op.enterAnim;</span><br><span class="line">        <span class="keyword">int</span> exitAnim = state != <span class="keyword">null</span> ? <span class="number">0</span> : op.exitAnim;</span><br><span class="line">        <span class="keyword">switch</span> (op.cmd) &#123;</span><br><span class="line">            <span class="comment">// 对于OP_ADD操作，执行addFragment</span></span><br><span class="line">            <span class="keyword">case</span> OP_ADD: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = enterAnim;</span><br><span class="line">                mManager.addFragment(f, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_REPLACE: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                <span class="keyword">int</span> containerId = f.mContainerId;</span><br><span class="line">                <span class="keyword">if</span> (mManager.mAdded != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mManager.mAdded.size(); i++) &#123;</span><br><span class="line">                        Fragment old = mManager.mAdded.get(i);</span><br><span class="line">                        <span class="keyword">if</span> (old.mContainerId == containerId) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (old == f) &#123;</span><br><span class="line">                                op.fragment = f = <span class="keyword">null</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (op.removed == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    op.removed = <span class="keyword">new</span> ArrayList&lt;Fragment&gt;();</span><br><span class="line">                                &#125;</span><br><span class="line">                                op.removed.add(old);</span><br><span class="line">                                old.mNextAnim = exitAnim;</span><br><span class="line">                                <span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">                                    old.mBackStackNesting += <span class="number">1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                mManager.removeFragment(old, transition, transitionStyle);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    f.mNextAnim = enterAnim;</span><br><span class="line">                    mManager.addFragment(f, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_REMOVE: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = exitAnim;</span><br><span class="line">                mManager.removeFragment(f, transition, transitionStyle);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_HIDE: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = exitAnim;</span><br><span class="line">                mManager.hideFragment(f, transition, transitionStyle);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_SHOW: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = enterAnim;</span><br><span class="line">                mManager.showFragment(f, transition, transitionStyle);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_DETACH: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = exitAnim;</span><br><span class="line">                mManager.detachFragment(f, transition, transitionStyle);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_ATTACH: &#123;</span><br><span class="line">                Fragment f = op.fragment;</span><br><span class="line">                f.mNextAnim = enterAnim;</span><br><span class="line">                mManager.attachFragment(f, transition, transitionStyle);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown cmd: "</span> + op.cmd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        op = op.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mManager.moveToState(mManager.mCurState, transition, transitionStyle, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">        mManager.addBackStackState(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很长，逻辑很简单，遍历BackStackRecord中保存的Op链表，处理每一个Op事件；每一个Op都对应了一个操作类型比如OP_ADD，其相应的处理是回过来通过FragmentManagerImpl的addFragment来实现的。下面继续分析处理的处理的具体细节。</p>
<h1 id="五、继续前面的流程分析："><a href="#五、继续前面的流程分析：" class="headerlink" title="五、继续前面的流程分析："></a>五、继续前面的流程分析：</h1><h2 id="1、FragmentManagerImpl-addFragment"><a href="#1、FragmentManagerImpl-addFragment" class="headerlink" title="1、FragmentManagerImpl#addFragment:"></a>1、FragmentManagerImpl#addFragment:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Fragment&gt; mAdded;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFragment</span><span class="params">(Fragment fragment, <span class="keyword">boolean</span> moveToStateNow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAdded == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mAdded = <span class="keyword">new</span> ArrayList&lt;Fragment&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为Fragment设置index，并添加到mActive数组中</span></span><br><span class="line">    makeActive(fragment);</span><br><span class="line">    <span class="keyword">if</span> (!fragment.mDetached) &#123;</span><br><span class="line">        <span class="comment">// fragment已经存在</span></span><br><span class="line">        <span class="keyword">if</span> (mAdded.contains(fragment)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fragment already added: "</span> + fragment);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加到mAdded中</span></span><br><span class="line">        mAdded.add(fragment);</span><br><span class="line">        fragment.mAdded = <span class="keyword">true</span>;</span><br><span class="line">        fragment.mRemoving = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (fragment.mHasMenu &amp;&amp; fragment.mMenuVisible) &#123;</span><br><span class="line">            mNeedMenuInvalidate = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重要的函数，当前传进来的是false.</span></span><br><span class="line">        <span class="keyword">if</span> (moveToStateNow) &#123;</span><br><span class="line">            moveToState(fragment);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; mAvailIndices;</span><br><span class="line">ArrayList&lt;Fragment&gt; mActive;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeActive</span><span class="params">(Fragment f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示已经是Active状态，即已经在active数组中，则不用Active，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (f.mIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果mActive未创建</span></span><br><span class="line">    <span class="keyword">if</span> (mAvailIndices == <span class="keyword">null</span> || mAvailIndices.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mActive = <span class="keyword">new</span> ArrayList&lt;Fragment&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置Fragment的index及其在系统内部的Internal Name</span></span><br><span class="line">        f.setIndex(mActive.size(), mParent);</span><br><span class="line">        <span class="comment">// 添加到mActive中</span></span><br><span class="line">        mActive.add(f);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 同样类似的操作</span></span><br><span class="line">        f.setIndex(mAvailIndices.remove(mAvailIndices.size()-<span class="number">1</span>), mParent);</span><br><span class="line">        mActive.set(f.mIndex, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addFragment的主要操作时将当前的Fragment添加到mActive数组（当前Active状态的Fragment集合）以及mAdded数组中；然后进行Fragment相关状态的设置；<br>对应再来看remove:</p>
<h2 id="2、FragmentManagerImpl-removeFragment"><a href="#2、FragmentManagerImpl-removeFragment" class="headerlink" title="2、FragmentManagerImpl#removeFragment"></a>2、FragmentManagerImpl#removeFragment</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeFragment</span><span class="params">(Fragment fragment, <span class="keyword">int</span> transition, <span class="keyword">int</span> transitionStyle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> inactive = !fragment.isInBackStack();</span><br><span class="line">    <span class="comment">// 与Add相对应，从Add数组中中删除</span></span><br><span class="line">    <span class="keyword">if</span> (!fragment.mDetached || inactive) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAdded != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAdded.remove(fragment);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fragment.mHasMenu &amp;&amp; fragment.mMenuVisible) &#123;</span><br><span class="line">            mNeedMenuInvalidate = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fragment.mAdded = <span class="keyword">false</span>;</span><br><span class="line">        fragment.mRemoving = <span class="keyword">true</span>;</span><br><span class="line">        moveToState(fragment, inactive ? Fragment.INITIALIZING : Fragment.CREATED,</span><br><span class="line">                transition, transitionStyle, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>removeFragment就是将Fragment从mAdd数组中删除；<br>而hide,show的主要逻辑是设置Fragment的Visibilty,hide设置为GONE，show设置为VISIBLE。<br>attach,detach也是操作mAdd.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachFragment</span><span class="params">(Fragment fragment, <span class="keyword">int</span> transition, <span class="keyword">int</span> transitionStyle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"attach: "</span> + fragment);</span><br><span class="line">    <span class="keyword">if</span> (fragment.mDetached) &#123;</span><br><span class="line">        fragment.mDetached = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!fragment.mAdded) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAdded == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mAdded = <span class="keyword">new</span> ArrayList&lt;Fragment&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mAdded.contains(fragment)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fragment already added: "</span> + fragment);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"add from attach: "</span> + fragment);</span><br><span class="line">            mAdded.add(fragment);</span><br><span class="line">            fragment.mAdded = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (fragment.mHasMenu &amp;&amp; fragment.mMenuVisible) &#123;</span><br><span class="line">                mNeedMenuInvalidate = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            moveToState(fragment, mCurState, transition, transitionStyle, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detachFragment</span><span class="params">(Fragment fragment, <span class="keyword">int</span> transition, <span class="keyword">int</span> transitionStyle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"detach: "</span> + fragment);</span><br><span class="line">    <span class="keyword">if</span> (!fragment.mDetached) &#123;</span><br><span class="line">        fragment.mDetached = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (fragment.mAdded) &#123;</span><br><span class="line">            <span class="comment">// We are not already in back stack, so need to remove the fragment.</span></span><br><span class="line">            <span class="keyword">if</span> (mAdded != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"remove from detach: "</span> + fragment);</span><br><span class="line">                mAdded.remove(fragment);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fragment.mHasMenu &amp;&amp; fragment.mMenuVisible) &#123;</span><br><span class="line">                mNeedMenuInvalidate = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fragment.mAdded = <span class="keyword">false</span>;</span><br><span class="line">            moveToState(fragment, Fragment.CREATED, transition, transitionStyle, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键的是看重要的函数moveToState，它是对Fragment状态进行管理的重要的函数。</p>
<h2 id="3、FragmentManagerImpl-moveToState"><a href="#3、FragmentManagerImpl-moveToState" class="headerlink" title="3、FragmentManagerImpl#moveToState:"></a>3、FragmentManagerImpl#moveToState:</h2><p>Fragment的状态总共分为以下六类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIALIZING = <span class="number">0</span>;     <span class="comment">// 还没有创建</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CREATED = <span class="number">1</span>;          <span class="comment">// 创建成功Created.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTIVITY_CREATED = <span class="number">2</span>; <span class="comment">// 对应Activity完成了create</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOPPED = <span class="number">3</span>;          <span class="comment">// 创建了，但并未开启start</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STARTED = <span class="number">4</span>;          <span class="comment">// 创建了，已经开启，而且没有resume</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESUMED = <span class="number">5</span>;          <span class="comment">// 创建了，并且已经resumed</span></span><br></pre></td></tr></table></figure>
<p>相对应的状态是按照生命周期状态进行递增的，在moveToState中通过curState转换成newState，比如INITIALIZING到STARTED，中间的四种状态仍然都是要经历的。在moveToState的switch-case中，可以看到每一个switch-case中都没有break;所以会顺序向下执行，而且每一个case中都会有判断，所以上面六种状态升序排序，最终一定会执行到想要设置的状态，而且其生命周期中每个状态都会经历。<br>而且注意，每一个case对应的是当前的curState，而真正执行的代码块对应的状态是Fragment为newState状态时的响应。即最初判断curState为INITIALIZING时，其对应的newState应该已经为CREATED了；<br>moveToState的代码较长，分来来看：</p>
<h3 id="（1）前期的一些简单判断："><a href="#（1）前期的一些简单判断：" class="headerlink" title="（1）前期的一些简单判断："></a>（1）前期的一些简单判断：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正的实现逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(Fragment f, <span class="keyword">int</span> newState, <span class="keyword">int</span> transit, <span class="keyword">int</span> transitionStyle,</span><br><span class="line">                 <span class="keyword">boolean</span> keepActive)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前Fragment的状态并不是ADD状态，或者已经detach,</span></span><br><span class="line">    <span class="comment">// 此时设置的newState比如start等会统一修改为CREATE状态,让Fragment仍停留在create状态</span></span><br><span class="line">    <span class="keyword">if</span> ((!f.mAdded || f.mDetached) &amp;&amp; newState &gt; Fragment.CREATED) &#123;</span><br><span class="line">        newState = Fragment.CREATED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当一个fragment正在被remove，该fragment应该保持原来的状态</span></span><br><span class="line">    <span class="keyword">if</span> (f.mRemoving &amp;&amp; newState &gt; f.mState) &#123;</span><br><span class="line">        <span class="comment">// While removing a fragment, we can't change it to a higher state.</span></span><br><span class="line">        newState = f.mState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Defer start if requested; don't allow it to move to STARTED or higher</span></span><br><span class="line">    <span class="comment">// if it's not already started.</span></span><br><span class="line">    <span class="keyword">if</span> (f.mDeferStart &amp;&amp; f.mState &lt; Fragment.STARTED &amp;&amp; newState &gt; Fragment.STOPPED) &#123;</span><br><span class="line">        newState = Fragment.STOPPED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（2）来到curState-lt-newState时，"><a href="#（2）来到curState-lt-newState时，" class="headerlink" title="（2）来到curState&lt;newState时，"></a>（2）来到curState&lt;newState时，</h3><h4 id="先来看INITIALIZING-gt-CREATED状态："><a href="#先来看INITIALIZING-gt-CREATED状态：" class="headerlink" title="先来看INITIALIZING==&gt;CREATED状态："></a>先来看INITIALIZING==&gt;CREATED状态：</h4><p>先来了解下Fragment的生命周期：<br><img src="http://img.blog.csdn.net/20160525164315530" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> Fragment.INITIALIZING:</span><br><span class="line">    <span class="comment">// 创建状态</span></span><br><span class="line">    <span class="comment">// mSavedFragmentState是个Bundle，用来保存Fragment异常销毁时的各种状态类型</span></span><br><span class="line">    <span class="comment">// 当期不为null时，则根据其记录的信息进行恢复</span></span><br><span class="line">    <span class="keyword">if</span> (f.mSavedFragmentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置ClassLoader</span></span><br><span class="line">        f.mSavedFragmentState.setClassLoader(mHost.getContext().getClassLoader());</span><br><span class="line">        <span class="comment">// Fragment异常关闭时保存的状态信息</span></span><br><span class="line">        f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(</span><br><span class="line">                FragmentManagerImpl.VIEW_STATE_TAG);</span><br><span class="line">        <span class="comment">// 从mActive数组中尝试获取Fragment</span></span><br><span class="line">        f.mTarget = getFragment(f.mSavedFragmentState,</span><br><span class="line">                FragmentManagerImpl.TARGET_STATE_TAG);</span><br><span class="line">        <span class="keyword">if</span> (f.mTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            f.mTargetRequestCode = f.mSavedFragmentState.getInt(</span><br><span class="line">                    FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置UserVisibleHint</span></span><br><span class="line">        f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(</span><br><span class="line">                FragmentManagerImpl.USER_VISIBLE_HINT_TAG, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 如果当前不可见，则设置Fragment状态最多为STOPPED，即创建而不启动</span></span><br><span class="line">        <span class="keyword">if</span> (!f.mUserVisibleHint) &#123;</span><br><span class="line">            f.mDeferStart = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (newState &gt; Fragment.STOPPED) &#123;</span><br><span class="line">                newState = Fragment.STOPPED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置Fragment的相关参数</span></span><br><span class="line">    f.mHost = mHost;</span><br><span class="line">    f.mParentFragment = mParent;</span><br><span class="line">    f.mFragmentManager = mParent != <span class="keyword">null</span></span><br><span class="line">            ? mParent.mChildFragmentManager : mHost.getFragmentManagerImpl();</span><br><span class="line">    f.mCalled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 调用attcah，开启Fragment的相关的生命周期</span></span><br><span class="line">    <span class="comment">// 因为mHost中保存了Fragment的宿主Activity的引用，所以可以直接进行设置，设置mCalled为true,即attach成功</span></span><br><span class="line">    f.onAttach(mHost.getContext());</span><br><span class="line">    <span class="keyword">if</span> (!f.mCalled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Fragment "</span> + f</span><br><span class="line">                + <span class="string">" did not call through to super.onAttach()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果父Fragment不为空，调用attachFragment</span></span><br><span class="line">    <span class="keyword">if</span> (f.mParentFragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mHost.onAttachFragment(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用onCreate</span></span><br><span class="line">    <span class="keyword">if</span> (!f.mRetaining) &#123;</span><br><span class="line">        f.performCreate(f.mSavedFragmentState);</span><br><span class="line">    &#125;</span><br><span class="line">    f.mRetaining = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (f.mFromLayout) &#123;</span><br><span class="line">        <span class="comment">// For fragments that are part of the content view</span></span><br><span class="line">        <span class="comment">// layout, we need to instantiate the view immediately</span></span><br><span class="line">        <span class="comment">// and the inflater will take care of adding it.</span></span><br><span class="line">        <span class="comment">// 调用onCreateView</span></span><br><span class="line">        f.mView = f.performCreateView(f.getLayoutInflater(</span><br><span class="line">                f.mSavedFragmentState), <span class="keyword">null</span>, f.mSavedFragmentState);</span><br><span class="line">        <span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            f.mInnerView = f.mView;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">11</span>) &#123;</span><br><span class="line">                ViewCompat.setSaveFromParentEnabled(f.mView, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f.mView = NoSaveStateFrameLayout.wrap(f.mView);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f.mHidden) f.mView.setVisibility(View.GONE);</span><br><span class="line">            <span class="comment">// 调用onViewCreated</span></span><br><span class="line">            f.onViewCreated(f.mView, f.mSavedFragmentState);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f.mInnerView = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里会首先判断是否要对之前销毁的Fragment进行重启，Fragment销毁时保存的状态都保存在 Fragment的mSavedFragmentState中，它是一个Bundle;这里首先对保存了state的Fragment进行恢复；<br>然后是按照上面的表开始Fragment的生命周期。一个一个来看</p>
<h5 id="1-gt-onAttach"><a href="#1-gt-onAttach" class="headerlink" title="1&gt;onAttach"></a>1&gt;onAttach</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为mHost中保存了Fragment的宿主Activity的引用，所以可以直接进行设置，设置mCalled为true,即attach成功</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Called when a fragment is first attached to its context.</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #onCreate(Bundle)&#125; will be called after this.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> Activity hostActivity = mHost == <span class="keyword">null</span> ? <span class="keyword">null</span> : mHost.getActivity();</span><br><span class="line">    <span class="keyword">if</span> (hostActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCalled = <span class="keyword">false</span>;</span><br><span class="line">        onAttach(hostActivity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Called when a fragment is first attached to its activity.</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #onCreate(Bundle)&#125; will be called after this.</span><br><span class="line"> * &lt;p&gt;Deprecated. See &#123;<span class="doctag">@link</span> #onAttach(Context)&#125;.</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-gt-onAttachFragment-如果父Fragment不为空的话"><a href="#2-gt-onAttachFragment-如果父Fragment不为空的话" class="headerlink" title="2&gt;onAttachFragment(如果父Fragment不为空的话)"></a>2&gt;onAttachFragment(如果父Fragment不为空的话)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HostCallBack</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttachFragment</span><span class="params">(Fragment fragment)</span> </span>&#123;</span><br><span class="line">    FragmentActivity.<span class="keyword">this</span>.onAttachFragment(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Called when a fragment is attached to the activity.</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttachFragment</span><span class="params">(Fragment fragment)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-gt-onCreate："><a href="#3-gt-onCreate：" class="headerlink" title="3&gt;onCreate："></a>3&gt;onCreate：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fragment.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mChildFragmentManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mChildFragmentManager.noteStateNotSaved();</span><br><span class="line">    &#125;</span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 调用onCreate</span></span><br><span class="line">    onCreate(savedInstanceState);</span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Fragment "</span> + <span class="keyword">this</span></span><br><span class="line">                + <span class="string">" did not call through to super.onCreate()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果进行恢复的话，注意恢复子Fragment的状态</span></span><br><span class="line">    <span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Parcelable p = savedInstanceState.getParcelable(</span><br><span class="line">                FragmentActivity.FRAGMENTS_TAG);</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mChildFragmentManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instantiateChildFragmentManager();</span><br><span class="line">            &#125;</span><br><span class="line">            mChildFragmentManager.restoreAllState(p, <span class="keyword">null</span>);</span><br><span class="line">            mChildFragmentManager.dispatchCreate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-gt-onCreateView：创建View"><a href="#4-gt-onCreateView：创建View" class="headerlink" title="4&gt;onCreateView：创建View"></a>4&gt;onCreateView：创建View</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">View <span class="title">performCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span><br><span class="line">        Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mChildFragmentManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mChildFragmentManager.noteStateNotSaved();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onCreateView(inflater, container, savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-gt-onViewCreated：View创建之后的回调函数，默认为空实现"><a href="#5-gt-onViewCreated：View创建之后的回调函数，默认为空实现" class="headerlink" title="5&gt;onViewCreated：View创建之后的回调函数，默认为空实现"></a>5&gt;onViewCreated：View创建之后的回调函数，默认为空实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Called immediately after &#123;<span class="doctag">@link</span> #onCreateView(LayoutInflater, ViewGroup, Bundle)&#125;</span><br><span class="line"> * has returned, but before any saved state has been restored in to the view.</span><br><span class="line"> * This gives subclasses a chance to initialize themselves once</span><br><span class="line"> * they know their view hierarchy has been completely created.  The fragment's</span><br><span class="line"> * view hierarchy is not however attached to its parent at this point.</span><br><span class="line"> * <span class="doctag">@param</span> view The View returned by &#123;<span class="doctag">@link</span> #onCreateView(LayoutInflater, ViewGroup, Bundle)&#125;.</span><br><span class="line"> * <span class="doctag">@param</span> savedInstanceState If non-null, this fragment is being re-constructed</span><br><span class="line"> * from a previous saved state as given here.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(View view, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3）接下来来到CREATE-gt-ACTIVITY-CREATED状态："><a href="#3）接下来来到CREATE-gt-ACTIVITY-CREATED状态：" class="headerlink" title="3）接下来来到CREATE==&gt;ACTIVITY_CREATED状态："></a>3）接下来来到CREATE==&gt;ACTIVITY_CREATED状态：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> Fragment.CREATED:</span><br><span class="line">    <span class="comment">// Set to true if this fragment was instantiated from a layout file.</span></span><br><span class="line">    <span class="comment">// 表示Fragment是否是通过layout file来初始化的</span></span><br><span class="line">    <span class="comment">// 即在layout中使用fragment创建的静态形式的Fragment在INITIALIZING中创建View</span></span><br><span class="line">    <span class="comment">// 而动态添加的则在CREATE中创建</span></span><br><span class="line">    <span class="keyword">boolean</span> mFromLayout;</span><br><span class="line">    <span class="keyword">if</span> (newState &gt; Fragment.CREATED) &#123;</span><br><span class="line">        <span class="comment">// 这里对应于INITIALIZING中的通过layout创建过程</span></span><br><span class="line">        <span class="keyword">if</span> (!f.mFromLayout) &#123;</span><br><span class="line">            ViewGroup container = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (f.mContainerId != <span class="number">0</span>) &#123;</span><br><span class="line">                container = (ViewGroup)mContainer.onFindViewById(f.mContainerId);</span><br><span class="line">                <span class="keyword">if</span> (container == <span class="keyword">null</span> &amp;&amp; !f.mRestored) &#123;</span><br><span class="line">                    throwException(<span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"No view found for id 0x"</span></span><br><span class="line">                                    + Integer.toHexString(f.mContainerId) + <span class="string">" ("</span></span><br><span class="line">                                    + f.getResources().getResourceName(f.mContainerId)</span><br><span class="line">                                    + <span class="string">") for fragment "</span> + f));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            f.mContainer = container;</span><br><span class="line">            f.mView = f.performCreateView(f.getLayoutInflater(</span><br><span class="line">                    f.mSavedFragmentState), container, f.mSavedFragmentState);</span><br><span class="line">            <span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                f.mInnerView = f.mView;</span><br><span class="line">                <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">11</span>) &#123;</span><br><span class="line">                    ViewCompat.setSaveFromParentEnabled(f.mView, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f.mView = NoSaveStateFrameLayout.wrap(f.mView);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (container != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Animation anim = loadAnimation(f, transit, <span class="keyword">true</span>,</span><br><span class="line">                            transitionStyle);</span><br><span class="line">                    <span class="keyword">if</span> (anim != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        setHWLayerAnimListenerIfAlpha(f.mView, anim);</span><br><span class="line">                        f.mView.startAnimation(anim);</span><br><span class="line">                    &#125;</span><br><span class="line">                    container.addView(f.mView);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (f.mHidden) f.mView.setVisibility(View.GONE);</span><br><span class="line">                f.onViewCreated(f.mView, f.mSavedFragmentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f.mInnerView = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用onActivityCreated</span></span><br><span class="line">        f.performActivityCreated(f.mSavedFragmentState);</span><br><span class="line">        <span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用onViewStateRestored</span></span><br><span class="line">            f.restoreViewState(f.mSavedFragmentState);</span><br><span class="line">        &#125;</span><br><span class="line">        f.mSavedFragmentState = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里除了继续调用生命周期函数外，可以看到Fragment的静态添加和动态添加的两个不同；在layout中使用fragment添加Fragment，其View的创建是在INITIALIZING中；而动态添加的初始化则是在CREATE状态中；</p>
<h5 id="6-gt-performActivityCreated"><a href="#6-gt-performActivityCreated" class="headerlink" title="6&gt;performActivityCreated"></a>6&gt;performActivityCreated</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mChildFragmentManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mChildFragmentManager.noteStateNotSaved();</span><br><span class="line">    &#125;</span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    onActivityCreated(savedInstanceState);</span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Fragment "</span> + <span class="keyword">this</span></span><br><span class="line">                + <span class="string">" did not call through to super.onActivityCreated()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mChildFragmentManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mChildFragmentManager.dispatchActivityCreated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-gt-restoreViewState"><a href="#7-gt-restoreViewState" class="headerlink" title="7&gt;restoreViewState"></a>7&gt;restoreViewState</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">restoreViewState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mSavedViewState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInnerView.restoreHierarchyState(mSavedViewState);</span><br><span class="line">        mSavedViewState = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    onViewStateRestored(savedInstanceState);</span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Fragment "</span> + <span class="keyword">this</span></span><br><span class="line">                + <span class="string">" did not call through to super.onViewStateRestored()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewStateRestored</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4）继续往下来到ACTIVITY-CREATED-gt-STOP-gt-STARTED状态"><a href="#4）继续往下来到ACTIVITY-CREATED-gt-STOP-gt-STARTED状态" class="headerlink" title="4）继续往下来到ACTIVITY_CREATED==&gt;STOP==&gt;STARTED状态:"></a>4）继续往下来到ACTIVITY_CREATED==&gt;STOP==&gt;STARTED状态:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> Fragment.ACTIVITY_CREATED:</span><br><span class="line"><span class="keyword">case</span> Fragment.STOPPED:</span><br><span class="line">    <span class="keyword">if</span> (newState &gt; Fragment.STOPPED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"moveto STARTED: "</span> + f);</span><br><span class="line">        f.performStart();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="8-gt-performStart"><a href="#8-gt-performStart" class="headerlink" title="8&gt; performStart:"></a>8&gt; performStart:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mChildFragmentManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mChildFragmentManager.noteStateNotSaved();</span><br><span class="line">        mChildFragmentManager.execPendingActions();</span><br><span class="line">    &#125;</span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    onStart();</span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Fragment "</span> + <span class="keyword">this</span></span><br><span class="line">                + <span class="string">" did not call through to super.onStart()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mChildFragmentManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mChildFragmentManager.dispatchStart();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mLoaderManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mLoaderManager.doReportStart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mLoadersStarted) &#123;</span><br><span class="line">        mLoadersStarted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!mCheckedForLoaderManager) &#123;</span><br><span class="line">            mCheckedForLoaderManager = <span class="keyword">true</span>;</span><br><span class="line">            mLoaderManager = mHost.getLoaderManager(mWho, mLoadersStarted, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mLoaderManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mLoaderManager.doStart();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5）STRAT-gt-RESUME对应onResume："><a href="#5）STRAT-gt-RESUME对应onResume：" class="headerlink" title="5）STRAT==&gt;RESUME对应onResume："></a>5）STRAT==&gt;RESUME对应onResume：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> Fragment.STARTED:</span><br><span class="line">    <span class="keyword">if</span> (newState &gt; Fragment.STARTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"moveto RESUMED: "</span> + f);</span><br><span class="line">        f.mResumed = <span class="keyword">true</span>;</span><br><span class="line">        f.performResume();</span><br><span class="line">        f.mSavedFragmentState = <span class="keyword">null</span>;</span><br><span class="line">        f.mSavedViewState = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="9-gt-performResume"><a href="#9-gt-performResume" class="headerlink" title="9&gt;performResume:"></a>9&gt;performResume:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mChildFragmentManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mChildFragmentManager.noteStateNotSaved();</span><br><span class="line">        mChildFragmentManager.execPendingActions();</span><br><span class="line">    &#125;</span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    onResume();</span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Fragment "</span> + <span class="keyword">this</span></span><br><span class="line">                + <span class="string">" did not call through to super.onResume()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mChildFragmentManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mChildFragmentManager.dispatchResume();</span><br><span class="line">        mChildFragmentManager.execPendingActions();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（3）再来到f-mState-gt-newState："><a href="#（3）再来到f-mState-gt-newState：" class="headerlink" title="（3）再来到f.mState &gt; newState："></a>（3）再来到f.mState &gt; newState：</h3><p> 再来看逆向销毁的过程，基本上生命周期流程图中的相匹配；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f.mState &gt; newState) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (f.mState) &#123;</span><br><span class="line">        <span class="keyword">case</span> Fragment.RESUMED:</span><br><span class="line">            <span class="keyword">if</span> (newState &lt; Fragment.RESUMED) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"movefrom RESUMED: "</span> + f);</span><br><span class="line">                <span class="comment">// 执行onPause</span></span><br><span class="line">                f.performPause();</span><br><span class="line">                f.mResumed = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> Fragment.STARTED:</span><br><span class="line">            <span class="keyword">if</span> (newState &lt; Fragment.STARTED) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"movefrom STARTED: "</span> + f);</span><br><span class="line">                <span class="comment">// 执行onStop</span></span><br><span class="line">                f.performStop();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> Fragment.STOPPED:</span><br><span class="line">            <span class="comment">// 执行onReallyStop</span></span><br><span class="line">            <span class="keyword">if</span> (newState &lt; Fragment.STOPPED) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"movefrom STOPPED: "</span> + f);</span><br><span class="line">                f.performReallyStop();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> Fragment.ACTIVITY_CREATED:</span><br><span class="line">            <span class="keyword">if</span> (newState &lt; Fragment.ACTIVITY_CREATED) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"movefrom ACTIVITY_CREATED: "</span> + f);</span><br><span class="line">                <span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Need to save the current view state if not</span></span><br><span class="line">                    <span class="comment">// done already.</span></span><br><span class="line">                    <span class="keyword">if</span> (mHost.onShouldSaveFragmentState(f) &amp;&amp; f.mSavedViewState == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 保存View的状态</span></span><br><span class="line">                        saveFragmentViewState(f);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// onDestroyView</span></span><br><span class="line">                f.performDestroyView();</span><br><span class="line">                <span class="keyword">if</span> (f.mView != <span class="keyword">null</span> &amp;&amp; f.mContainer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Animation anim = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (mCurState &gt; Fragment.INITIALIZING &amp;&amp; !mDestroyed) &#123;</span><br><span class="line">                        anim = loadAnimation(f, transit, <span class="keyword">false</span>,</span><br><span class="line">                                transitionStyle);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (anim != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">final</span> Fragment fragment = f;</span><br><span class="line">                        f.mAnimatingAway = f.mView;</span><br><span class="line">                        f.mStateAfterAnimating = newState;</span><br><span class="line">                        <span class="keyword">final</span> View viewToAnimate = f.mView;</span><br><span class="line">                        anim.setAnimationListener(<span class="keyword">new</span> AnimateOnHWLayerIfNeededListener(</span><br><span class="line">                                viewToAnimate, anim) &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">                                <span class="keyword">super</span>.onAnimationEnd(animation);</span><br><span class="line">                                <span class="keyword">if</span> (fragment.mAnimatingAway != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    fragment.mAnimatingAway = <span class="keyword">null</span>;</span><br><span class="line">                                    moveToState(fragment, fragment.mStateAfterAnimating,</span><br><span class="line">                                            <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        f.mView.startAnimation(anim);</span><br><span class="line">                    &#125;</span><br><span class="line">                    f.mContainer.removeView(f.mView);</span><br><span class="line">                &#125;</span><br><span class="line">                f.mContainer = <span class="keyword">null</span>;</span><br><span class="line">                f.mView = <span class="keyword">null</span>;</span><br><span class="line">                f.mInnerView = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> Fragment.CREATED:</span><br><span class="line">            <span class="keyword">if</span> (newState &lt; Fragment.CREATED) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mDestroyed) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (f.mAnimatingAway != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// The fragment's containing activity is</span></span><br><span class="line">                        <span class="comment">// being destroyed, but this fragment is</span></span><br><span class="line">                        <span class="comment">// currently animating away.  Stop the</span></span><br><span class="line">                        <span class="comment">// animation right now -- it is not needed,</span></span><br><span class="line">                        <span class="comment">// and we can't wait any more on destroying</span></span><br><span class="line">                        <span class="comment">// the fragment.</span></span><br><span class="line">                        View v = f.mAnimatingAway;</span><br><span class="line">                        f.mAnimatingAway = <span class="keyword">null</span>;</span><br><span class="line">                        v.clearAnimation();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (f.mAnimatingAway != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// We are waiting for the fragment's view to finish</span></span><br><span class="line">                    <span class="comment">// animating away.  Just make a note of the state</span></span><br><span class="line">                    <span class="comment">// the fragment now should move to once the animation</span></span><br><span class="line">                    <span class="comment">// is done.</span></span><br><span class="line">                    f.mStateAfterAnimating = newState;</span><br><span class="line">                    newState = Fragment.CREATED;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"movefrom CREATED: "</span> + f);</span><br><span class="line">                    <span class="keyword">if</span> (!f.mRetaining) &#123;</span><br><span class="line">                        <span class="comment">// 调用onDestroy</span></span><br><span class="line">                        f.performDestroy();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    f.mCalled = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// onDetach</span></span><br><span class="line">                    f.onDetach();</span><br><span class="line">                    <span class="keyword">if</span> (!f.mCalled) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Fragment "</span> + f</span><br><span class="line">                                + <span class="string">" did not call through to super.onDetach()"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!keepActive) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!f.mRetaining) &#123;</span><br><span class="line">                            </span><br><span class="line">                            makeInactive(f);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            f.mHost = <span class="keyword">null</span>;</span><br><span class="line">                            f.mParentFragment = <span class="keyword">null</span>;</span><br><span class="line">                            f.mFragmentManager = <span class="keyword">null</span>;</span><br><span class="line">                            f.mChildFragmentManager = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.mState = newState;</span><br></pre></td></tr></table></figure>
<p>生命周期函数不再详述，来重点看下onDetach回到INITIALIZING状态后的makeInactive函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeInactive</span><span class="params">(Fragment f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f.mIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里将该Fragment对应的位置的引用设为null，并未清除</span></span><br><span class="line">    mActive.set(f.mIndex, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (mAvailIndices == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mAvailIndices = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 而创建了一个mAvailIndices来保存销毁的f.mIndex</span></span><br><span class="line">    mAvailIndices.add(f.mIndex);</span><br><span class="line">    <span class="comment">// 根据f的mWho tag设置为inActive状态</span></span><br><span class="line">    mHost.inactivateFragment(f.mWho);</span><br><span class="line">    <span class="comment">// 初始化该Fragment中的所有状态</span></span><br><span class="line">    f.initState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inactivateFragment</span><span class="params">(String who)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Log.v(TAG, "invalidateSupportFragment: who=" + who);</span></span><br><span class="line">    <span class="keyword">if</span> (mAllLoaderManagers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LoaderManagerImpl lm = (LoaderManagerImpl) mAllLoaderManagers.get(who);</span><br><span class="line">        <span class="keyword">if</span> (lm != <span class="keyword">null</span> &amp;&amp; !lm.mRetaining) &#123;</span><br><span class="line">            lm.doDestroy();</span><br><span class="line">            mAllLoaderManagers.remove(who);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> SparseArrayCompat&lt;LoaderInfo&gt; mLoaders = <span class="keyword">new</span> SparseArrayCompat&lt;LoaderInfo&gt;();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (!mRetaining) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Destroying Active in "</span> + <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mLoaders.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            mLoaders.valueAt(i).destroy();</span><br><span class="line">        &#125;</span><br><span class="line">        mLoaders.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Destroying Inactive in "</span> + <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mInactiveLoaders.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        mInactiveLoaders.valueAt(i).destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    mInactiveLoaders.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结以上的生命周期：<br><img src="http://img.blog.csdn.net/20160525164248764" alt="这里写图片描述"><br>所以FragmentTransaction中的几种动态操作Fragment的方法，其中的主要区别都是通过设置moveToState中不同的State来实现的。<br><strong>add:</strong>添加Fragment；<br><strong>remove:</strong>删除Fragment，而且会销毁Fragment实例；注意在removeFragment中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">moveToState(fragment, inactive ? Fragment.INITIALIZING : Fragment.CREATED,</span><br><span class="line">                transition, transitionStyle, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p><strong>replace:</strong>先调用removeFragment,再调用addFragment；<br><strong>hide:</strong>隐藏；设置visibility=gone;<br><strong>show:</strong>显示；通过设置VISIBILITY=VISIBILE来实现。<br><strong>attach：</strong>添加到mAdded数组中，不改变当前状态；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moveToState(fragment, mCurState, transition, transitionStyle, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p><strong>detach：</strong>设置Fragment的状态为CREATED，并未调用onDestory和onDetach来销毁Fragment实例，只是destroyView</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moveToState(fragment, Fragment.CREATED, transition, transitionStyle, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Volley源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/16/Volley源码解析/" class="article-date">
      <time datetime="2016-05-16T09:04:34.825Z" itemprop="datePublished">2016-05-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/16/Volley源码解析/">Volley源码解析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="一、Volley框架图"><a href="#一、Volley框架图" class="headerlink" title="一、Volley框架图"></a>一、Volley框架图</h1><p><img src="http://chuantu.biz/t4/13/1463052200x3738746523.png" alt="enter image description here"></p>
<p>图中是官方给出的Volley工作的流程，见右下角的注释，蓝色表示主线程(main thread)，绿色表示缓存线程(cache thread)，黄色表示网络线程(network threads)；<br>再寻找图中的关键字：queue(RequestQueue)，cache queue，CacheDispatcher，NetworkDispatcher;<br>    流程可简单地描述为：RequestQueue的add()操作将Request添加到缓存队列cache queue中。CacheDispatcher将Request从queue中取出，如果发现缓存中已经保存了相应的结果，则直接从缓存中读取并解析，将response结果回调给主线程。如果缓存中未发现，则将Request添加到网络队列中，进行相应的HTTP transaction等事务处理，将网络请求的结果返回给主线程。</p>
<h1 id="二、Volley系统流程设计图"><a href="#二、Volley系统流程设计图" class="headerlink" title="二、Volley系统流程设计图"></a>二、Volley系统流程设计图</h1><p><img src="http://chuantu.biz/t4/13/1463052272x3738746523.png" alt="enter image description here"><br><img src="http://chuantu.biz/t4/13/1463052295x3738746523.png" alt="enter image description here"><br>DispatchThread(Cache层对应CacheDispatcher,Network层对应NetworkDispatcher),不断从RequestQueue获取用户请求，根据是否已经存储在Cache中分别从内存缓存或服务器中来请求数据，然后交由ResponseDelivery进行结果分发和回调处理。</p>
<h1 id="三、概念小结"><a href="#三、概念小结" class="headerlink" title="三、概念小结"></a>三、概念小结</h1><p>上面涉及到的RequestQueue，ResponseDelivery，CacheDispatcher，NetworkDispatcher等概念，对其作用做了简单总结：<br><strong>Volley                   ：</strong>Volley 对外暴露的 API，类中只有两个函数<br>                                通过 newRequestQueue(…) 函数新建并启动一个请求队列RequestQueue。<br><strong>Request<t>          ：</t></strong>表示一个请求的抽象类。<br>                                StringRequest、JsonRequest、ImageRequest 都是它的子类，表示某种类型的请求。<br>                                也可自定义自己的Request<br><strong>RequestQueue      ：</strong>表示请求队列，一个RequestQueue对象包含：<br>                               一个CacheDispatcher(用于处理走缓存请求的调度线程)、<br>                               一个NetworkDispatcher数组(默认数组大小为4，用于处理走网络请求的调度线程)，<br>                               一个ResponseDelivery(返回结果分发接口)，<br>                               在start() 函数启动时会创建启动CacheDispatcher和NetworkDispatchers。<br><strong>CacheDispatcher   ：</strong>Cache层中的一个线程，用于调度处理缓存的请求。<br>                               启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery去执行后续处理。<br>                               当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入NetworkDispatcher去调度处理。<br><strong>NetworkDispatcher：</strong>NetWork层中的一个线程，用于调度处理走网络的请求。<br>                                启动后会不断从网络请求队列中取请求处理，队列为空则等待，<br>                                请求处理结束则将结果传递给ResponseDelivery去执行后续处理，并判断结果是否要进行缓存。<br><strong>ResponseDelivery ：</strong>返回结果分发接口，在创建RequestQueue对象时进行了初始化<br>                              在目前只有基于ExecutorDelivery的在入参 handler 对应线程内进行分发。<br><strong>HttpStack             ：</strong>处理 Http 请求，返回请求结果。在newRequestQueue中被初始化。<br>                              目前 Volley 中有基于 HttpURLConnection 的HurlStack和 基于 Apache HttpClient 的HttpClientStack。<br>                              上一篇中已经对其如何根据Android版本进行选择做了解析。<br><strong>Network               ：</strong>调用HttpStack处理请求，并将结果转换为可被ResponseDelivery处理的NetworkResponse。<br>                               在newRequestQueue中被初始化<br><strong>Cache                   ：</strong>缓存请求结果，Volley 默认使用的是基于 sdcard 的DiskBasedCache。<br>                  NetworkDispatcher得到请求结果后判断是否需要存储在 Cache，CacheDispatcher会从 Cache 中取缓存结果。<br>下面附上每个类之间的关系图：<br><img src="http://chuantu.biz/t4/13/1463052405x3738746523.png" alt="enter image description here"></p>
<h1 id="四、源码分析："><a href="#四、源码分析：" class="headerlink" title="四、源码分析："></a>四、源码分析：</h1><p>由上图可以得出流程图的入口在于RequestQueue的add()方法，先从RequestQueue的创建看起：</p>
<h2 id="（一）RequestQueue的使用："><a href="#（一）RequestQueue的使用：" class="headerlink" title="（一）RequestQueue的使用："></a>（一）RequestQueue的使用：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RequestQueue mRequestQueue = Volley.newRequestQueue(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>看一下Volley.newRequestQueue的事务逻辑，Volley类中总共就两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Creates a default instance of the worker pool and calls &#123;<span class="doctag">@link</span> RequestQueue#start()&#125; on it.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> newRequestQueue(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的事务主体在这里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Default on-disk cache directory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CACHE_DIR = <span class="string">"volley"</span>;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Creates a default instance of the worker pool and calls &#123;<span class="doctag">@link</span> RequestQueue#start()&#125; on it.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> context A &#123;<span class="doctag">@link</span> Context&#125; to use for creating the cache dir.</span><br><span class="line"> * <span class="doctag">@param</span> stack An &#123;<span class="doctag">@link</span> HttpStack&#125; to use for the network, or null for default.</span><br><span class="line"> * <span class="doctag">@return</span> A started &#123;<span class="doctag">@link</span> RequestQueue&#125; instance.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建cache</span></span><br><span class="line">    File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line"> </span><br><span class="line">    String userAgent = <span class="string">"volley/0"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String packageName = context.getPackageName();</span><br><span class="line">        PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class="number">0</span>);</span><br><span class="line">        userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** 根据博文http://blog.csdn.net/guolin_blog/article/details/12452307，HurlStack是用HttpURLConnection实现的；</span><br><span class="line">        HttpClintStack是由HttpClient实现的；由Android2.3之前的版本宜使用HttpClient，因为其Bug较少；</span><br><span class="line">        Android2.3之后版本宜使用HttpURLConnection，因其较轻量级且API简单；</span><br><span class="line">        故会有此HurlStack和HttpURLConnection的使用分类 */</span></span><br><span class="line">    <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">            stack = <span class="keyword">new</span> HurlStack();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建以stack为参数的Network对象</span></span><br><span class="line">    Network network = <span class="keyword">new</span> BasicNetwork(stack);</span><br><span class="line">    <span class="comment">//创建RequestQueue对象</span></span><br><span class="line">    RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</span><br><span class="line">    queue.start();<span class="comment">//继续向下分析的入口</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-、HurlStack"><a href="#1-、HurlStack" class="headerlink" title="1) 、HurlStack"></a>1) 、HurlStack</h2><p>HurlStack中的部分代码，可以看出其是基于HttpURLClient实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HttpEntity <span class="title">entityFromConnection</span><span class="params">(HttpURLConnection connection)</span></span><br><span class="line"> 对应的HttpClientStack的构造函数可以看出其实基于HttpClient实现的：    </span><br><span class="line"><span class="keyword">public</span> <span class="title">HttpClientStack</span><span class="params">(HttpClient client)</span> </span>&#123;</span><br><span class="line">     mClient = client;</span><br><span class="line"> &#125;</span><br><span class="line"> 而两者都是基于HttpStack接口的：</span><br><span class="line"> <span class="comment">/** An HTTP stack abstraction.*/</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpStack</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">         <span class="keyword">throws</span> IOException, AuthFailureError</span>; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>   由于Android 2.3版本之前，因为HttpURLConnection的BUG较多，HttpClient的API已经较完备，故宜使用HttpClient，故这里版本9之前，选择使用HttpClientStack;<br> Android2.3之后版本，HttpURLConnection不断发展，因其较为轻量级，且API使用较为简单，其也在不断优化性能等，故这里使用基于其的HurlStack;</p>
<h3 id="2-、-Network"><a href="#2-、-Network" class="headerlink" title="2)、 Network"></a>2)、 Network</h3><p>这里引出一个Network对象，看一下构造函数,其用以处理stack传来的网络请求，与主线关系不大，可以不看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * A network performing Volley requests over an &#123;<span class="doctag">@link</span> HttpStack&#125;.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicNetwork</span> <span class="keyword">implements</span> <span class="title">Network</span> </span>&#123;</span><br><span class="line">    ...   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_POOL_SIZE = <span class="number">4096</span>; </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> HttpStack mHttpStack; </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ByteArrayPool mPool;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicNetwork</span><span class="params">(HttpStack httpStack)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If a pool isn't passed in, then build a small default pool that will give us a lot of</span></span><br><span class="line">        <span class="comment">// benefit and not use too much memory.</span></span><br><span class="line">        <span class="keyword">this</span>(httpStack, <span class="keyword">new</span> ByteArrayPool(DEFAULT_POOL_SIZE));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * <span class="doctag">@param</span> httpStack HTTP stack to be used</span><br><span class="line">     * <span class="doctag">@param</span> pool a buffer pool that improves GC performance in copy operations</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicNetwork</span><span class="params">(HttpStack httpStack, ByteArrayPool pool)</span> </span>&#123;</span><br><span class="line">        mHttpStack = httpStack;</span><br><span class="line">        mPool = pool;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存了创建的stack，并创建一个字节数组池（ByteArrayPool）</p>
<h3 id="3-、-RequestQueue"><a href="#3-、-RequestQueue" class="headerlink" title="3)、 RequestQueue"></a>3)、 RequestQueue</h3><p>回到重要的RequestQueue，其构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Number of network request dispatcher threads to start. */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NETWORK_THREAD_POOL_SIZE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(cache, network, threadPoolSize,</span><br><span class="line">               <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span><br><span class="line">    * Creates the worker pool. Processing will not begin until &#123;<span class="doctag">@link</span> #start()&#125; is called.</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> cache A Cache to use for persisting responses to disk</span><br><span class="line">    * <span class="doctag">@param</span> network A Network interface for performing HTTP requests</span><br><span class="line">    * <span class="doctag">@param</span> threadPoolSize Number of network dispatcher threads to create</span><br><span class="line">    * <span class="doctag">@param</span> delivery A ResponseDelivery interface for posting responses and errors</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize,</span><br><span class="line">           ResponseDelivery delivery)</span> </span>&#123;</span><br><span class="line">       mCache = cache;</span><br><span class="line">       mNetwork = network;</span><br><span class="line">       mDispatchers = <span class="keyword">new</span> NetworkDispatcher[threadPoolSize];</span><br><span class="line">       mDelivery = delivery;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在这里创建了之前分析中一个重要的对象：NetworkDispatcher;并且可以看到其类似线程池似的，创建了大小为threadPoolSize的NetworkDispatcher数组；其中的处理逻辑暂且不看，首先可以知道其是一个线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkDispatcher</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure>
<p>总结第一部RequestQueue中add方法所作的工作：<br>1）创建了Cache；<br>2）创建了HttpStack，并由HttpStack为基创建了Network对象；<br>3）创建RequestQueue对象，并在RequestQueue构造函数中创建了大小为threadPoolSize的NetworkDispatcher数组（注并未创建相应NetworkDispatcher对象）<br>4）创建ResponseDelivery对象（new ExecutorDelivery(new Handler(Looper.getMainLooper()))）<br>5）调用RequestQueue.start()函数</p>
<h2 id="（二）从start方法看起："><a href="#（二）从start方法看起：" class="headerlink" title="（二）从start方法看起："></a>（二）从start方法看起：</h2><h3 id="1、RequestQueue-start"><a href="#1、RequestQueue-start" class="headerlink" title="1、RequestQueue.start():"></a>1、RequestQueue.start():</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Starts the dispatchers in this queue.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">publicvoid <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stop();  <span class="comment">// Make sure any currently running dispatchers are stopped.</span></span><br><span class="line">    <span class="comment">// Create the cache dispatcher and start it.</span></span><br><span class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">    mCacheDispatcher.start();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Create network dispatchers (and corresponding threads) up to the pool size.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</span><br><span class="line">                mCache, mDelivery);</span><br><span class="line">        mDispatchers[i] = networkDispatcher;</span><br><span class="line">        networkDispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Stops the cache and network dispatchers.*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCacheDispatcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCacheDispatcher.quit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDispatchers[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mDispatchers[i].quit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>start()依然在做初始化，可以看到创建了一个CacheDispatcher线程（它也是继承Thread的）；又创建了threadPoolSize(默认为4)个NetworkDispatcher线程；则start()后加上主线程，一共有六个线程在运行；回顾之前的流程图，黄色、绿色、蓝色对应的线程都已集齐；黄色线程和绿色线程运行下后台一直在等待网络Request并进行dispatch；<br>    则下面学习的主体落到了两个主要的处理线程CacheDispatcher和NetworkDispathcer上来；试了下，直接看源代码有些困难；先把之前使用Volley的流程走一遍；创建好RequestQueue之后，是创建自己的Request，前面文章已经做了学习；而后是将request通过RequestQueue的add()方法添加进来；</p>
<h3 id="2、RequestQueue-add"><a href="#2、RequestQueue-add" class="headerlink" title="2、RequestQueue.add()"></a>2、RequestQueue.add()</h3><p>下面看一下RequestQueue.add()方法，它是前面流程图运行的入口函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * The set of all requests currently being processed by this RequestQueue. A Request</span><br><span class="line">    * will be in this set if it is waiting in any queue or currently being processed by any dispatcher.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Request&gt; mCurrentRequests = <span class="keyword">new</span> HashSet&lt;Request&gt;();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span><br><span class="line">    * Adds a Request to the dispatch queue.</span><br><span class="line">    * <span class="doctag">@param</span> request The request to service</span><br><span class="line">    * <span class="doctag">@return</span> The passed-in request</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Request <span class="title">add</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Tag the request as belonging to this queue and add it to the set of current requests.</span></span><br><span class="line">       request.setRequestQueue(<span class="keyword">this</span>);  <span class="comment">//见附I Request设置其对应的RequestQueue</span></span><br><span class="line">       <span class="keyword">synchronized</span> (mCurrentRequests) &#123; <span class="comment">//mCurrentRequests表示当前该RequestQueue持有的requests，由HashSet来保存</span></span><br><span class="line">           mCurrentRequests.add(request);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 为新添加的request进行一系列的初始化设置</span></span><br><span class="line">       request.setSequence(getSequenceNumber());</span><br><span class="line">       request.addMarker(<span class="string">"add-to-queue"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 见附II 判断request是否允许缓存</span></span><br><span class="line">       <span class="keyword">if</span> (!request.shouldCache()) &#123;</span><br><span class="line">           mNetworkQueue.add(request);</span><br><span class="line">           <span class="keyword">return</span> request;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//request如果允许缓存 </span></span><br><span class="line">       <span class="comment">//Insert request into stage if there's already a request with the same cache key in flight.</span></span><br><span class="line">       <span class="keyword">synchronized</span> (mWaitingRequests) &#123;  <span class="comment">// 见附III</span></span><br><span class="line">           String cacheKey = request.getCacheKey();</span><br><span class="line">           <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</span><br><span class="line">               <span class="comment">// There is already a request in flight. Queue up.</span></span><br><span class="line">               Queue&lt;Request&gt; stagedRequests = mWaitingRequests.get(cacheKey);</span><br><span class="line">               <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&gt;();</span><br><span class="line">               &#125;</span><br><span class="line">               stagedRequests.add(request);</span><br><span class="line">               mWaitingRequests.put(cacheKey, stagedRequests);</span><br><span class="line">               <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">                   VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Insert 'null' queue for this cacheKey, indicating there is now a request in</span></span><br><span class="line">               <span class="comment">// flight.</span></span><br><span class="line">               mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</span><br><span class="line">               mCacheQueue.add(request);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> request;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-：mCurrentRequests"><a href="#1-：mCurrentRequests" class="headerlink" title="1)：mCurrentRequests"></a>1)：mCurrentRequests</h3><p>mCurrentRequests维护了一个正在进行中，尚未完成的请求集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = <span class="keyword">new</span> HashSet&lt;Request&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="2-、Request-setRequestQueue"><a href="#2-、Request-setRequestQueue" class="headerlink" title="2)、Request.setRequestQueue()"></a>2)、Request.setRequestQueue()</h3><p>字面上可以看出是Request设置其对应的RequestQueue，简单的setter函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The request queue this request is associated with. */</span></span><br><span class="line"><span class="keyword">private</span> RequestQueue mRequestQueue;   </span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Associates this request with the given queue. The request queue will be notified when this</span><br><span class="line"> * request has finished.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestQueue</span><span class="params">(RequestQueue requestQueue)</span> </span>&#123;</span><br><span class="line">    mRequestQueue = requestQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-、request-shouldCache"><a href="#3-、request-shouldCache" class="headerlink" title="3)、request.shouldCache()"></a>3)、request.shouldCache()</h3><p>用以判断该request是否允许缓存（默认允许，可使用setShouldCache(false)来禁止缓存）；如果不允许缓存，则直接将其添加到mNetworkQueue中返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/** The queue of requests that are actually going out to the network. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&gt; mNetworkQueue = <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&gt;();</span><br><span class="line">RequetQueue其实并不是一个真正的Queue，真正存储Request供处理线程去读取和操作的Queue是mNetworkQueue,其类型是PriorityBlockingQueue；</span><br></pre></td></tr></table></figure>
<h3 id="4-、mWaitingRequests"><a href="#4-、mWaitingRequests" class="headerlink" title="4)、mWaitingRequests"></a>4)、mWaitingRequests</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Staging area for requests that already have a duplicate request in flight.</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> *     &lt;li&gt;containsKey(cacheKey) indicates that there is a request in flight for the given cache</span><br><span class="line"> *          key.&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;get(cacheKey) returns waiting requests for the given cache key. The in flight request</span><br><span class="line"> *          is &lt;em&gt;not&lt;/em&gt; contained in that list. Is null if no requests are staged.&lt;/li&gt;</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Queue&lt;Request&gt;&gt; mWaitingRequests = <span class="keyword">new</span> HashMap&lt;String, Queue&lt;Request&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>维护了一个等待请求的集合，如果一个请求正在被处理并且可以被缓存，后续的相同 url 的请求，将进入此等待队列。<br>函数：<br><strong>containsKey(cacheKey):</strong>  true表明对于给定的cache key，已经存在了一个request<br>         <strong>get(cacheKey)            :</strong>  返回对于给定cache key对应的waiting requests，即Queue<request><br>其存储request的整个工作流程为：<br><img src="http://chuantu.biz/t4/13/1463053030x3738746523.png" alt="enter image description here"><br>1）对于每个新add的request,先获取它的CacheKey;<br>2）如果当前mWaitingRequests不存在当前cachekey，则会put(cacheKey, null);null表示当前Map中已经存在了一个对应cacheKey的请求；<br>3）如果mWaitingRequests已经存在了对应的cacheKey，通过get(Key)获取cacheKey对应的Queue;如果Queue为null，由第二步知，当前cacheKey仅仅对应一个request,则新建对应的Map Value值——Queue<request>（这里由LinkedList来实现），然后添加进去即可；<br>附IV）mCacheQueue和mNetworkQueue是想对应存在的：<br>mCacheQueue 放在缓存请求队列中的 Request，将通过缓存获取数据；<br>mNetworkQueue放在网络请求队列中的 Request，将通过网络获取数据。</request></request></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue = <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue = <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure>
<h1 id="五、CacheDispatcher："><a href="#五、CacheDispatcher：" class="headerlink" title="五、CacheDispatcher："></a>五、CacheDispatcher：</h1><p>一个线程，用于调度处理走缓存的请求。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给ResponseDelivery 去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入NetworkDispatcher去调度处理。</p>
<h2 id="（一）成员变量"><a href="#（一）成员变量" class="headerlink" title="（一）成员变量"></a>（一）成员变量</h2><p>看源码前，先看一下从其成员变量与处理流程：</p>
<h3 id="1-成员变量"><a href="#1-成员变量" class="headerlink" title="(1). 成员变量"></a>(1). 成员变量</h3><p><strong>BlockingQueue<request<?>&gt; mCacheQueue</request<?></strong>     缓存请求队列<br><strong>BlockingQueue<request<?>&gt; mNetworkQueue</request<?></strong> 网络请求队列<br><strong>Cache mCache</strong>                                                缓存类，代表了一个可以获取请求结果，存储请求结果的缓存<br><strong>ResponseDelivery mDelivery</strong>                        请求结果传递类</p>
<h3 id="2-处理流程图"><a href="#2-处理流程图" class="headerlink" title="(2). 处理流程图"></a>(2). 处理流程图</h3><p><img src="http://chuantu.biz/t4/13/1463053184x3738746523.png" alt="enter image description here"></p>
<h3 id="3-源码："><a href="#3-源码：" class="headerlink" title="(3)源码："></a>(3)源码：</h3><h4 id="1、构造函数："><a href="#1、构造函数：" class="headerlink" title="1、构造函数："></a>1、构造函数：</h4><p>一系列赋值初始化操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Creates a new cache triage dispatcher thread.  You must call &#123;<span class="doctag">@link</span> #start()&#125;</span><br><span class="line">    * in order to begin processing.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CacheDispatcher</span><span class="params">(BlockingQueue&lt;Request&gt; cacheQueue, BlockingQueue&lt;Request&gt; networkQueue,</span><br><span class="line">           Cache cache, ResponseDelivery delivery)</span> </span>&#123;</span><br><span class="line">       mCacheQueue = cacheQueue;</span><br><span class="line">       mNetworkQueue = networkQueue;</span><br><span class="line">       mCache = cache;</span><br><span class="line">       mDelivery = delivery;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 提到使用CacheDispatcher时一定要调用start()方法；而CacheDispatcher的创建与线程start都是在RequestQueue中的add()函数中实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the cache dispatcher and start it.</span></span><br><span class="line">   mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">   mCacheDispatcher.start();</span><br></pre></td></tr></table></figure>
<h4 id="2、看起执行逻辑："><a href="#2、看起执行逻辑：" class="headerlink" title="2、看起执行逻辑："></a>2、看起执行逻辑：</h4><p>既然是线程，重点看其run()函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置优先级</span></span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">    <span class="comment">// Make a blocking call to initialize the cache.</span></span><br><span class="line">    <span class="comment">//这里的Cache其实是DiskBasedCache，见附I</span></span><br><span class="line">    mCache.initialize();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*****循环处理逻辑******/</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从缓存队列 mCacheQueue中取出一个Request；如果mCacheQueue为空，则阻塞进行忙等待</span></span><br><span class="line">            <span class="keyword">final</span> Request request = mCacheQueue.take();</span><br><span class="line">            request.addMarker(<span class="string">"cache-queue-take"</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 如果取出的Request请求已经被取消，则直接finish,处理下一个request</span></span><br><span class="line">            <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">                request.finish(<span class="string">"cache-discard-canceled"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 尝试从缓存中获取request对应的结果</span></span><br><span class="line">            Cache.Entry entry = mCache.get(request.getCacheKey());</span><br><span class="line">           </span><br><span class="line">            <span class="comment">//为null，表示该cacheKey对应缓存结果不存在，则直接将request添加到mNetworkQueue中</span></span><br><span class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                request.addMarker(<span class="string">"cache-miss"</span>);</span><br><span class="line">                mNetworkQueue.put(request);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//如果缓存结果存在，但是已过期，同样也是将request添加到mNetworkQueue中</span></span><br><span class="line">            <span class="keyword">if</span> (entry.isExpired()) &#123;</span><br><span class="line">                request.addMarker(<span class="string">"cache-hit-expired"</span>);</span><br><span class="line">                request.setCacheEntry(entry);</span><br><span class="line">                mNetworkQueue.put(request);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 如果命中(hit)找到了对应的缓存结果，则解析其数据为Response并返回给该request</span></span><br><span class="line">            request.addMarker(<span class="string">"cache-hit"</span>);</span><br><span class="line">            Response&lt;?&gt; response = request.parseNetworkResponse(</span><br><span class="line">                    <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">            request.addMarker(<span class="string">"cache-hit-parsed"</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 还需判断缓存结果是否时间过久已经不新鲜，是否需要refresh</span></span><br><span class="line">            <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</span><br><span class="line">              <span class="comment">// 不需要Refresh,则直接由mDelivery提交给相应的request</span></span><br><span class="line">                mDelivery.postResponse(request, response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果已经不新鲜，mDelivery依旧提交结果给request，</span></span><br><span class="line">              <span class="comment">// 但同时要将Request传递给mNetworkQueue进行新鲜度验证</span></span><br><span class="line">                request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</span><br><span class="line">                request.setCacheEntry(entry);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// Mark the response as intermediate.</span></span><br><span class="line">                response.intermediate = <span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// Post the intermediate response back to the user and have</span></span><br><span class="line">                <span class="comment">// the delivery then forward the request along to the network.</span></span><br><span class="line">                mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            mNetworkQueue.put(request);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// We may have been interrupted because it was time to quit.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的Cache实际是DiskBasedCache，mCache.initialize()实际上调用的是DiskBasedCache.initialize():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Initializes the DiskBasedCache by scanning for all files currently in the</span><br><span class="line">    * specified root directory. Creates the root directory if necessary.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h1 id="六、NetworkDispatcher"><a href="#六、NetworkDispatcher" class="headerlink" title="六、NetworkDispatcher"></a>六、NetworkDispatcher</h1><p>一个线程，用于调度处理网络的请求。启动后会不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给 ResponseDelivery 去执行后续处理，并判断结果是否要进行缓存。</p>
<h2 id="1-成员变量-1"><a href="#1-成员变量-1" class="headerlink" title="(1). 成员变量"></a>(1). 成员变量</h2><p><strong>BlockingQueue<request<?>&gt; mQueue</request<?></strong> 网络请求队列<br><strong>Network mNetwork</strong>                             网络类，代表了一个可以执行请求的网络<br><strong>Cache mCache</strong>                                    缓存类，代表了一个可以获取请求结果，存储请求结果的缓存<br><strong>ResponseDelivery mDelivery</strong>           请求结果传递类，可以传递请求的结果或者错误到调用者</p>
<h2 id="2-处理流程图-1"><a href="#2-处理流程图-1" class="headerlink" title="(2). 处理流程图"></a>(2). 处理流程图</h2><p><img src="http://chuantu.biz/t4/13/1463053414x3738746523.png" alt="enter image description here"></p>
<h2 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="(3).构造函数"></a>(3).构造函数</h2><p>先看其构造函数，与CacheDispatcher的逻辑处理大致相同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Creates a new network dispatcher thread.  You must call &#123;<span class="doctag">@link</span> #start()&#125;</span><br><span class="line">    * in order to begin processing.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NetworkDispatcher</span><span class="params">(BlockingQueue&lt;Request&gt; queue,</span><br><span class="line">           Network network, Cache cache,</span><br><span class="line">           ResponseDelivery delivery)</span> </span>&#123;</span><br><span class="line">       mQueue = queue;</span><br><span class="line">       mNetwork = network;</span><br><span class="line">       mCache = cache;</span><br><span class="line">       mDelivery = delivery;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-其run-函数："><a href="#4-其run-函数：" class="headerlink" title="(4).其run()函数："></a>(4).其run()函数：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//设为后台进程</span></span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">    Request request;</span><br><span class="line">    <span class="comment">/*********循环处理逻辑********/</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从网络请求队列中取出request，同理mQueue为空时，也是忙等待</span></span><br><span class="line">            request = mQueue.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            request.addMarker(<span class="string">"network-queue-take"</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 如果取出的Request请求已经被取消，则直接finish,处理下一个request</span></span><br><span class="line">            <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">                request.finish(<span class="string">"network-discard-cancelled"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Tag the request (if API &gt;= 14)</span></span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">                TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 通过Network执行Request，获得NetworkResponse，故网络请求的处理逻辑应该都封装在了Network中</span></span><br><span class="line">            NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class="line">            request.addMarker(<span class="string">"network-http-complete"</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 用来验证新鲜度，（notModified=304）响应为304且请求已经有了Response传输情况</span></span><br><span class="line">            <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">                request.finish(<span class="string">"not-modified"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 将NetworkResponse解析为Response</span></span><br><span class="line">            Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">            request.addMarker(<span class="string">"network-parse-complete"</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 如果request可以被缓存，并且其请求实体补位空，则添加到mCache中</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Only update cache metadata instead of entire record for 304s.</span></span><br><span class="line">            <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">                request.addMarker(<span class="string">"network-cache-written"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 传输Response</span></span><br><span class="line">            request.markDelivered();</span><br><span class="line">            mDelivery.postResponse(request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</span><br><span class="line">            parseAndDeliverNetworkError(request, volleyError);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</span><br><span class="line">            mDelivery.postError(request, <span class="keyword">new</span> VolleyError(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="七、Network"><a href="#七、Network" class="headerlink" title="七、Network"></a>七、Network</h1><p>在NetworkDispatcher中需要处理的网络请求，由下面进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br></pre></td></tr></table></figure>
<p>看一下mNetwork的定义：（定义在NetworkDispatcher中）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/** The network interface for processing requests. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Network mNetwork;</span><br><span class="line">NetworkDispatcher.mNetwork初始化发生在RequestQueue.start()中：</span><br><span class="line">    NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</span><br><span class="line">         mCache, mDelivery);</span><br></pre></td></tr></table></figure>
<p>而RequestQueue.mNetwork是在其构造函数中传入的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize,</span><br><span class="line">        ResponseDelivery delivery)</span> </span>&#123;</span><br><span class="line">    mCache = cache;</span><br><span class="line">    mNetwork = network;</span><br><span class="line">    mDispatchers = <span class="keyword">new</span> NetworkDispatcher[threadPoolSize];</span><br><span class="line">    mDelivery = delivery;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由前面分析知RequestQueue的构建是在Volley.newRequestQueue中实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建以stack为参数的Network对象</span></span><br><span class="line">Network network = <span class="keyword">new</span> BasicNetwork(stack);</span><br><span class="line"><span class="comment">//创建RequestQueue对象</span></span><br><span class="line">RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</span><br><span class="line">queue.start();<span class="comment">//继续向下分析的入口</span></span><br></pre></td></tr></table></figure>
<p> 可以看出mNetwork其实是BasicNetwork对象。<br>    则NetworkResponse中mNetwork实际上调用的是BasicNetwork.performRequest(),这是一个专门用来处理网络请求的函数，其作用为调用HttpStack处理请求，并将结果转换为可被ResponseDelivery处理的NetworkResponse。<br>看一下其源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">         HttpResponse httpResponse = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</span><br><span class="line">         Map&lt;String, String&gt; responseHeaders = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">/** 忽略网络处理的细节*/</span></span><br><span class="line">             <span class="comment">// Gather headers.</span></span><br><span class="line">             Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">             addCacheHeaders(headers, request.getCacheEntry());</span><br><span class="line">            </span><br><span class="line">             <span class="comment">/**执行网络请求</span><br><span class="line">              * 这里调用了HttpStack.performRequest，并得到一个HttpResponse返回结果*/</span></span><br><span class="line">             httpResponse = mHttpStack.performRequest(request, headers);</span><br><span class="line">            </span><br><span class="line">             StatusLine statusLine = httpResponse.getStatusLine();</span><br><span class="line">             <span class="keyword">int</span> statusCode = statusLine.getStatusCode();</span><br><span class="line">             responseHeaders = convertHeaders(httpResponse.getAllHeaders());</span><br><span class="line"> </span><br><span class="line">             <span class="comment">/**新鲜度验证：</span><br><span class="line">              * 304 Not Modified：客户端有缓冲的文件并发出了一个条件性的请求</span><br><span class="line">              * （一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。</span><br><span class="line">              * 服务器告诉客户，原来缓冲的文档还可以继续使用。*/</span></span><br><span class="line">             <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</span><br><span class="line">               <span class="comment">/** 解析成NetworkResponse，返回*/</span></span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED,</span><br><span class="line">                         request.getCacheEntry().data, responseHeaders, <span class="keyword">true</span>);</span><br><span class="line">             &#125;</span><br><span class="line"> </span><br><span class="line">             <span class="comment">// 判断responses是否有实体信息，一些响应如204，并不包含content，所以需要验证</span></span><br><span class="line">             <span class="keyword">if</span> (httpResponse.getEntity() != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//实体信息转化成byte[]</span></span><br><span class="line">                 responseContents = entityToBytes(httpResponse.getEntity());</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 无实体信息情况</span></span><br><span class="line">               responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">             &#125;</span><br><span class="line"> </span><br><span class="line">             <span class="comment">// 超时情况处理.</span></span><br><span class="line">             <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</span><br><span class="line">             logSlowRequests(requestLifetime, request, responseContents, statusLine);</span><br><span class="line"> </span><br><span class="line">             <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class="keyword">false</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">             attemptRetryOnException(<span class="string">"socket"</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">         &#125; <span class="keyword">catch</span> (ConnectTimeoutException e) &#123;</span><br><span class="line">             attemptRetryOnException(<span class="string">"connection"</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">         &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Bad URL "</span> + request.getUrl(), e);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">             ...</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 总结一下Network.performRequest所做的工作：<br>1、由传入的HttpStack对象执行网络请求：mHttpStack.performRequest()<br>2、解析响应结果，将HttpResponse解析成NetworkResponse;<br>3、对返回结果进行新鲜度验证（304）<br>4、将response的实体信息转化为byte数组<br>5、超时情况处理，如果发生超时，认证失败等错误，进行重试操作(attemptRetryOnException)，直到成功、抛出异常(不满足重试策略等)结束。</p>
<p>attemptRetryOnException()是根据重试策略进行请求重试操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">   * Attempts to prepare the request for a retry. If there are no more attempts remaining in the</span><br><span class="line">   * request's retry policy, a timeout exception is thrown.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attemptRetryOnException</span><span class="params">(String logPrefix, Request&lt;?&gt; request,</span><br><span class="line">          VolleyError exception)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">      RetryPolicy retryPolicy = request.getRetryPolicy();</span><br><span class="line">      <span class="keyword">int</span> oldTimeout = request.getTimeoutMs();</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          retryPolicy.retry(exception);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (VolleyError e) &#123;</span><br><span class="line">          request.addMarker(</span><br><span class="line">                  String.format(<span class="string">"%s-timeout-giveup [timeout=%s]"</span>, logPrefix, oldTimeout));</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">      request.addMarker(String.format(<span class="string">"%s-retry [timeout=%s]"</span>, logPrefix, oldTimeout));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="八、HttpClientStack、HurlStack"><a href="#八、HttpClientStack、HurlStack" class="headerlink" title="八、HttpClientStack、HurlStack"></a>八、HttpClientStack、HurlStack</h1><p>据上面源码知，网络请求处理的逻辑实际上是交由传进来的参数HttpStack进行处理。前面已经分析过，Android2.3之前使用 HttpClientStack，之后使用HurlStack；</p>
<h2 id="1、先看两者的父类HttpStack"><a href="#1、先看两者的父类HttpStack" class="headerlink" title="1、先看两者的父类HttpStack:"></a>1、先看两者的父类HttpStack:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Performs an HTTP request with the given parameters.</span><br><span class="line">     * &lt;p&gt;A GET request is sent if request.getPostBody() == null. A POST request is sent otherwise,</span><br><span class="line">     * and the Content-Type header is set to request.getPostBodyContentType().&lt;/p&gt;</span><br><span class="line">     * <span class="doctag">@param</span> request the request to perform</span><br><span class="line">     * <span class="doctag">@param</span> 发起请求之前，添加额外的请求 Headers &#123;<span class="doctag">@link</span> Request#getHeaders()&#125;</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、HttpClientStack-使用HttpClient来实现"><a href="#2、HttpClientStack-使用HttpClient来实现" class="headerlink" title="2、HttpClientStack(使用HttpClient来实现)"></a>2、HttpClientStack(使用HttpClient来实现)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError </span>&#123;</span><br><span class="line">    HttpUriRequest httpRequest = createHttpRequest(request, additionalHeaders);<span class="comment">//见附一</span></span><br><span class="line">    addHeaders(httpRequest, additionalHeaders);</span><br><span class="line">    addHeaders(httpRequest, request.getHeaders());</span><br><span class="line">    onPrepareRequest(httpRequest);<span class="comment">// Nothing.空函数，用于重写；该函数在request被excute之前被调用</span></span><br><span class="line">    <span class="comment">//一些网络设置</span></span><br><span class="line">    HttpParams httpParams = httpRequest.getParams();</span><br><span class="line">    <span class="keyword">int</span> timeoutMs = request.getTimeoutMs();</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Reevaluate this connection timeout based on more wide-scale</span></span><br><span class="line">    <span class="comment">// data collection and possibly different for wifi vs. 3G.</span></span><br><span class="line">    HttpConnectionParams.setConnectionTimeout(httpParams, <span class="number">5000</span>);</span><br><span class="line">    HttpConnectionParams.setSoTimeout(httpParams, timeoutMs);</span><br><span class="line">    <span class="keyword">return</span> mClient.execute(httpRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1）：createHttpRequest函数："><a href="#1）：createHttpRequest函数：" class="headerlink" title="1）：createHttpRequest函数："></a>1）：createHttpRequest函数：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 根据传进来的request来构造合适的HttpUriRequest</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> HttpUriRequest <span class="title">createHttpRequest</span><span class="params">(Request&lt;?&gt; request,</span><br><span class="line">        Map&lt;String, String&gt; additionalHeaders)</span> <span class="keyword">throws</span> AuthFailureError </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (request.getMethod()) &#123;</span><br><span class="line">        <span class="keyword">case</span> Method.DEPRECATED_GET_OR_POST: &#123;</span><br><span class="line">            <span class="comment">// This is the deprecated way that needs to be handled for backwards compatibility.</span></span><br><span class="line">            <span class="comment">// If the request's post body is null, then the assumption is that the request is</span></span><br><span class="line">            <span class="comment">// GET.  Otherwise, it is assumed that the request is a POST.</span></span><br><span class="line">            <span class="keyword">byte</span>[] postBody = request.getPostBody();</span><br><span class="line">            <span class="keyword">if</span> (postBody != <span class="keyword">null</span>) &#123;</span><br><span class="line">                HttpPost postRequest = <span class="keyword">new</span> HttpPost(request.getUrl());</span><br><span class="line">                postRequest.addHeader(HEADER_CONTENT_TYPE, request.getPostBodyContentType());</span><br><span class="line">                HttpEntity entity;</span><br><span class="line">                entity = <span class="keyword">new</span> ByteArrayEntity(postBody);</span><br><span class="line">                postRequest.setEntity(entity);</span><br><span class="line">                <span class="keyword">return</span> postRequest;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HttpGet(request.getUrl());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/***********一般较多使用的是POST与GET，其等同于HttpClient的一般使用流程***************/</span></span><br><span class="line">        <span class="keyword">case</span> Method.GET:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HttpGet(request.getUrl());</span><br><span class="line">        <span class="keyword">case</span> Method.DELETE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HttpDelete(request.getUrl());</span><br><span class="line">        <span class="keyword">case</span> Method.POST: &#123;</span><br><span class="line">            HttpPost postRequest = <span class="keyword">new</span> HttpPost(request.getUrl());</span><br><span class="line">            <span class="comment">//这里就看到了前面实现Request时，重写getBodyContentType（）函数的意义</span></span><br><span class="line">            postRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());</span><br><span class="line">            setEntityIfNonEmptyBody(postRequest, request);</span><br><span class="line">            <span class="keyword">return</span> postRequest;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Method.PUT: &#123;</span><br><span class="line">            HttpPut putRequest = <span class="keyword">new</span> HttpPut(request.getUrl());</span><br><span class="line">            putRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());</span><br><span class="line">            setEntityIfNonEmptyBody(putRequest, request);</span><br><span class="line">            <span class="keyword">return</span> putRequest;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown request method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、HurlStack-由HttpURLConnection来实现"><a href="#3、HurlStack-由HttpURLConnection来实现" class="headerlink" title="3、HurlStack(由HttpURLConnection来实现)"></a>3、HurlStack(由HttpURLConnection来实现)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError </span>&#123;</span><br><span class="line">    String url = request.getUrl();</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.putAll(request.getHeaders());</span><br><span class="line">    map.putAll(additionalHeaders);</span><br><span class="line">    <span class="comment">//UrlRewriter见附一</span></span><br><span class="line">    <span class="keyword">if</span> (mUrlRewriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String rewritten = mUrlRewriter.rewriteUrl(url);</span><br><span class="line">        <span class="keyword">if</span> (rewritten == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="function">thrownew <span class="title">IOException</span><span class="params">(<span class="string">"URL blocked by rewriter: "</span> + url)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        url = rewritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**************HttpURLConnection的一般使用流程*******************/</span></span><br><span class="line">    URL parsedUrl = <span class="keyword">new</span> URL(url);</span><br><span class="line">    HttpURLConnection connection = openConnection(parsedUrl, request);</span><br><span class="line">    <span class="keyword">for</span> (String headerName : map.keySet()) &#123;</span><br><span class="line">        connection.addRequestProperty(headerName, map.get(headerName));</span><br><span class="line">    &#125;</span><br><span class="line">    setConnectionParametersForRequest(connection, request);</span><br><span class="line">    <span class="comment">// Initialize HttpResponse with data from the HttpURLConnection.</span></span><br><span class="line">    ProtocolVersion protocolVersion = <span class="keyword">new</span> ProtocolVersion(<span class="string">"HTTP"</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> responseCode = connection.getResponseCode();</span><br><span class="line">    <span class="keyword">if</span> (responseCode == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// -1 is returned by getResponseCode() if the response code could not be retrieved.</span></span><br><span class="line">        <span class="comment">// Signal to the caller that something was wrong with the connection.</span></span><br><span class="line">        <span class="function">thrownew <span class="title">IOException</span><span class="params">(<span class="string">"Could not retrieve response code from HttpUrlConnection."</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StatusLine responseStatus = <span class="keyword">new</span> BasicStatusLine(protocolVersion,</span><br><span class="line">            connection.getResponseCode(), connection.getResponseMessage());</span><br><span class="line">    BasicHttpResponse response = <span class="keyword">new</span> BasicHttpResponse(responseStatus);</span><br><span class="line">    response.setEntity(entityFromConnection(connection));</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, List&lt;String&gt;&gt; header : connection.getHeaderFields().entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (header.getKey() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Header h = <span class="keyword">new</span> BasicHeader(header.getKey(), header.getValue().get(<span class="number">0</span>));</span><br><span class="line">            response.addHeader(h);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1）：UrlRewriter"><a href="#1）：UrlRewriter" class="headerlink" title="1）：UrlRewriter"></a>1）：UrlRewriter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 对URLs在使用前进行重写转换*/</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UrlRewriter</span> </span>&#123;</span><br><span class="line">     <span class="comment">/**</span><br><span class="line">      * Returns a URL to use instead of the provided one, or null to indicate</span><br><span class="line">      * this URL should not be used at all.</span><br><span class="line">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">rewriteUrl</span><span class="params">(String originalUrl)</span></span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>参数mUrlRewriter通过HttpStack的构造函数传入进来，故可以自行进行定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HurlStack</span><span class="params">(UrlRewriter urlRewriter, SSLSocketFactory sslSocketFactory)</span> </span>&#123;</span><br><span class="line">    mUrlRewriter = urlRewriter;</span><br><span class="line">    mSslSocketFactory = sslSocketFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="九、NetworkResponse"><a href="#九、NetworkResponse" class="headerlink" title="九、NetworkResponse"></a>九、NetworkResponse</h1><p>回到起点NetworkDispatcher（Thread）中的run()函数，其中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br></pre></td></tr></table></figure>
<p>下面继续看NetworkResponse的源码：<br>NetworkResponse类很简单，仅是用以在多个类中传递数据，其成员变量：</p>
<h2 id="1）成员变量"><a href="#1）成员变量" class="headerlink" title="1）成员变量"></a>1）成员变量</h2><p><strong>int statusCode Http</strong> 响应状态码<br><strong>byte[] data Body</strong> 数据<br><strong>Map<string, string=""> headers</string,></strong> 响应 Headers<br><strong>boolean notModified</strong> 表示是否为 304 响应<br><strong>long networkTimeMs</strong> 请求耗时</p>
<h2 id="2）其主体只为几个构造函数："><a href="#2）其主体只为几个构造函数：" class="headerlink" title="2）其主体只为几个构造函数："></a>2）其主体只为几个构造函数：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NetworkResponse</span><span class="params">(<span class="keyword">int</span> statusCode, <span class="keyword">byte</span>[] data, Map&lt;String, String&gt; headers,</span><br><span class="line">         <span class="keyword">boolean</span> notModified)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.statusCode = statusCode;</span><br><span class="line">     <span class="keyword">this</span>.data = data;</span><br><span class="line">     <span class="keyword">this</span>.headers = headers;</span><br><span class="line">     <span class="keyword">this</span>.notModified = notModified;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">NetworkResponse</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(HttpStatus.SC_OK, data, Collections.&lt;String, String&gt;emptyMap(), <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">NetworkResponse</span><span class="params">(<span class="keyword">byte</span>[] data, Map&lt;String, String&gt; headers)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(HttpStatus.SC_OK, data, headers, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>3）回顾一下前面分析的设计NetworkResponse的类之间数据的传递关系：<br><img src="http://chuantu.biz/t4/13/1463053821x3738746523.png" alt="enter image description here"></p>
<p>这里的主体是根据NetworkDispatcher.run()函数进行分析的<br>0、函数中调用Network.performRequest();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br></pre></td></tr></table></figure>
<p> 而Network.performRequest()是基于HttpStack实现的；<br>1、HttpClientStack与HurlStack（分别基于HttpClient与HttpURLConnection实现）中的public HttpResponse performRequest()函数返回HttpResponse ；<br>2、Network（实际为BasicNetwork）中performRequest()方法，使用1中的两个HttpStack类，获取到其返回值HttpResponse，然后将其解析成为NetworkResponse;<br>3、Request中 <code>abstract protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response);</code><br>    将NetworkResponse解析成Response;<br>    而该函数的调用是在NetworkDispatcher中的run()函数中调用的；<br>4、在NetworkDispatcher.run(）的最后一步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mDelivery.postResponse(request, response);</span><br></pre></td></tr></table></figure>
<p>将response传递给了ResponseDelivery<br>后面继续看Delivery的逻辑；<br>ResponseDelivery mDelivery的实际类型是ExecutorDelivery：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(cache, network, threadPoolSize,</span><br><span class="line">            <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make an Executor that just wraps the handler.</span></span><br><span class="line">    mResponsePoster = <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">            handler.post(command);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到很简单，就是使用主线程的Looper构建一个Handler，下面所有的post操作都是调用这个Handler来执行Runnable;<br>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">    request.markDelivered();</span><br><span class="line">    request.addMarker(<span class="string">"post-response"</span>);</span><br><span class="line">    mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将传递来的Response转化为ResponseDeliveryRunnable ，显然这是一个Runnable;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDeliveryRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Request mRequest;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Response mResponse;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mRunnable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseDeliveryRunnable</span><span class="params">(Request request, Response response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">        mRequest = request;</span><br><span class="line">        mResponse = response;</span><br><span class="line">        mRunnable = runnable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If this request has canceled, finish it and don't deliver.</span></span><br><span class="line">        <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</span><br><span class="line">            mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deliver a normal response or error, depending.</span></span><br><span class="line">        <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</span><br><span class="line">            mRequest.deliverResponse(mResponse.result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mRequest.deliverError(mResponse.error);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this is an intermediate response, add a marker, otherwise we're done</span></span><br><span class="line">        <span class="comment">// and the request can be finished.</span></span><br><span class="line">        <span class="keyword">if</span> (mResponse.intermediate) &#123;</span><br><span class="line">            mRequest.addMarker(<span class="string">"intermediate-response"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mRequest.finish(<span class="string">"done"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we have been provided a post-delivery runnable, run it.</span></span><br><span class="line">        <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mRunnable.run();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个子线程中，转而调用 Request来deliverResponse：<br>以StringRequest为例，来看这个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mListener.onResponse(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个Listener就是自己在定义Request的时候声明的ResponseListener，可以看到这个Listener工作在子线程中，所以如果要更新界面，注意使用Handler把消息传递主线程进行处理。</p>
<h1 id="十、Volley图片加载的实现"><a href="#十、Volley图片加载的实现" class="headerlink" title="十、Volley图片加载的实现"></a>十、Volley图片加载的实现</h1><p>Volley的图片加载主要还是基于上面的原理来实现的，具体如下：<br><strong>ImageLoader的使用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ImageLoader</span></span><br><span class="line">imageLoader = <span class="keyword">new</span> ImageLoader(httpUtils.getRequestQueue(), imageCache);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ImageLoader</span><span class="params">(RequestQueue queue, ImageCache imageCache)</span> </span>&#123;</span><br><span class="line">    mRequestQueue = queue;</span><br><span class="line">    mCache = imageCache;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面的ImageCache是自定义的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取最大内存缓存大小</span></span><br><span class="line"><span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);</span><br><span class="line">MAX_CACHE_SIZE = maxMemory / <span class="number">8</span>; <span class="comment">// 定义为应用最大缓存的1/8</span></span><br><span class="line"></span><br><span class="line">mImageLruCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(MAX_CACHE_SIZE)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String url, Bitmap bitmap)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bitmap.getRowBytes() * bitmap.getHeight() / <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建ImageCache</span></span><br><span class="line">imageCache = <span class="keyword">new</span> ImageLoader.ImageCache() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putBitmap</span><span class="params">(String url, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">        mImageLruCache.put(url, bitmap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmap</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mImageLruCache.get(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用LruCache来实现ImageCache接口，实现图片的内存缓存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmap</span><span class="params">(String url)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putBitmap</span><span class="params">(String url, Bitmap bitmap)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载图片时的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imageListener = ImageLoader.getImageListener(myImageView, default_pg, failed_pg);</span><br><span class="line">imageLoader.get(imageUrl, imageListener);</span><br></pre></td></tr></table></figure>
<p>来到ImageLoader#get:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ImageContainer <span class="title">get</span><span class="params">(String requestUrl, <span class="keyword">final</span> ImageListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(requestUrl, listener, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ImageContainer <span class="title">get</span><span class="params">(String requestUrl, ImageListener imageListener,</span><br><span class="line">                          <span class="keyword">int</span> maxWidth, <span class="keyword">int</span> maxHeight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(requestUrl, imageListener, maxWidth, maxHeight, ImageView.ScaleType.CENTER_INSIDE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ImageContainer <span class="title">get</span><span class="params">(String requestUrl, ImageListener imageListener,</span><br><span class="line">                          <span class="keyword">int</span> maxWidth, <span class="keyword">int</span> maxHeight, ImageView.ScaleType scaleType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果操作不是在主线程，则直接抛出异常</span></span><br><span class="line">    throwIfNotOnMainThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为图片的URL创建一个特定的cacheKey，注意这个cache还和图片的大小及scaleType相关</span></span><br><span class="line">    <span class="keyword">final</span> String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight, scaleType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里会使用自定义的LruCache去获取一个Bitmap实例</span></span><br><span class="line">    Bitmap cachedBitmap = mCache.getBitmap(cacheKey);</span><br><span class="line">    <span class="comment">// 如果缓存中已经存在，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (cachedBitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Return the cached bitmap.</span></span><br><span class="line">        ImageContainer container = <span class="keyword">new</span> ImageContainer(cachedBitmap, requestUrl, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        imageListener.onResponse(container, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存中不存在，则进行获取</span></span><br><span class="line">    ImageContainer imageContainer =</span><br><span class="line">            <span class="keyword">new</span> ImageContainer(<span class="keyword">null</span>, requestUrl, cacheKey, imageListener);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知Observer这时可以使用默认的图片</span></span><br><span class="line">    imageListener.onResponse(imageContainer, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否已经有了一个相同的请求在等待</span></span><br><span class="line">    BatchedImageRequest request = mInFlightRequests.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If it is, add this request to the list of listeners.</span></span><br><span class="line">        request.addContainer(imageContainer);</span><br><span class="line">        <span class="keyword">return</span> imageContainer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Request，重复之前的流程</span></span><br><span class="line">    Request&lt;Bitmap&gt; newRequest = makeImageRequest(requestUrl, maxWidth, maxHeight, scaleType,</span><br><span class="line">            cacheKey);</span><br><span class="line"></span><br><span class="line">    mRequestQueue.add(newRequest);</span><br><span class="line">    mInFlightRequests.put(cacheKey,</span><br><span class="line">            <span class="keyword">new</span> BatchedImageRequest(newRequest, imageContainer));</span><br><span class="line">    <span class="keyword">return</span> imageContainer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理逻辑大致和前面的addRequest相同，首先判断缓存中是否已经存在该url对应的bitmap，如果存在直接返回；如果不存在，先判断是否已经有了一个相同的请求在等待，如果是，把这个请求添加到监听者链表中；如果不存在，则创建一个Request<bitmap>，添加到RequestQueue中，从网络中去获取；从网络中获取的流程和前面分析的相同。</bitmap></p>
<p><strong>先来看Request<bitmap>:</bitmap></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Request&lt;Bitmap&gt; <span class="title">makeImageRequest</span><span class="params">(String requestUrl, <span class="keyword">int</span> maxWidth, <span class="keyword">int</span> maxHeight,</span><br><span class="line">        ScaleType scaleType, <span class="keyword">final</span> String cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImageRequest(requestUrl, <span class="keyword">new</span> Listener&lt;Bitmap&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Bitmap response)</span> </span>&#123;</span><br><span class="line">            onGetImageSuccess(cacheKey, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, maxWidth, maxHeight, scaleType, Config.RGB_565, <span class="keyword">new</span> ErrorListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">            onGetImageError(cacheKey, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上返回一个ImageRequest类型，来看其请求成功的响应：即把获得的图片存储到缓存中；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onGetImageSuccess</span><span class="params">(String cacheKey, Bitmap response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把获取到的图片存储到缓存中</span></span><br><span class="line">    mCache.putBitmap(cacheKey, response);</span><br><span class="line">    <span class="comment">// 可以看到如果是多个相同请求在等待，则可以同时进行更新处理</span></span><br><span class="line">    BatchedImageRequest request = mInFlightRequests.remove(cacheKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Update the response bitmap.</span></span><br><span class="line">        request.mResponseBitmap = response;</span><br><span class="line">        <span class="comment">// Send the batched response</span></span><br><span class="line">        batchResponse(cacheKey, request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后NetWork执行的结果会封装成NetWorkResponse，通过ResponseDelivery进行转发，这个类最后会调用Request中deliverResponse方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(Bitmap response)</span> </span>&#123;</span><br><span class="line">    mListener.onResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个Listener就是最初定义的ImageListener:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ImageListener <span class="title">getImageListener</span><span class="params">(<span class="keyword">final</span> ImageView view,</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> defaultImageResId, <span class="keyword">final</span> <span class="keyword">int</span> errorImageResId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImageListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (errorImageResId != <span class="number">0</span>) &#123;</span><br><span class="line">                view.setImageResource(errorImageResId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(ImageContainer response, <span class="keyword">boolean</span> isImmediate)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (response.getBitmap() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                view.setImageBitmap(response.getBitmap());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (defaultImageResId != <span class="number">0</span>) &#123;</span><br><span class="line">                view.setImageResource(defaultImageResId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里最终给View空间设置了图片，以上就是Volley实现图片加载的流程。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Picasso源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/15/Picasso源码解析/" class="article-date">
      <time datetime="2016-05-15T09:05:09.139Z" itemprop="datePublished">2016-05-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/15/Picasso源码解析/">Picasso源码解析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="一、Picasso使用："><a href="#一、Picasso使用：" class="headerlink" title="一、Picasso使用："></a>一、Picasso使用：</h2><p><strong>gradle:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.squareup.picasso:picasso:2.5.2&apos;</span><br></pre></td></tr></table></figure>
<p><strong>使用：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Picasso.with(this).load(&quot;http://...../photo3.jpg&quot;).into(myImg);</span><br></pre></td></tr></table></figure>
<p><strong>自定义的使用方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Picasso picasso = <span class="keyword">new</span> Picasso.Builder(<span class="keyword">this</span>)</span><br><span class="line">        .memoryCache(<span class="keyword">new</span> LruCache())       <span class="comment">// 设置自定义的内存缓存</span></span><br><span class="line">        .addRequestHandler(requestHandler) <span class="comment">// 设置自定义的RequestHandler</span></span><br><span class="line">        .defaultBitmapConfig(bitmapConfig) <span class="comment">// 设置自定义的Bitmap Config</span></span><br><span class="line">        .downloader(okHttpDownloader)      <span class="comment">// 设置自定义的Downloader</span></span><br><span class="line">        .executor(executorService)         <span class="comment">// 设置自定义的线程池</span></span><br><span class="line">        .requestTransformer(transformer)   <span class="comment">// 设置自定义的Transformor</span></span><br><span class="line">        .listener(listener)                <span class="comment">// 添加Listener进行监听</span></span><br><span class="line">        .build();</span><br><span class="line">picasso.load(File/resId/Uri/String)</span><br><span class="line">        .resize(width, height)</span><br><span class="line">        .centerInside()</span><br><span class="line">        .into(imageView);</span><br></pre></td></tr></table></figure>
<h1 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h1><h2 id="（一）Picasso-with进行一系列初始化"><a href="#（一）Picasso-with进行一系列初始化" class="headerlink" title="（一）Picasso.with进行一系列初始化"></a>（一）Picasso.with进行一系列初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Picasso <span class="title">with</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Picasso.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> Builder(context).build();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的多线程单例模式；同时使用Buidler模式来创建Picasso实例。</p>
<h3 id="1、Picasso-Builder-build"><a href="#1、Picasso-Builder-build" class="headerlink" title="1、Picasso.Builder#build:"></a>1、Picasso.Builder#build:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Start building a new &#123;<span class="doctag">@link</span> Picasso&#125; instance. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Context must not be null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.context = context.getApplicationContext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Downloader downloader;</span><br><span class="line"><span class="keyword">private</span> ExecutorService service;</span><br><span class="line"><span class="keyword">private</span> Cache cache;</span><br><span class="line"><span class="keyword">private</span> Listener listener;</span><br><span class="line"><span class="keyword">private</span> RequestTransformer transformer;</span><br><span class="line"><span class="keyword">private</span> List&lt;RequestHandler&gt; requestHandlers;</span><br><span class="line"><span class="keyword">private</span> Bitmap.Config defaultBitmapConfig;</span><br><span class="line"><span class="comment">/** Create the &#123;<span class="doctag">@link</span> Picasso&#125; instance. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Picasso <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Context context = <span class="keyword">this</span>.context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为这一系列变量进行默认初始化</span></span><br><span class="line">    <span class="comment">// Downloader执行实际的下载业务，返回Response</span></span><br><span class="line">    <span class="keyword">if</span> (downloader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        downloader = Utils.createDefaultDownloader(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内存缓存，可以看到默认的是LruCache</span></span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> LruCache(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程池，执行网络请求的地方</span></span><br><span class="line">    <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">        service = <span class="keyword">new</span> PicassoExecutorService();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// request发送前进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (transformer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        transformer = RequestTransformer.IDENTITY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用以统计</span></span><br><span class="line">    Stats stats = <span class="keyword">new</span> Stats(cache);</span><br><span class="line">    <span class="comment">// 进行Request以及Response的转发</span></span><br><span class="line">    Dispatcher dispatcher = <span class="keyword">new</span> Dispatcher(context, service, HANDLER, downloader, cache, stats);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Picasso</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,</span><br><span class="line">            defaultBitmapConfig, indicatorsEnabled, loggingEnabled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里为许多重要类进行了默认初始化，后面获取图片使用到的都是这些默认的变量，当然这些变量也都可以进行自定义；<br><strong>Downloader：</strong>默认实现是OkHttpDownloader，Picasso是对OkHttp的封装，它的网络请求以及对本地Cache的请求都是直接通过OkHttp来实现的；Downloader是实现本地磁盘查询，以及发起网络请求的类；<br><strong>Cache：</strong>内存缓存；这里采用的LruCache，也可以自行定义。缓存的是进行网络请求后，大小等裁剪之后的图片资源。<br><strong>PicassoExecutorService：</strong> Picasso之中的线程池，默认核心线程为3个，没有非核心线程；但也会根据手机当前的网络状态进行适时改变，比如WIFI状态的核心线程就为4个，而4G，3G，2G状态下的线程数分别为3,2,1个；<br><strong>Stats：</strong>进行一些数据统计，比如图片下载命中率等。<br><strong>RequestTransformer:</strong>用来预处理Request，必须修改域名等<br><strong>Dispatcher：</strong>用以分发任务，它通过启动了一个DispatcherThread线程，然后创建一个用来处理消息的DispatcherHandler，该Handler的数据处理是在DispatcherThread中进行的。<br><strong>RequestHandler：</strong>  后面将会看到，该对象用来持有一个具体的Request，所有Request最终其实都是由其对应的RequestHandler来进行处理的。</p>
<p>根据后面具体使用情况再做分析：</p>
<h3 id="2、Picasso-load"><a href="#2、Picasso-load" class="headerlink" title="2、Picasso#load:"></a>2、Picasso#load:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RequestCreator(<span class="keyword">this</span>, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (path.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Path must not be empty."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> load(Uri.parse(path));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestCreator(<span class="keyword">this</span>, uri, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建一个<strong>RequestCreator</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Picasso picasso;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Request.Builder data;</span><br><span class="line"></span><br><span class="line">RequestCreator(Picasso picasso, Uri uri, <span class="keyword">int</span> resourceId) &#123;</span><br><span class="line">    <span class="keyword">if</span> (picasso.shutdown) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"Picasso instance already shut down. Cannot submit new requests."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.picasso = picasso;</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="keyword">new</span> Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>data对应创建一个Request的Builder，这个Request中封装了了相应的请求信息，传入了请求加载图片的URI，已经resourceId，以及默认显示图片的配置信息。<br>进而一般调用into将图片加载到相应的控件中。</p>
<h3 id="3、RequestCreator-into："><a href="#3、RequestCreator-into：" class="headerlink" title="3、RequestCreator#into："></a>3、RequestCreator#into：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestCreator.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">into</span><span class="params">(ImageView target)</span> </span>&#123;</span><br><span class="line">    into(target, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">into</span><span class="params">(ImageView target, Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> started = System.nanoTime();</span><br><span class="line">    <span class="comment">// 盘算是否是在主线程，如果不是则会抛出异常</span></span><br><span class="line">    checkMain();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Target must not be null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断reqeust是否合法，即存在URI或者对应的resId，否则会取消该请求</span></span><br><span class="line">    <span class="keyword">if</span> (!data.hasImage()) &#123;</span><br><span class="line">        picasso.cancelRequest(target);</span><br><span class="line">        <span class="keyword">if</span> (setPlaceholder) &#123;</span><br><span class="line">            setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要延期执行</span></span><br><span class="line">    <span class="keyword">if</span> (deferred) &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经设置了宽高大小</span></span><br><span class="line">        <span class="keyword">if</span> (data.hasSize()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fit cannot be used with resize."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取目标控件的宽高参数</span></span><br><span class="line">        <span class="keyword">int</span> width = target.getWidth();</span><br><span class="line">        <span class="keyword">int</span> height = target.getHeight();</span><br><span class="line">        <span class="comment">// 表示当前控件并未加载到界面上（宽或高为0）</span></span><br><span class="line">        <span class="keyword">if</span> (width == <span class="number">0</span> || height == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (setPlaceholder) &#123;</span><br><span class="line">                setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 生成DeferredRequestCreator，加入相应队列进行处理</span></span><br><span class="line">            picasso.defer(target, <span class="keyword">new</span> DeferredRequestCreator(<span class="keyword">this</span>, target, callback));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置Request.Builder中的宽高参数大小</span></span><br><span class="line">        data.resize(width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Request</span></span><br><span class="line">    Request request = createRequest(started);</span><br><span class="line">    <span class="comment">// 获取request对应的key</span></span><br><span class="line">    String requestKey = createKey(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据策略判断是够需要跳过读取MemoryCache</span></span><br><span class="line">    <span class="keyword">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123; <span class="comment">// 尝试从MemoryCache中获取Bitmap</span></span><br><span class="line">        <span class="comment">// 根据Requeskey来获取相应的Bitmap</span></span><br><span class="line">        Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);</span><br><span class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果从MemoryCache中获取到相应的bitmap，则取消request</span></span><br><span class="line">            picasso.cancelRequest(target);</span><br><span class="line">            <span class="comment">// 设置图片</span></span><br><span class="line">            setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);</span><br><span class="line">            <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</span><br><span class="line">                log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), <span class="string">"from "</span> + MEMORY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用回调callback的onSuccess函数</span></span><br><span class="line">            <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                callback.onSuccess();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果从MemoryCache获取图片失败，或者根据缓存策略直接跳过读取MemoryCache，则设置默认图片</span></span><br><span class="line">    <span class="keyword">if</span> (setPlaceholder) &#123;</span><br><span class="line">        setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建ImageViewAction，Action里面包含了一次请求所需要的所有信息</span></span><br><span class="line">    Action action =</span><br><span class="line">            <span class="keyword">new</span> ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,</span><br><span class="line">                    errorDrawable, requestKey, tag, callback, noFade);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将action入队列</span></span><br><span class="line">    picasso.enqueueAndSubmit(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个图片加载流程和一般的三级缓存加载流程相似，下图已经介绍地很清晰：<br><img src="http://img.blog.csdn.net/20160525164643032" alt="这里写图片描述"><br>上面主要是尝试从MemoryCache中获取对应Bitmap，如果获取失败，再创建Action，通过将Action入队列，然后从本地Cache以及网络上去获取该图片。<br>接着上面enqueueAndSubmit继续分析</p>
<h3 id="4、Picasso-enqueueAndSubmit："><a href="#4、Picasso-enqueueAndSubmit：" class="headerlink" title="4、Picasso#enqueueAndSubmit："></a>4、Picasso#enqueueAndSubmit：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Picasso.java</span></span><br><span class="line"><span class="keyword">final</span> Map&lt;Object, Action&gt; targetToAction;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueueAndSubmit</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据Action获取对应的Target</span></span><br><span class="line">    Object target = action.getTarget();</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; targetToAction.get(target) != action) &#123;</span><br><span class="line">        <span class="comment">// This will also check we are on the main thread.</span></span><br><span class="line">        <span class="comment">// 取消该target对应的以前的请求</span></span><br><span class="line">        cancelExistingRequest(target);</span><br><span class="line">        <span class="comment">// 添加当前请求</span></span><br><span class="line">        targetToAction.put(target, action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 提交action</span></span><br><span class="line">    submit(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>targetToAction是一个Map，它存储的是Target对应的Action，以Target为相应key值。<br>当新添加一个action时，首先尝试取消该Action对应的Target之前的Action请求，然后将新Action添加到Map中；<br>然后提交action请求；</p>
<p>先来看下取消一个Request的函数<strong>cancelExistingReqeust</strong>，常用的cancelReqeust也是直接调用该函数实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Picasso.java</span></span><br><span class="line"><span class="keyword">final</span> Map&lt;Object, Action&gt; targetToAction;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelExistingRequest</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否在主线程中进行</span></span><br><span class="line">    checkMain();</span><br><span class="line">    <span class="comment">// 从Map中移除该target对应action</span></span><br><span class="line">    Action action = targetToAction.remove(target);</span><br><span class="line">    <span class="comment">// 如果该Target之前存在对应的action</span></span><br><span class="line">    <span class="keyword">if</span> (action != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 则调用该action的cancel函数进行取消</span></span><br><span class="line">        action.cancel();</span><br><span class="line">        <span class="comment">// 并且调用Dispatcher进行分发cancel请求</span></span><br><span class="line">        dispatcher.dispatchCancel(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于ImageView类型的Target</span></span><br><span class="line">    <span class="keyword">if</span> (target <span class="keyword">instanceof</span> ImageView) &#123;</span><br><span class="line">        ImageView targetImageView = (ImageView) target;</span><br><span class="line">        <span class="comment">// 前面分析提到可能有需要延迟操作的请求，它是通过添加到DeferredRequestCreator来实现的，这里的需要将其cancel掉</span></span><br><span class="line">        DeferredRequestCreator deferredRequestCreator =</span><br><span class="line">                targetToDeferredRequestCreator.remove(targetImageView);</span><br><span class="line">        <span class="keyword">if</span> (deferredRequestCreator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            deferredRequestCreator.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>简单的cancel逻辑：</strong><br>这里依然也需要先判断事件处理是否是在主线程中进行的；<br>然后尝试从targetToAction中删除该Target中对应的Action，如果该Action确实存在，则调用cancel函数取消该Action，并且调用Dispatcher来分发该cancel请求；<br>对应ImageView类型的target，前面分析中提到当需要defer即延迟的请求时，是通过创建DeferredReqeustCreator，并添加到一个Map中来实现的，这里同理应将其删除并cancel掉；<br>再来看看其cancel函数：</p>
<h4 id="1）Action-cancel"><a href="#1）Action-cancel" class="headerlink" title="1）Action#cancel:"></a>1）Action#cancel:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ImageViewAction.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageViewAction</span> <span class="keyword">extends</span> <span class="title">Action</span>&lt;<span class="title">ImageView</span>&gt; </span>&#123;</span><br><span class="line">    Callback callback;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.cancel();</span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            callback = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Action.java</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> cancelled;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cancelled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和Volley这些差不多，通过设置一个cancel标志来实现。</p>
<h4 id="2）-Dispatcher-dispatchCacnel"><a href="#2）-Dispatcher-dispatchCacnel" class="headerlink" title="2） Dispatcher#dispatchCacnel"></a>2） Dispatcher#dispatchCacnel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchCancel</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">    handler.sendMessage(handler.obtainMessage(REQUEST_CANCEL, action));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分发逻辑较为简单，使用Handler来实现的；<br>这里来具体来看下Dispatcher的定义，来确定handler的定义；Dispathcer是在创建Picasso时默认创建了一个Dispathcer实例，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Picasso.java</span></span><br><span class="line">Dispatcher dispatcher = <span class="keyword">new</span> Dispatcher(context, service, HANDLER, downloader, cache, stats);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Handler HANDLER = <span class="keyword">new</span> Handler(Looper.getMainLooper()) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而Dispatcher中的Handler并不是这个Handler，而是又做了一个封装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.handler = <span class="keyword">new</span> DispatcherHandler(dispatcherThread.getLooper(), <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DispatcherHandler</span><span class="params">(Looper looper, Dispatcher dispatcher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">        <span class="keyword">this</span>.dispatcher = dispatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> REQUEST_SUBMIT: &#123;</span><br><span class="line">                Action action = (Action) msg.obj;</span><br><span class="line">                dispatcher.performSubmit(action);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> REQUEST_CANCEL: &#123;</span><br><span class="line">                Action action = (Action) msg.obj;</span><br><span class="line">                dispatcher.performCancel(action);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            .......</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                Picasso.HANDLER.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Unknown handler message received: "</span> + msg.what);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dispathcer的作用是通过handler将相应的操作逻辑转换到自己Looper对应线程中去实现，然后调用performCancel去具体处理该Action；<br>下面接着来看<strong>Dispatcher#performCancel：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher.java</span></span><br><span class="line"><span class="keyword">final</span> Map&lt;String, BitmapHunter&gt; hunterMap;</span><br><span class="line"><span class="keyword">final</span> Set&lt;Object&gt; pausedTags;</span><br><span class="line"><span class="keyword">final</span> Map&lt;Object, Action&gt; pausedActions;</span><br><span class="line"><span class="keyword">final</span> Map&lt;Object, Action&gt; failedActions;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performCancel</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取Action对应的key</span></span><br><span class="line">    String key = action.getKey();</span><br><span class="line">    <span class="comment">// 根据key获取对应的BitmapHunter</span></span><br><span class="line">    BitmapHunter hunter = hunterMap.get(key);</span><br><span class="line">    <span class="comment">// 取消执行bitmapHunter</span></span><br><span class="line">    <span class="keyword">if</span> (hunter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        hunter.detach(action);</span><br><span class="line">        <span class="keyword">if</span> (hunter.cancel()) &#123;</span><br><span class="line">            hunterMap.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从暂停map中删除对应action</span></span><br><span class="line">    <span class="keyword">if</span> (pausedTags.contains(action.getTag())) &#123;</span><br><span class="line">        pausedActions.remove(action.getTarget());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从失败map中删除对应Action</span></span><br><span class="line">    Action remove = failedActions.remove(action.getTarget());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 逻辑较为简单，主要从各个可能存储该Action的集合中将其删除，如果已经有Bitmap在执行，则调用去cancel去处理。里面引出一个重要的类BitmapHunter，下面将会进行介绍。</p>
<p>如果没有从MemoryCache中获取到Bitmap（分两种情况，一直是根据policy直接跳过从MemoryCache中获取；另一种是MemoryCache中并没有对应的Bitmap缓存），这是将会来到submit(Action);</p>
<h3 id="5、Picasso-submit"><a href="#5、Picasso-submit" class="headerlink" title="5、Picasso#submit:"></a>5、Picasso#submit:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Picasso.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">    dispatcher.dispatchSubmit(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和前面类似。继续调用Dispatcher来分发submit事件，因此可以看出Dispatcher的主要作用是对Picasso（主线程）中发送的事件进行分发处理；<br>和dispatchCancel类似，接下来会来到performSubmit:</p>
<h3 id="6、Dispatcher-performSubmit"><a href="#6、Dispatcher-performSubmit" class="headerlink" title="6、Dispatcher#performSubmit:"></a>6、Dispatcher#performSubmit:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Set&lt;Object&gt; pausedTags;</span><br><span class="line"><span class="keyword">final</span> Map&lt;Object, Action&gt; failedActions;</span><br><span class="line"><span class="keyword">final</span> Map&lt;Object, Action&gt; pausedActions;</span><br><span class="line"><span class="keyword">final</span> Map&lt;String, BitmapHunter&gt; hunterMap;</span><br><span class="line"><span class="keyword">final</span> ExecutorService service;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performSubmit</span><span class="params">(Action action, <span class="keyword">boolean</span> dismissFailed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果Action已经暂停</span></span><br><span class="line">    <span class="keyword">if</span> (pausedTags.contains(action.getTag())) &#123;</span><br><span class="line">        pausedActions.put(action.getTarget(), action);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应的BitmapHunter</span></span><br><span class="line">    BitmapHunter hunter = hunterMap.get(action.getKey());</span><br><span class="line">    <span class="keyword">if</span> (hunter != <span class="keyword">null</span>) &#123; <span class="comment">// 如果对应hunter不为null，表示前面有同样的请求在进行，因此这是可以合并请求</span></span><br><span class="line">        hunter.attach(action);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否已经关闭</span></span><br><span class="line">    <span class="keyword">if</span> (service.isShutdown()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建BitmapHunter</span></span><br><span class="line">    hunter = forRequest(action.getPicasso(), <span class="keyword">this</span>, cache, stats, action);</span><br><span class="line">    <span class="comment">// 将Bitmap提交到线程池</span></span><br><span class="line">    hunter.future = service.submit(hunter);</span><br><span class="line">    <span class="comment">// 保存Bitmap</span></span><br><span class="line">    hunterMap.put(action.getKey(), hunter);</span><br><span class="line">    <span class="keyword">if</span> (dismissFailed) &#123;</span><br><span class="line">        failedActions.remove(action.getTarget());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的工作逻辑如下图：<br><img src="http://img.blog.csdn.net/20160525164703880" alt="这里写图片描述"><br>当遇到相同的Action时，Picasso会通过BitmapHunter的Attach来合并相同的请求，避免同一个请求重复进行；简单看下attach：</p>
<h4 id="1）Bitmap-attach："><a href="#1）Bitmap-attach：" class="headerlink" title="1）Bitmap#attach："></a>1）Bitmap#attach：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BitmapHunter.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Action action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> loggingEnabled = picasso.loggingEnabled;</span><br><span class="line">    Request request = action.request;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果BitmapHunter对应的action仍未设置，则直接设置action返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.action == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.action = action;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个保存相同Action的ArrayList</span></span><br><span class="line">    <span class="keyword">if</span> (actions == <span class="keyword">null</span>) &#123;</span><br><span class="line">        actions = <span class="keyword">new</span> ArrayList&lt;Action&gt;(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    actions.add(action);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得Action的优先级</span></span><br><span class="line">    Picasso.Priority actionPriority = action.getPriority();</span><br><span class="line">    <span class="comment">// 如果新添加Action的Priority优先级高于原来的优先级，则更新该Bitmaphunter的优先级</span></span><br><span class="line">    <span class="keyword">if</span> (actionPriority.ordinal() &gt; priority.ordinal()) &#123;</span><br><span class="line">        priority = actionPriority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到合并相同请求，则是在BitmapHunter中维护一个Action列表actions;<br>当新添加Action的Priority优先级高于原来的优先级，则更新该BitmapHunter的优先级大小；<br>这里在来关注下Picasso中的优先级问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * The priority of a request.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@see</span> RequestCreator#priority(Priority)</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Priority &#123;</span><br><span class="line">  LOW,</span><br><span class="line">  NORMAL,</span><br><span class="line">  HIGH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Picasso中Priority是个枚举类，总共分为LOW,NORMAL,HIGH三个等级；而相对应地，Volley中Request的Priority则多了一个IMMEDIATE等级；顺便提下Volley中Reqeust可以根据Priority进行执行的原因是因为其实现了Comparable接口：<br><strong>Volley#Reqeust:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Request</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Priority &#123;</span><br><span class="line">        LOW,</span><br><span class="line">        NORMAL,</span><br><span class="line">        HIGH,</span><br><span class="line">        IMMEDIATE</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Request&lt;T&gt; other)</span> </span>&#123;</span><br><span class="line">        Priority left = <span class="keyword">this</span>.getPriority();</span><br><span class="line">        Priority right = other.getPriority();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// High-priority requests are "lesser" so they are sorted to the front.</span></span><br><span class="line">        <span class="comment">// Equal priorities are sorted by sequence number to provide FIFO ordering.</span></span><br><span class="line">        <span class="keyword">return</span> left == right ?</span><br><span class="line">                <span class="keyword">this</span>.mSequence - other.mSequence :</span><br><span class="line">                right.ordinal() - left.ordinal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2）ExecutorService："><a href="#2）ExecutorService：" class="headerlink" title="2）ExecutorService："></a>2）ExecutorService：</h4><p>再来看下线程池ExecutorService，它是在Picasso创建之初Builder时就创建的，默认的实现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Picasso.Builder</span></span><br><span class="line"><span class="keyword">private</span> ExecutorService service;</span><br><span class="line"><span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">    service = <span class="keyword">new</span> PicassoExecutorService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-1）来看PicassoExecutorService："><a href="#2-1）来看PicassoExecutorService：" class="headerlink" title="2.1）来看PicassoExecutorService："></a>2.1）来看PicassoExecutorService：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PicassoExecutorService</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PicassoExecutorService</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认的线程池的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_THREAD_COUNT = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    PicassoExecutorService() &#123;</span><br><span class="line">        <span class="keyword">super</span>(DEFAULT_THREAD_COUNT, DEFAULT_THREAD_COUNT, <span class="number">0</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> PriorityBlockingQueue&lt;Runnable&gt;(), <span class="keyword">new</span> Utils.PicassoThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Picasso提供的是个默认核心线程数为3个，没有非核心线程（最大的线程数目也是为3），任务队列为PriorityBlockingQueue的线程池；<br>Picasso有个有趣的地方是，它可以根据当前应用的网络状态实时调整线程池中的线程数目：</p>
<h5 id="2-2）PicassoExecutorService-adjustThreadCount："><a href="#2-2）PicassoExecutorService-adjustThreadCount：" class="headerlink" title="2.2）PicassoExecutorService#adjustThreadCount："></a>2.2）PicassoExecutorService#adjustThreadCount：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据网络状况调整线程池中线程的数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustThreadCount</span><span class="params">(NetworkInfo info)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (info == <span class="keyword">null</span> || !info.isConnectedOrConnecting()) &#123;</span><br><span class="line">        setThreadCount(DEFAULT_THREAD_COUNT);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (info.getType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ConnectivityManager.TYPE_WIFI:</span><br><span class="line">        <span class="keyword">case</span> ConnectivityManager.TYPE_WIMAX:</span><br><span class="line">        <span class="keyword">case</span> ConnectivityManager.TYPE_ETHERNET:</span><br><span class="line">            setThreadCount(<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ConnectivityManager.TYPE_MOBILE:</span><br><span class="line">            <span class="keyword">switch</span> (info.getSubtype()) &#123;</span><br><span class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_LTE:  <span class="comment">// 4G</span></span><br><span class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_HSPAP:</span><br><span class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EHRPD:</span><br><span class="line">                    setThreadCount(<span class="number">3</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_UMTS: <span class="comment">// 3G</span></span><br><span class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_CDMA:</span><br><span class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EVDO_0:</span><br><span class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EVDO_A:</span><br><span class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EVDO_B:</span><br><span class="line">                    setThreadCount(<span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_GPRS: <span class="comment">// 2G</span></span><br><span class="line">                <span class="keyword">case</span> TelephonyManager.NETWORK_TYPE_EDGE:</span><br><span class="line">                    setThreadCount(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    setThreadCount(DEFAULT_THREAD_COUNT);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            setThreadCount(DEFAULT_THREAD_COUNT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreadCount</span><span class="params">(<span class="keyword">int</span> threadCount)</span> </span>&#123;</span><br><span class="line">    setCorePoolSize(threadCount);</span><br><span class="line">    setMaximumPoolSize(threadCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即WIFI状态下线程数目为4，4G状态下为3,3G状态下为2,2G转态下线程池中只有一个线程；</p>
<p>再来看线程池中创建线程的Factory，看看Picasso的线程池中的线程有何特别之处：</p>
<h5 id="2-3）PicassoThreadFactory："><a href="#2-3）PicassoThreadFactory：" class="headerlink" title="2.3）PicassoThreadFactory："></a>2.3）PicassoThreadFactory：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PicassoThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"NullableProblems"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PicassoThread(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PicassoThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PicassoThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Process.setThreadPriority(THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PicassoThread简单的Thread，线程优先级为后台线程；<br>再看service提交submit一个BitmapHunter时的操作逻辑：</p>
<h5 id="2-4）PicassoExecutorService-submit"><a href="#2-4）PicassoExecutorService-submit" class="headerlink" title="2.4）PicassoExecutorService#submit:"></a>2.4）PicassoExecutorService#submit:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PicassoExecutorService</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PicassoExecutorService</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        PicassoFutureTask ftask = <span class="keyword">new</span> PicassoFutureTask((BitmapHunter) task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将BitmapHunter封装成PicassoFutureTask进行execute</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PicassoFutureTask</span> <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">BitmapHunter</span>&gt;</span><br><span class="line">            <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">PicassoFutureTask</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> BitmapHunter hunter;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PicassoFutureTask</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(hunter, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">this</span>.hunter = hunter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PicassoFutureTask other)</span> </span>&#123;</span><br><span class="line">            Picasso.Priority p1 = hunter.getPriority();</span><br><span class="line">            Picasso.Priority p2 = other.hunter.getPriority();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// High-priority requests are "lesser" so they are sorted to the front.</span></span><br><span class="line">            <span class="comment">// Equal priorities are sorted by sequence number to provide FIFO ordering.</span></span><br><span class="line">            <span class="keyword">return</span> (p1 == p2 ? hunter.sequence - other.hunter.sequence : p2.ordinal() - p1.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在submit中将BitmapHunter封装成一个FutureTask进行execute;<br>PicassoFutureTask可以实现对当前Runnbale运行结果的查看及控制；同期它提供了和Volley一个样的Priority一样的优先级机制。</p>
<p>回到前面performSubmit的执行逻辑，接下来会创建以及执行BitmapHunter，下面重点介绍BitmapHunter，它是一个任务具体执行的整体：</p>
<h3 id="7、BitmapHunter"><a href="#7、BitmapHunter" class="headerlink" title="7、BitmapHunter:"></a>7、BitmapHunter:</h3><h4 id="1）Dispatcher-forReqeust："><a href="#1）Dispatcher-forReqeust：" class="headerlink" title="1）Dispatcher#forReqeust："></a>1）Dispatcher#forReqeust：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BitmapHunter.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BitmapHunter <span class="title">forRequest</span><span class="params">(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,</span><br><span class="line">                               Action action)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据Action获取对应Request</span></span><br><span class="line">    Request request = action.getRequest();</span><br><span class="line">    <span class="comment">// 获取requestHandlers</span></span><br><span class="line">    List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Index-based loop to avoid allocating an iterator.</span></span><br><span class="line">    <span class="comment">//noinspection ForLoopReplaceableByForEach</span></span><br><span class="line">    <span class="comment">// 查找使用能够处理该Request的requesthandler，如果有则传入BitmapHandler</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = requestHandlers.size(); i &lt; count; i++) &#123;</span><br><span class="line">        RequestHandler requestHandler = requestHandlers.get(i);</span><br><span class="line">        <span class="keyword">if</span> (requestHandler.canHandleRequest(request)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用默认的ERRORING_HANDLER来构造BitmapHunter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先判断Picasso中是否已经设置了能够处理该Request的requestHandler，如果存在则传入BitmapHandler,如果不存在，则使用默认的ERRORING_HANDLER来构造BitmapHandler；<br>简单看下ERRORING_HANDLER:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BitmapHunter.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RequestHandler ERRORING_HANDLER = <span class="keyword">new</span> RequestHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canHandleRequest</span><span class="params">(Request data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Result <span class="title">load</span><span class="params">(Request request, <span class="keyword">int</span> networkPolicy)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized type of request: "</span> + request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>事实上处理Request请求主要是通过reqeustHandler的load函数来进行处理的，然后将处理后的结果封装成Result，然后返回；Picasso在其构造函数中提供了一些列的RequestHandler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;RequestHandler&gt; allRequestHandlers =</span><br><span class="line">    <span class="keyword">new</span> ArrayList&lt;RequestHandler&gt;(builtInHandlers + extraCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ResourceRequestHandler needs to be the first in the list to avoid</span></span><br><span class="line"><span class="comment">// forcing other RequestHandlers to perform null checks on request.uri</span></span><br><span class="line"><span class="comment">// to cover the (request.resourceId != 0) case.</span></span><br><span class="line">allRequestHandlers.add(<span class="keyword">new</span> ResourceRequestHandler(context));</span><br><span class="line"><span class="keyword">if</span> (extraRequestHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">  allRequestHandlers.addAll(extraRequestHandlers);</span><br><span class="line">&#125;</span><br><span class="line">allRequestHandlers.add(<span class="keyword">new</span> ContactsPhotoRequestHandler(context));</span><br><span class="line">allRequestHandlers.add(<span class="keyword">new</span> MediaStoreRequestHandler(context));</span><br><span class="line">allRequestHandlers.add(<span class="keyword">new</span> ContentStreamRequestHandler(context));</span><br><span class="line">allRequestHandlers.add(<span class="keyword">new</span> AssetRequestHandler(context));</span><br><span class="line">allRequestHandlers.add(<span class="keyword">new</span> FileRequestHandler(context));</span><br><span class="line">allRequestHandlers.add(<span class="keyword">new</span> NetworkRequestHandler(dispatcher.downloader, stats));</span><br><span class="line">requestHandlers = Collections.unmodifiableList(allRequestHandlers);</span><br></pre></td></tr></table></figure>
<p>可以看到，按照不同的Request，Picasso提供了不同的RequestHandler进行处理，比如从资源中进行加载的则使用ResourceRequestHandler，从文件中加载则调用FileRequestHandler,从网络中直接下载使用NetworkRequestHandler等等。<br>下面将会看到这些RequestHandler的具体处理作用；</p>
<h4 id="2）BitmapHunter"><a href="#2）BitmapHunter" class="headerlink" title="2）BitmapHunter:"></a>2）BitmapHunter:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BitmapHunter.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapHunter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Global lock for bitmap decoding to ensure that we are only are decoding one at a time. Since</span><br><span class="line">     * this will only ever happen in background threads we help avoid excessive memory thrashing as</span><br><span class="line">     * well as potential OOMs. Shamelessly stolen from Volley.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object DECODE_LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            updateThreadName(data);</span><br><span class="line">            <span class="comment">// 主要的执行逻辑在hunt方法中</span></span><br><span class="line">            result = hunt();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过Dispatcher来分发运行之后的结果</span></span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                dispatcher.dispatchFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dispatcher.dispatchComplete(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下面是进行运行过程中的一邪猎以往情况的处理</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Downloader.ResponseException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.localCacheOnly || e.responseCode != <span class="number">504</span>) &#123;</span><br><span class="line">                exception = e;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatcher.dispatchFailed(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NetworkRequestHandler.ContentLengthException e) &#123;</span><br><span class="line">            exception = e;</span><br><span class="line">            dispatcher.dispatchRetry(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            exception = e;</span><br><span class="line">            dispatcher.dispatchRetry(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">            StringWriter writer = <span class="keyword">new</span> StringWriter();</span><br><span class="line">            stats.createSnapshot().dump(<span class="keyword">new</span> PrintWriter(writer));</span><br><span class="line">            exception = <span class="keyword">new</span> RuntimeException(writer.toString(), e);</span><br><span class="line">            dispatcher.dispatchFailed(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            exception = e;</span><br><span class="line">            dispatcher.dispatchFailed(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Thread.currentThread().setName(Utils.THREAD_IDLE_NAME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> BitmapHunter实际上是一个Runnable,重点看其run中的执行逻辑；看到执行较为简单，都是通过hunt这个函数来实现的，获取到结果后，根据结果的成功与否，通过Dispatcher进行转发结果；<br>BitmapHunter中有一个成员变量较为有趣，DECODE_LOCK，这个变量在Volley中出现过，而且代码作者也说这是它从Volley中学习过来来，从名称中就可以看出，它是用来在解码图片时使用的锁，用来保证系统在同一时刻只有一个线程在解码图片；</p>
<h5 id="2-1）Bitmap-hunt"><a href="#2-1）Bitmap-hunt" class="headerlink" title="2.1）Bitmap#hunt:"></a>2.1）Bitmap#hunt:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BitmapHunter.java</span></span><br><span class="line"><span class="keyword">final</span> Request data;</span><br><span class="line"><span class="function">Bitmap <span class="title">hunt</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里还是先尝试从MemoryCache中去获取Bitmap</span></span><br><span class="line">    <span class="keyword">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;</span><br><span class="line">        bitmap = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123; <span class="comment">// 如果获取成功，直接返回</span></span><br><span class="line">            stats.dispatchCacheHit(); <span class="comment">// 统计命中信息</span></span><br><span class="line">            loadedFrom = MEMORY;      <span class="comment">// loadedFrom记录表示从Memory缓存中获取</span></span><br><span class="line">            <span class="keyword">return</span> bitmap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data.networkPolicy = retryCount == <span class="number">0</span> ? NetworkPolicy.OFFLINE.index : networkPolicy;</span><br><span class="line">    <span class="comment">// 通过RequestHandler.load来处理Request获取结果</span></span><br><span class="line">    RequestHandler.Result result = requestHandler.load(data, networkPolicy);</span><br><span class="line">    <span class="comment">// 如果处理结果成功</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loadedFrom = result.getLoadedFrom();</span><br><span class="line">        exifRotation = result.getExifOrientation();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从结果中获取Bitmap</span></span><br><span class="line">        bitmap = result.getBitmap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there was no Bitmap then we need to decode it from the stream.</span></span><br><span class="line">        <span class="comment">// 如果Bitmap为null，则需要将Stream转化成Bitmap</span></span><br><span class="line">        <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            InputStream is = result.getStream();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bitmap = decodeStream(is, data); <span class="comment">// 将网络数据流decode成Bitmap</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Utils.closeQuietly(is);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 更新统计信息   </span></span><br><span class="line">        stats.dispatchBitmapDecoded(bitmap);</span><br><span class="line">        <span class="comment">// 判断是否需要进行Transformation，即进行转换</span></span><br><span class="line">        <span class="keyword">if</span> (data.needsTransformation() || exifRotation != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里体现了前面提到的DECODE_LOCK的作用，它保证在同一时刻，只有一个线程在执行图形变换</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DECODE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data.needsMatrixTransform() || exifRotation != <span class="number">0</span>) &#123;</span><br><span class="line">                    bitmap = transformResult(data, bitmap, exifRotation);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (data.hasCustomTransformations()) &#123;</span><br><span class="line">                    bitmap = applyCustomTransformations(data.transformations, bitmap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stats.dispatchBitmapTransformed(bitmap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hunt获取Bitmap的流程也较为清晰，首先仍然进行一次尝试从MemoryCache中进行获取；<br>获取失败，通过requestHandler的load函数进行加载，加载返回的结果为Result；<br>然后判断获取到的结果是否已经是Bitmap，如果不是，则需要将其从Stream转化成Bitmap；<br>然后判断是否需要Transformation；使用Transformation可以实现对获取到的图片的转化，一般的使用方式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Picasso.with(<span class="keyword">this</span>).load(<span class="string">""</span>).transform(<span class="keyword">new</span> Transformation() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">transform</span><span class="params">(Bitmap source)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 进行图片转换</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">key</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).into(mImageView);</span><br></pre></td></tr></table></figure>
<p>使用transform方法中添加Transformation进行图片处理，相应的图片处理开源库picasso-transformations源码地址已经集成了一些常用的Transformation可以直接进行使用；<br>transform的主要作用是将新创建Transformation对象添加到Request的transformations这个ArrayList中；<br>因而判断Request是否需要进行transform的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Request.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">needsTransformation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> needsMatrixTransform() || hasCustomTransformations();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否需要矩阵变换</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">needsMatrixTransform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasSize() || rotationDegrees != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即将Bitmap转化成ImageView适合的尺寸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> targetWidth != <span class="number">0</span> || targetHeight != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断用户是否添加了相应的Transformation</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasCustomTransformations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transformations != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后根据需要，对图片进行转换；<br>这里转换时使用到了前面所提到的<strong>DECODE_LOCK</strong>，它保证在同一时刻，只有一个线程在执行图形变换操作；<br>流程梳理清楚了，下面接着来看通过requestHandler接着获取Bitmap的过程，这里通过NetworkRequestHandler为例，即从网络中获取；</p>
<h5 id="2-2）NetworkRequestHandler-load"><a href="#2-2）NetworkRequestHandler-load" class="headerlink" title="2.2）NetworkRequestHandler#load:"></a>2.2）NetworkRequestHandler#load:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NetWorkRequestHandler.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkRequestHandler</span> <span class="keyword">extends</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Downloader downloader;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RequestHandler.<span class="function">Result <span class="title">load</span><span class="params">(Request request, <span class="keyword">int</span> networkPolicy)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 可以看到真正处理网络请求的操作时通过downloader来实现的</span></span><br><span class="line">        Downloader.Response response = downloader.load(request.uri, request.networkPolicy);</span><br><span class="line">        <span class="comment">// 下面处理response结果</span></span><br><span class="line">        <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断数据是从磁盘还是网络总获取的</span></span><br><span class="line">        Picasso.LoadedFrom loadedFrom = response.cached ? DISK : NETWORK;</span><br><span class="line"></span><br><span class="line">        Bitmap bitmap = response.getBitmap();</span><br><span class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123; <span class="comment">// 如果可以直接获取到Bitmap，则将其封装成Result，返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RequestHandler.Result(bitmap, loadedFrom);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则获取其输入流InputStream</span></span><br><span class="line">        InputStream is = response.getInputStream();</span><br><span class="line">        <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Sometimes response content length is zero when requests are being replayed. Haven't found</span></span><br><span class="line">        <span class="comment">// root cause to this but retrying the request seems safe to do so.</span></span><br><span class="line">        <span class="comment">// 处理无效的Content长度为0的情况</span></span><br><span class="line">        <span class="keyword">if</span> (loadedFrom == DISK &amp;&amp; response.getContentLength() == <span class="number">0</span>) &#123;</span><br><span class="line">            Utils.closeQuietly(is);</span><br><span class="line">            <span class="comment">// 抛出ContentLengthException，在Bitmap的run函数中会处理该异常，会调用retry进行重试</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ContentLengthException(<span class="string">"Received response with 0 content-length header."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (loadedFrom == NETWORK &amp;&amp; response.getContentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            stats.dispatchDownloadFinished(response.getContentLength());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 封装成Result，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RequestHandler.Result(is, loadedFrom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到，真正处理请求的其实是Downloader这个实例，处理后返回的结果为Response;<br>Response中返回的结果可能有两种情况，一种是可能已经获取到了bitmap，一种可能是InputStream，这里需要分别进行处理，封装成Result，返回给BitmapHunter；<br>这里有个细节，当从磁盘中获取的结果Content的长度为0时，这里会抛出ContentLengthException异常，在BitmapHunter的run函数中会处理该异常，会调用retry进行重试;<br>downloader也是在Picasso初始化时就创建了的，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (downloader == <span class="keyword">null</span>) &#123;</span><br><span class="line">  downloader = Utils.createDefaultDownloader(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3）Downloader"><a href="#2-3）Downloader" class="headerlink" title="2.3）Downloader:"></a>2.3）Downloader:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Utils.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Downloader <span class="title">createDefaultDownloader</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(<span class="string">"com.squareup.okhttp.OkHttpClient"</span>);</span><br><span class="line">        <span class="keyword">return</span> OkHttpLoaderCreator.create(context);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UrlConnectionDownloader(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里提供了两种实现，一种是如果系统中已经添加了OkhttpClient依赖，则使用Class.forName加载OkHttpClient类时，会加载成功，这时使用OkHttpLoaderCreator进行创建，也就是下面的网络请求通过okHttp来实现；否则是使用Android中默认提供的UrlConnection;这里一句OkHttp来进行分析；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Utils.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpLoaderCreator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Downloader <span class="title">create</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OkHttpDownloader(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则Downloader的真是类型为OkHttpDownloader;<br>先来看下OkHttpDownloader的一些具体细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Utils.java</span></span><br><span class="line"><span class="comment">// 创建Cache的文件地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PICASSO_CACHE = <span class="string">"picasso-cache"</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> File <span class="title">createDefaultCacheDir</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    File cache = <span class="keyword">new</span> File(context.getApplicationContext().getCacheDir(), PICASSO_CACHE);</span><br><span class="line">    <span class="keyword">if</span> (!cache.exists()) &#123;</span><br><span class="line">        <span class="comment">//noinspection ResultOfMethodCallIgnored</span></span><br><span class="line">        cache.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OkHttpDownloader.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpDownloader</span> <span class="keyword">implements</span> <span class="title">Downloader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> OkHttpClient <span class="title">defaultOkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">        <span class="comment">// 设置OkHttpClient中的一些参数</span></span><br><span class="line">        client.setConnectTimeout(Utils.DEFAULT_CONNECT_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);</span><br><span class="line">        client.setReadTimeout(Utils.DEFAULT_READ_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);</span><br><span class="line">        client.setWriteTimeout(Utils.DEFAULT_WRITE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Create new downloader that uses OkHttp. This will install an image cache into your application</span><br><span class="line">     * cache directory.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">// 一系列构造函数</span></span><br><span class="line">    <span class="comment">// 构造函数的主要作用其实只是为了创建OkHttpClient</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OkHttpDownloader</span><span class="params">(<span class="keyword">final</span> Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Utils.createDefaultCacheDir(context));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OkHttpDownloader</span><span class="params">(<span class="keyword">final</span> File cacheDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(cacheDir, Utils.calculateDiskCacheSize(cacheDir));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OkHttpDownloader</span><span class="params">(<span class="keyword">final</span> File cacheDir, <span class="keyword">final</span> <span class="keyword">long</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(defaultOkHttpClient());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置Cache地址，使用的是OkHttp中的Cache</span></span><br><span class="line">            client.setCache(<span class="keyword">new</span> com.squareup.okhttp.Cache(cacheDir, maxSize));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OkHttpDownloader</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里提供了一系列OkHttpDownloader的构造函数及创建细节，其实最主要的工作只是为了创建OkHttpClient；<br>具体来看其load执行网络请求的细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OkHttpDownloader.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Downloader.<span class="function">Response <span class="title">load</span><span class="params">(Uri uri, <span class="keyword">int</span> networkPolicy)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    CacheControl cacheControl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 构建Cache的相关执行策略</span></span><br><span class="line">    <span class="keyword">if</span> (networkPolicy != <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> (NetworkPolicy.isOfflineOnly(networkPolicy)) &#123; <span class="comment">// 如果要求强制从网络中获取</span></span><br><span class="line">            cacheControl = CacheControl.FORCE_CACHE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            CacheControl.Builder builder = <span class="keyword">new</span> CacheControl.Builder();</span><br><span class="line">            <span class="keyword">if</span> (!NetworkPolicy.shouldReadFromDiskCache(networkPolicy)) &#123; <span class="comment">// 判断是否允许读取Disk缓存</span></span><br><span class="line">                builder.noCache(); <span class="comment">// DiskCache不允许读</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!NetworkPolicy.shouldWriteToDiskCache(networkPolicy)) &#123; <span class="comment">// 判断是否允许写入Disk缓存</span></span><br><span class="line">                builder.noStore(); <span class="comment">// DiskCache不允许写</span></span><br><span class="line">            &#125;</span><br><span class="line">            cacheControl = builder.build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据URI创建OkHttp中的Request</span></span><br><span class="line">    com.squareup.okhttp.Request.Builder builder = <span class="keyword">new</span> com.squareup.okhttp.Request.Builder().url(uri.toString());</span><br><span class="line">    <span class="keyword">if</span> (cacheControl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        builder.cacheControl(cacheControl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 典型的okHttp的同步执行方式来获取网络请求</span></span><br><span class="line">    com.squareup.okhttp.Response response = client.newCall(builder.build()).execute();</span><br><span class="line">    <span class="keyword">int</span> responseCode = response.code();</span><br><span class="line">    <span class="comment">// 处理失败的请求</span></span><br><span class="line">    <span class="keyword">if</span> (responseCode &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">        response.body().close();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Downloader.ResponseException(responseCode + <span class="string">" "</span> + response.message(), networkPolicy,</span><br><span class="line">                responseCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> fromCache = response.cacheResponse() != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ResponseBody responseBody = response.body();</span><br><span class="line">    <span class="comment">// 将获取到的结果封装成Response返回给RequestHandler</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Downloader.Response(responseBody.byteStream(), fromCache, responseBody.contentLength());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求过程完全交由OkHttp来实现的，过程较为简单，不再赘述；这里有个细节问题，这里使用的OkHttp中的同步执行方式，因为这里执行load的线程就已经是非主线程了，故选择同步执行方式即可；具体的从DISK以及Network中来获取Response的工作完全交给OkHttp进行执行即可；<br>至此获取Bitmap的工作已经完成，主要的所有逻辑可以总结为<br>1）首先创建一个Request，Request中包含了一个请求中的相关信息，这是尝试从MemoryCache中获取，如果获取成功则直接返回，否则将Request封装成Action，然后enqueueAndSubmit；<br>2）在submit中，如果有相同的Action请求，则合并后来的Action请求，同一个actions集合，只需要执行一个Action就可以获取到结果；<br>如果之前并没有相同的Action请求，则使用Action创建一个Runnable即重要的BitmapHunter，通过线程池ExecutorService来submit执行；<br>3）BitmapHunter的主要执行逻辑在run函数中；而获取Bitmap的操作主要通过hunt函数来获取；hunt接着调用Request相对应的适合处理该request的RequestHandler的load函数进行处理，比如处理网络请求则需要使用NetworkRequestHandler;<br>4）RequestHandler的load函数其实也只是一层封装，真正执行网络请求的是Downloader这个类，对应于实际情况就是OkHttpDownloader;它的所有网络请求也都是直接交由OkHttp来完成的，因此Picasso和Retrofit一样都可以看做是对OkHttp的进一步封装；</p>
<p>获取Bitmap成功后，回来BitmapHunter的run方法继续来看对于结果是怎么处理的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过Dispatcher来分发运行之后的结果</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">    dispatcher.dispatchFailed(<span class="keyword">this</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dispatcher.dispatchComplete(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-4）Dispatcher："><a href="#2-4）Dispatcher：" class="headerlink" title="2.4）Dispatcher："></a>2.4）Dispatcher：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchComplete</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</span><br><span class="line">    handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> HUNTER_COMPLETE: &#123;</span><br><span class="line">                BitmapHunter hunter = (BitmapHunter) msg.obj;</span><br><span class="line">                dispatcher.performComplete(hunter);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performComplete</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否允许写入到MemoryCache中</span></span><br><span class="line">    <span class="keyword">if</span> (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123;</span><br><span class="line">        cache.set(hunter.getKey(), hunter.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从hunterMap中移除该BitmapHunter</span></span><br><span class="line">    hunterMap.remove(hunter.getKey());</span><br><span class="line">    batch(hunter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> List&lt;BitmapHunter&gt; batch;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BATCH_DELAY = <span class="number">200</span>; <span class="comment">// ms</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">batch</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果hunter取消了，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (hunter.isCancelled()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行打包发送</span></span><br><span class="line">    batch.add(hunter);</span><br><span class="line">    <span class="keyword">if</span> (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) &#123;</span><br><span class="line">        handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dispatcher即进行一些结果上的转发以及线程间的转换，都是同handler来实现的；前面提到这里handler对应的是DispatcherHandler，对应的Dispatcher所在的线程，然后使用该handler分发结果；<br>首先判断系统是否允许将获取到的结果写入到memoryCache中；然后执行完成过一个BitmapHunter之后，注意将其从hunterMap中移除；Picasso中分发结果是采用batch打包分发的，它每<strong>200ms</strong>分发一次，通过的就是batch函数中实现的；<br>handler发送一个延迟时间为200ms的类型为 HUNTER_DELAY_NEXT_BATCH的Message，在这200ms之内，下面将要转发的hunter事件，因为handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)为true，故而会添加到一个ArrayList batch中，等到延迟时间到了，这200ms内所到达的所有hunter都会存储到batch中一并进行发送；来看具体的发送函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> HUNTER_DELAY_NEXT_BATCH: &#123;</span><br><span class="line">                dispatcher.performBatchComplete();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performBatchComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;BitmapHunter&gt; copy = <span class="keyword">new</span> ArrayList&lt;BitmapHunter&gt;(batch);</span><br><span class="line">    batch.clear();</span><br><span class="line">    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));</span><br><span class="line">    logBatch(copy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即通过主线程的Handler将结果发送到主线程；<br>mainThreadHandler对应的是Picasso中的静态内部类，来看其处理逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Picasso.java</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Handler HANDLER = <span class="keyword">new</span> Handler(Looper.getMainLooper()) &#123;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> HUNTER_BATCH_COMPLETE: &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) </span><br><span class="line">                List&lt;BitmapHunter&gt; batch = (List&lt;BitmapHunter&gt;) msg.obj;</span><br><span class="line">                <span class="comment">//noinspection ForLoopReplaceableByForEach</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = batch.size(); i &lt; n; i++) &#123;</span><br><span class="line">                    BitmapHunter hunter = batch.get(i);</span><br><span class="line">                    hunter.picasso.complete(hunter);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续来看<strong>complete：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Picasso.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取Action</span></span><br><span class="line">    Action single = hunter.getAction();</span><br><span class="line">    List&lt;Action&gt; joined = hunter.getActions();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> hasMultiple = joined != <span class="keyword">null</span> &amp;&amp; !joined.isEmpty();</span><br><span class="line">    <span class="keyword">boolean</span> shouldDeliver = single != <span class="keyword">null</span> || hasMultiple;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!shouldDeliver) &#123; </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Uri uri = hunter.getData().uri;</span><br><span class="line">    Exception exception = hunter.getException();</span><br><span class="line">    Bitmap result = hunter.getResult();</span><br><span class="line">    LoadedFrom from = hunter.getLoadedFrom();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (single != <span class="keyword">null</span>) &#123;</span><br><span class="line">        deliverAction(result, from, single);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasMultiple) &#123;</span><br><span class="line">        <span class="comment">//noinspection ForLoopReplaceableByForEach</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = joined.size(); i &lt; n; i++) &#123;</span><br><span class="line">            Action join = joined.get(i);</span><br><span class="line">            deliverAction(result, from, join);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Listener情况</span></span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="keyword">null</span> &amp;&amp; exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        listener.onImageLoadFailed(<span class="keyword">this</span>, uri, exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理最终的结果，对于有合并相同Action的请求，则需要对应地分别进行处理；处理的函数均为deliverAction：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Picasso.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliverAction</span><span class="params">(Bitmap result, LoadedFrom from, Action action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action.isCancelled()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!action.willReplay()) &#123;</span><br><span class="line">        targetToAction.remove(action.getTarget());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (from == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"LoadedFrom cannot be null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        action.complete(result, from);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        action.error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>盗用一张图来解释所有的处理逻辑：<br><img src="http://img.blog.csdn.net/20160525164719036" alt="这里写图片描述"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-设计模式汇总--结构型模型" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/12/设计模式汇总--结构型模型/" class="article-date">
      <time datetime="2016-05-12T02:14:15.022Z" itemprop="datePublished">2016-05-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/12/设计模式汇总--结构型模型/">设计模式汇总--结构型模式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>总体来说设计模式分为三大类：<br><strong>创建型模式</strong>，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br><strong>结构型模式</strong>，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br><strong>行为型模式</strong>，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。<br>其实还有两类：并发型模式和线程池模式。<br>前面已经介绍了<a href="http://blog.csdn.net/woliuyunyicai/article/details/51287132" target="_blank" rel="external">《设计模式汇总：创建型模式》</a>，下面来看结构型模型：</p>
<h1 id="一、适配器模式"><a href="#一、适配器模式" class="headerlink" title="一、适配器模式"></a>一、适配器模式</h1><p>适配器模式在Android中比较常见，在ListView中无时无刻不在使用；<br>适配器的思想是将一个类的接口转换成客户希望的另外一个接口。其主要涉及三个角色：<br>模式所涉及的角色有：<br><strong>目标(Target)角色：</strong>这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。<br><strong>源(Adapee)角色：</strong>现在需要适配的接口。<br><strong>适配器(Adaper)角色：</strong>适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。<br>把Adaptee设想成使用ListView时想要加载的数据如ArrayList；<br>目标角色Target即是ListView源码中会用到的BaseAdapter这些;<br>而开发时继承BaseAdater自定义的Adapter即为Adapter角色；</p>
<p>实现适配器的方法有两种，可以分别通过继承和组合来实现适配器效果：<br>一种是类适配器模式；一种是对象适配器模式；</p>
<h2 id="1）类适配器模式"><a href="#1）类适配器模式" class="headerlink" title="1）类适配器模式"></a>1）类适配器模式</h2><p><img src="http://img.blog.csdn.net/20160525163616480" alt="这里写图片描述"><br><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reqeust</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">specReqeust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adaptee specReqeust"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为Adaptee适配成Target接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reqeust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        specReqeust();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Target target = <span class="keyword">new</span> Adapter();</span><br><span class="line">        target.reqeust();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Target不为接口时，Java不支持多继承，可以采用组合的形式来实现：</p>
<h2 id="2）对象适配器模式"><a href="#2）对象适配器模式" class="headerlink" title="2）对象适配器模式"></a>2）对象适配器模式</h2><p><img src="http://img.blog.csdn.net/20160525163628959" alt="这里写图片描述"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">reqeust</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">specReqeust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adaptee specReqeust"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为Adaptee适配成Target接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reqeust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.specReqeust();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将Adaptee适配成Target来使用</span></span><br><span class="line">        Target target = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee());</span><br><span class="line">        target.reqeust();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3）适配器模式的优点-："><a href="#3）适配器模式的优点-：" class="headerlink" title="3）适配器模式的优点 ："></a>3）适配器模式的优点 ：</h2><p><strong>1）更好的复用性</strong><br>系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。<br><strong>2）更好的扩展性</strong><br>在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。</p>
<p><strong>适配器模式的缺点 ：</strong><br>　　过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</p>
<h1 id="二、装饰者模式"><a href="#二、装饰者模式" class="headerlink" title="二、装饰者模式"></a>二、装饰者模式</h1><p>Java中InputStream，FilterInputStream，DataInputStream这些就是典型的装饰者模式。<br><img src="http://img.blog.csdn.net/20160525163645319" alt="这里写图片描述"><br><strong>Decorator模式（别名Wrapper）</strong>：动态将职责附加到对象上，若要扩展功能，装饰者提供了比继承更具弹性的代替方案。<br>意图：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。<br><img src="http://img.blog.csdn.net/20160525163654647" alt="这里写图片描述"><br><strong>适用性</strong>：<br>以下情况使用Decorator模式<br>1）需要扩展一个类的功能，或给一个类添加附加职责。<br>2）需要动态的给一个对象添加功能，这些功能可以再动态的撤销。<br>3）需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。<br>4）当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。 比如如下情况所提供的灵活性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = null;</span><br><span class="line">new BufferedInputStream(new DataInputStream(in));</span><br><span class="line">new DataInputStream(new BufferedInputStream(in));</span><br></pre></td></tr></table></figure>
<p>明显采用继承是比较难以实现的；</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">abstract class Compontent &#123;</span><br><span class="line">    abstract void operation1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConcreteCompontent extends Compontent&#123;</span><br><span class="line">    @Override</span><br><span class="line">    void operation1() &#123;</span><br><span class="line">        System.out.print(&quot;ConcreteCompontent operation1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Decorator extends Compontent &#123;</span><br><span class="line">    Compontent compontent;</span><br><span class="line"></span><br><span class="line">    public Decorator(Compontent compontent) &#123;</span><br><span class="line">        this.compontent = compontent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void operation1() &#123;</span><br><span class="line">        compontent.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConcreteDecorator1 extends Decorator &#123;</span><br><span class="line">    int addedField; // 动态添加的变量</span><br><span class="line"></span><br><span class="line">    public ConcreteDecorator1(Compontent compontent) &#123;</span><br><span class="line">        super(compontent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void operation1() &#123;</span><br><span class="line">        System.out.println(&quot;do other sth&quot;);</span><br><span class="line">        super.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConcreteDecorator2 extends Decorator &#123;</span><br><span class="line"></span><br><span class="line">    public ConcreteDecorator2(Compontent compontent) &#123;</span><br><span class="line">        super(compontent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 动态添加的操作</span><br><span class="line">    void operation2() &#123;</span><br><span class="line">        System.out.print(&quot;ConcreteCompontent operation2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client &#123;</span><br><span class="line">    public void dosth() &#123;</span><br><span class="line">        Compontent co = new ConcreteCompontent();</span><br><span class="line">        Compontent compontent0 = new ConcreteDecorator2(co);</span><br><span class="line">        Compontent compontent1 = new ConcreteDecorator1(new ConcreteDecorator2(co));</span><br><span class="line">        Compontent compontent2 = new ConcreteDecorator2(new ConcreteDecorator1(co));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装饰者模式的优缺点："><a href="#装饰者模式的优缺点：" class="headerlink" title="装饰者模式的优缺点："></a>装饰者模式的优缺点：</h2><h3 id="1）优点："><a href="#1）优点：" class="headerlink" title="1）优点："></a>1）优点：</h3><ol>
<li>通过组合而非继承的方式，实现了动态扩展对象的功能的能力。</li>
<li>有效避免了使用继承的方式扩展对象功能而带来的灵活性差，子类无限制扩张的问题。</li>
<li>充分利用了继承和组合的长处和短处，在灵活性和扩展性之间找到完美的平衡点。</li>
<li>装饰者和被装饰者之间虽然都是同一类型，但是它们彼此是完全独立并可以各自独立任意改变的。</li>
<li>遵守大部分GRASP原则和常用设计原则，高内聚、低偶合。</li>
<li>Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。</li>
<li>通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合<h3 id="2）缺点："><a href="#2）缺点：" class="headerlink" title="2）缺点："></a>2）缺点：</h3></li>
<li>装饰链不能过长，否则会影响效率。</li>
<li>因为所有对象都是Component,所以如果Component内部结构发生改变，则不可避免地影响所有子类(装饰者和被装饰者)，也就是说，通过继承建立的关系总是脆弱地，如果基类改变，势必影响对象的内部，而通过组合(Decoator HAS A Component)建立的关系只会影响被装饰对象的外部特征。</li>
<li>只在必要的时候使用装饰者模式，否则会提高程序的复杂性，增加系统维护难度。</li>
<li>这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。</li>
<li>装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</li>
<li>装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。</li>
</ol>
<p><strong>修饰者模式至少有两个关键利益及两个责任(liability)：</strong><br><strong>1）比静态继承更有弹性：</strong>修饰者模式提供一个较静态（多重）继承更有弹性的方式附加责任到对象上。使用修饰者责任可以在执行期简单的附加或取消，相对的继承需要为每一个新的附加责任建立一个新的类（如BorderedScrollableTextView、BorderedTextView等），如此会造成使用许多类及增加系统复杂度。更进一步；为特定的Component类提供不同的修饰者类让你比较及混合责任。<br>避免在层级架构中增加外貌装载(feature-laden《译注：在类中存有许多有关显示外貌的Component或属性等》)类：修饰者提供一个你要才有(pay-as-you-go)的方式附加责任。相对的不去在一个复杂客制化类中提供一所有可预测外貌；而定义一个简单类并在一个修饰者类逐步增加功能，其结果是一个应用系统无须准备一些不会使用到的外貌。同时也容易从他们所扩充的对象类定义一个新的修饰者类；甚至不在预测内。扩充一个复杂类需要揭露与你要附加责任无关的部分。<br><strong>2）修饰者及其Component不是同一个：</strong>修饰者就像透明的围墙(transparent enclosure)，但从一个对象界定(identity)的观点；一个被修饰的对象与其本身并不需要去区分(identical)，因此当你使用修饰者无区依赖对象界定。<br>有许多小对象：使用修饰这设计时常常产生在一个系统中组合看起来很像的许多小对象的结果。这些对象的差一点只是互动(interconnect)的方式；而非他的类或者其内不变量的值。虽然只要你了解他们就可以方便客制系统；但是可能难以学习及除错。<br>接口一致(conformance)：修饰者对象的接口必须与其修饰的对象接口一致具体修饰指(ConcreteDecorator)类必须继承一个公用(common)类。<br><strong>3）忽略(omitting)抽象修饰者类：</strong>当你只是附加单一责任时无须定义一个抽象修饰者类，这种情形一般是当你使用现存的类层级架构而非构建一个新的，因此你可以将修饰者传递请求到Component的责任融合(merge)至具体修饰者。<br>保持轻量(lightweight)的Component类：要确保接口一致，Component及修饰者必须自一个公用Component类继承，保持这个公用Component类轻量是很重要的，即必须专注于定义一个接口而非储存数据。数据责任的定义必须延缓至子类，否则太复杂的Component类会在数量上使用太过于重(heavyweight)。在Component类中放置太多的功能同时会增加其子类为许多没有必要的外表付出代价的可能性。<br><strong>4）改变对象的外表(skin)或其内部(guts)：</strong>我们可以想象修饰者就像对象的可以改变行为外表，另一种替代方式是改变其内部，策略模式(Strategy)就是改变其内部的作法。当Component类在本质上(intrinsically)太重(heavyweight)时策略模式是一个比较适当的选择，因为以修饰者模式实现成本太高。在策略模式中组件传递(forward)他的部分行为给另外的策略对象，策略模式让我们以替代的策略对象改变或扩充组件的功能。<br><strong>动态和静态的问题：</strong><br>所谓动态是说可以在系统运行时(RunTime)动态给对象增加其它职责而不需要修改代码或重新编译；<br>所谓静态是说必须通过调整代码(DesignTime)才能给对象增加职责,而且系统还需要重新编译；<br>从具体技术层面来说，对象的组合和继承正好对应于前面的动态和静态，因为通过对象组合建立的交互关系不是在代码中(DesignTime)固定死的，而是在运行时(RunTime)动态组合的；而通过继承建立的关系是僵硬的难以改变的，因为它是在代码中(DesignTime)固定死了的，根本不存在运行时(RunTime)改变的可能。换个角度说：我们应该多使用对象组合来保持系统的运行时扩展性，尽量少使继承，因为继承让程序变得僵硬，优先使用对象组合，而非类继承。</p>
<h1 id="三、代理模式"><a href="#三、代理模式" class="headerlink" title="三、代理模式"></a>三、代理模式</h1><p>代理模式就是给一个对象提供一个代理，并由代理对象控制对原对象的引用。<br>在代理模式中，proxy代理主要是起到一个中介的作用，它连接客户端和目标对象。<br>在Android的Binder机制中，代理模式起到很重要的作用。<br><img src="http://img.blog.csdn.net/20160525163712195" alt="这里写图片描述"></p>
<p><strong>代理模式适用于：</strong><br>在某些情况下，我们不希望或是不能直接访问对象 A，而是通过访问一个中介对象 B，由 B 去访问 A 达成目的，这种方式我们就称为代理。<br>这里对象 A 所属类我们称为委托类，也称为被代理类，对象 B 所属类称为代理类。<br><strong>代理优点有：</strong><br>1）隐藏委托类的实现<br>2）解耦，不改变委托类代码情况下做一些额外处理，比如添加初始判断及其他公共操作<br><strong>代理模式中有三类角色：</strong><br><strong>抽象主题角色（Object）：</strong>声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。<br><strong>具体主题角色（RealObject)：</strong>也称为委托角色或者被代理角色。定义了代理对象所代表的目标对象。<br><strong>代理主题角色（Proxy)：</strong>也叫代理类。代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。</p>
<p>Java中根据程序运行前代理类是否已经存在，可以将代理分为静态代理和动态代理。 </p>
<h2 id="1）静态代理："><a href="#1）静态代理：" class="headerlink" title="1）静态代理："></a>1）静态代理：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">interface IObject &#123;</span><br><span class="line">    void operation1();</span><br><span class="line">    void operation2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RealObject implements IObject&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operation1() &#123;</span><br><span class="line">        System.out.print(&quot;RealObject operation1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operation2() &#123;</span><br><span class="line">        System.out.print(&quot;RealObject operation2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Proxy implements IObject &#123;</span><br><span class="line">    private RealObject real;</span><br><span class="line"></span><br><span class="line">    public Proxy() &#123;</span><br><span class="line">        real = new RealObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operation1() &#123;</span><br><span class="line">        real.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operation2() &#123;</span><br><span class="line">        real.operation2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client &#123;</span><br><span class="line">    void doSth() &#123;</span><br><span class="line">        Proxy proxy = new Proxy();</span><br><span class="line">        proxy.operation1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上可见，Proxy就相当于生活中的代理，比如买东西的时候，没必要去生产商品的厂家去购买，直接去代理地点也即是超市购买即可；代理通过调用委托类来未用户提供同样的服务，而又避免了用户去直接调用委托类。</p>
<h2 id="2）动态代理："><a href="#2）动态代理：" class="headerlink" title="2）动态代理："></a>2）动态代理：</h2><p>由前所见，每一个委托类需要对应一个代理类，这样在大型项目中将会出现众多的代理类，而这些代理类只是一个中介而已，为了优化代码结果，Java提供了动态代理的方式，使用反射来动态生成相应的代理类来为用户提供服务。</p>
<h3 id="2-1）创建动态代理的流程："><a href="#2-1）创建动态代理的流程：" class="headerlink" title="2.1）创建动态代理的流程："></a>2.1）创建动态代理的流程：</h3><p>1、定义一个代理类和委托类共同使用的接口Operate<br>2、实现一个委托类继承Interface，它是真正实现操作逻辑的类记为Real<br>3、继承一个InvocationHandler，传入委托类实例；重写invoke函数<br>4、使用Proxy.newProxyInstance来动态创建一个代理类，今后的所有操作都通过这个实例proxy来操作；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 创建委托类和代理类统一的接口</span><br><span class="line">interface Operate &#123;</span><br><span class="line">    void do1();</span><br><span class="line">    void do2();</span><br><span class="line">    void do3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体的委托类</span><br><span class="line">class RealImpl implements Operate &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void do1() &#123;</span><br><span class="line">        System. out.println(&quot;Real do1&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void do2() &#123;</span><br><span class="line">        System. out.println(&quot;Real do2&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void do3() &#123;</span><br><span class="line">        System. out.println(&quot;Real do3&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 自定义InvocationHandler</span><br><span class="line">class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">    private Object target ;</span><br><span class="line"></span><br><span class="line">    public MyInvocationHandler(Object target ) &#123;</span><br><span class="line">        this.target = target ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy , Method method, Object[] args)</span><br><span class="line">            throws Throwable &#123;</span><br><span class="line">        // 执行 method之前的一些操作</span><br><span class="line">        Object result = method.invoke( target, args);</span><br><span class="line">        // 执行 method之后的一些自处理操作</span><br><span class="line">        return result ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class ProxyDynamic &#123;</span><br><span class="line">        // 具体的使用</span><br><span class="line">        public void a() &#123;</span><br><span class="line">              Operate proxy = (Operate) Proxy.newProxyInstance(Operate.class.getClassLoader(), new Class&lt;?&gt;[] &#123;Operate.class&#125;,</span><br><span class="line">                            new MyInvocationHandler(new RealImpl()));</span><br><span class="line">               proxy.do1();</span><br><span class="line">               proxy.do2();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2）原理："><a href="#2-2）原理：" class="headerlink" title="2.2）原理："></a>2.2）原理：</h3><p>Proxy这个类根据ClassLoader以及interfaces这个数组，获得一个相应的代理类的名称，一般的格式是packagename+$Proxy+num，然后通过<br> ProxyGenerator.generateProxyClass(proxyName, interfaces , accessFlags );<br>来创建对应的类；最后通过反射调用该类的构造器创建一个具体实例；这个类是继承Proxy的，Proxy持有InvocationHandler的实例h；<br>代理类的所有操作都是通过将Method传递到h的invoke函数，通过invoke函数进行最终的处理；<br>因此InvocationHandler是代理类和委托类之间的中介；</p>
<h4 id="1、来看具体的动态生成的类-Proxy0"><a href="#1、来看具体的动态生成的类-Proxy0" class="headerlink" title="1、来看具体的动态生成的类$Proxy0:"></a>1、来看具体的动态生成的类$Proxy0:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">import com.hust.liuyun.Operate;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line">public final class $Proxy0 extends Proxy</span><br><span class="line">  implements Operate</span><br><span class="line">&#123;</span><br><span class="line">  private static Method m4 ;</span><br><span class="line">  private static Method m1 ;</span><br><span class="line">  private static Method m5 ;</span><br><span class="line">  private static Method m0 ;</span><br><span class="line">  private static Method m3 ;</span><br><span class="line">  private static Method m2 ;</span><br><span class="line"></span><br><span class="line">  public $Proxy0(InvocationHandler paramInvocationHandler)</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    super(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final void operateMethod1()</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      h.invoke( this, m4, null );</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final boolean equals(Object paramObject)</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return ((Boolean)h.invoke( this, m1, new Object[] &#123; paramObject &#125;)).booleanValue();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final void operateMethod2()</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      h.invoke( this, m5, null );</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final int hashCode()</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return ((Integer)h.invoke( this, m0, null )).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final void operateMethod3()</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      h.invoke( this, m3, null );</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final String toString()</span><br><span class="line">    throws</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return (String)h.invoke( this, m2, null );</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      m4 = Class.forName(&quot;com.hust.liuyun.Operate&quot;).getMethod( &quot;do1&quot;, new Class[0]);</span><br><span class="line">      m1 = Class.forName(&quot;java.lang.Object&quot; ).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);</span><br><span class="line">      m5 = Class.forName(&quot;com.hust.liuyun.Operate&quot;).getMethod( &quot;do2&quot;, new Class[0]);</span><br><span class="line">      m0 = Class.forName(&quot;java.lang.Object&quot; ).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">      m3 = Class.forName(&quot;com.hust.liuyun.Operate&quot;).getMethod( &quot;do3&quot;, new Class[0]);</span><br><span class="line">      m2 = Class.forName(&quot;java.lang.Object&quot; ).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoSuchMethodError(localNoSuchMethodException .getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoClassDefFoundError(localClassNotFoundException .getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到该生成类是继承Proxy的，在构造函数中将InvocationHandler的实例传递进来；然后通过反射获取到该类中所有相关的Method的实例。<br>相关的所有操作都是通过h.invoke来实现的。</p>
<h4 id="2、Proxy-newProxyInstance："><a href="#2、Proxy-newProxyInstance：" class="headerlink" title="2、Proxy#newProxyInstance："></a>2、Proxy#newProxyInstance：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                 Class&lt;?&gt;[] interfaces, InvocationHandler h )</span><br><span class="line">                  throws IllegalArgumentException &#123;</span><br><span class="line">          Objects. requireNonNull(h);</span><br><span class="line"></span><br><span class="line">           final Class&lt;?&gt;[] intfs = interfaces .clone();</span><br><span class="line">           final SecurityManager sm = System.getSecurityManager ();</span><br><span class="line">           if (sm != null) &#123;</span><br><span class="line">                  checkProxyAccess(Reflection. getCallerClass(), loader, intfs);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">           * Look up or generate the designated proxy class.</span><br><span class="line">           */</span><br><span class="line">           // 通过这个重要类，来生成一个动态代理类</span><br><span class="line">          Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">           /*</span><br><span class="line">           * Invoke its constructor with the designated invocation handler.</span><br><span class="line">           */</span><br><span class="line">           try &#123;</span><br><span class="line">                  if (sm != null) &#123;</span><br><span class="line">                        checkNewProxyPermission(Reflection.getCallerClass() , cl);</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                  // 调用动态代理类的构造器来创建一个具体实例</span><br><span class="line">                  final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">                  final InvocationHandler ih = h ;</span><br><span class="line">                  if (!Modifier.isPublic( cl.getModifiers())) &#123;</span><br><span class="line">                       AccessController. doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                               public Void run() &#123;</span><br><span class="line">                                      cons.setAccessible( true);</span><br><span class="line">                                      return null ;</span><br><span class="line">                              &#125;</span><br><span class="line">                       &#125;);</span><br><span class="line">                 &#125;</span><br><span class="line">                  // 可以看到这里将InvocationHandler这个中介以参数形式加入进来</span><br><span class="line">                  return cons .newInstance(new Object[] &#123; h &#125;);</span><br><span class="line">          &#125; catch (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">                  throw new InternalError(e.toString(), e);</span><br><span class="line">          &#125; catch (InvocationTargetException e ) &#123;</span><br><span class="line">                 Throwable t = e.getCause();</span><br><span class="line">                  if (t instanceof RuntimeException) &#123;</span><br><span class="line">                        throw (RuntimeException) t ;</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                        throw new InternalError(t.toString(), t);</span><br><span class="line">                 &#125;</span><br><span class="line">          &#125; catch (NoSuchMethodException e ) &#123;</span><br><span class="line">                  throw new InternalError(e.toString(), e);</span><br><span class="line">          &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>流程：<br>1）进行一些权限检查之类<br>2）通过getProxyClass0来获得对应的动态代理类（可能是新创建，也可能是从Cache中取出）<br>3）调用代理类的构造器来创建一个具体的代理类；</p>
<h4 id="3、getProxyClass0"><a href="#3、getProxyClass0" class="headerlink" title="3、getProxyClass0"></a>3、getProxyClass0</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static final WeakCache &lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">proxyClassCache = new WeakCache &lt;&gt;(new KeyFactory(), new ProxyClassFactory());</span><br><span class="line">/**</span><br><span class="line"> * Generate a proxy class.  Must call the checkProxyAccess method</span><br><span class="line"> * to perform permission checks before calling this.</span><br><span class="line"> */</span><br><span class="line">private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    if (interfaces.length &gt; 65535) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If the proxy class defined by the given loader implementing</span><br><span class="line">    // the given interfaces exists, this will simply return the cached copy;</span><br><span class="line">    // otherwise, it will create the proxy class via the ProxyClassFactory</span><br><span class="line">    return proxyClassCache.get(loader , interfaces );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个WeakCache来存储相关的代理类信息，通过代理类来获取；</p>
<h4 id="4、WeakCache-get"><a href="#4、WeakCache-get" class="headerlink" title="4、WeakCache#get:"></a>4、WeakCache#get:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public V get(K key , P parameter) &#123;</span><br><span class="line">    Objects.requireNonNull(parameter );</span><br><span class="line"></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    // 根据ClassLoader获取相应的key值</span><br><span class="line">    Object cacheKey = CacheKey.valueOf(key , refQueue);</span><br><span class="line"></span><br><span class="line">    // 根据ClassLoader获得其中的ConcurrentMap</span><br><span class="line">    // lazily install the 2nd level valuesMap for the particular cacheKey</span><br><span class="line">    ConcurrentMap&lt;Object, Supplier&lt; V&gt;&gt; valuesMap = map.get(cacheKey );</span><br><span class="line">    if (valuesMap == null) &#123;</span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt; V&gt;&gt; oldValuesMap</span><br><span class="line">            = map.putIfAbsent(cacheKey,</span><br><span class="line">                              valuesMap = new ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        if (oldValuesMap != null) &#123;</span><br><span class="line">            valuesMap = oldValuesMap ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span><br><span class="line">    // subKey from valuesMap</span><br><span class="line">    // 在ConcurrentMap中，key对应的interfaces，Value则对应着具体的类Class信息&lt;?&gt;</span><br><span class="line">    // 代理类的具体创建逻辑是通过subKeyFactory.apply来实现的</span><br><span class="line">    Object subKey = Objects.requireNonNull(subKeyFactory.apply( key, parameter));</span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap .get(subKey );</span><br><span class="line">    Factory factory = null;</span><br><span class="line"></span><br><span class="line">    while ( true) &#123;</span><br><span class="line">       // 如果已经存在，则直接返回</span><br><span class="line">        if (supplier != null) &#123;</span><br><span class="line">            // supplier might be a Factory or a CacheValue&lt;V&gt; instance</span><br><span class="line">            V value = supplier.get();</span><br><span class="line">            if (value != null) &#123;</span><br><span class="line">                return value ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // else no supplier in cache</span><br><span class="line">        // or a supplier that returned null (could be a cleared CacheValue</span><br><span class="line">        // or a Factory that wasn&apos;t successful in installing the CacheValue)</span><br><span class="line"></span><br><span class="line">        // lazily construct a Factory</span><br><span class="line">        if (factory == null) &#123;</span><br><span class="line">            factory = new Factory( key, parameter, subKey , valuesMap );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (supplier == null) &#123;</span><br><span class="line">            supplier = valuesMap.putIfAbsent(subKey , factory );</span><br><span class="line">            if (supplier == null) &#123;</span><br><span class="line">                // successfully installed Factory</span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125;</span><br><span class="line">            // else retry with winning supplier</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (valuesMap .replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                // successfully replaced</span><br><span class="line">                // cleared CacheEntry / unsuccessful Factory</span><br><span class="line">                // with our Factory</span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // retry with current supplier</span><br><span class="line">                supplier = valuesMap.get(subKey );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的Cache是个两级缓存，通过ClassLoader为key来缓存一个ConcurrentMap；该ConcurrentMap的key对应着传入进来的interface参数；</p>
<p>由前面知道subKeyFactory对应的具体类为：ProxyClassFactory，具体来看其apply函数；</p>
<h4 id="5、ProxyClassFactory-apply"><a href="#5、ProxyClassFactory-apply" class="headerlink" title="5、ProxyClassFactory#apply:"></a>5、ProxyClassFactory#apply:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">private static final class ProxyClassFactory</span><br><span class="line">    implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    // prefix for all proxy class names</span><br><span class="line">    private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;</span><br><span class="line"></span><br><span class="line">    // next number to use for generation of unique proxy class names</span><br><span class="line">    private static final AtomicLong nextUniqueNumber = new AtomicLong();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces .length );</span><br><span class="line">       </span><br><span class="line">        /** 对传递进来的interface进行判断</span><br><span class="line">         * 1、先判断该interface是否是通过传递进来的ClassLoader来加载的</span><br><span class="line">         * 2、判断该interface是否为接口</span><br><span class="line">         * 3、判断该接口数组中是否有重复的类  **/</span><br><span class="line">        for (Class&lt;?&gt; intf : interfaces ) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Verify that the class loader resolves the name of this</span><br><span class="line">             * interface to the same Class object.</span><br><span class="line">             */</span><br><span class="line">            Class&lt;?&gt; interfaceClass = null ;</span><br><span class="line">            try &#123;</span><br><span class="line">                interfaceClass = Class.forName( intf.getName(), false, loader );</span><br><span class="line">            &#125; catch (ClassNotFoundException e ) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            if (interfaceClass != intf ) &#123;</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    intf + &quot; is not visible from class loader&quot; );</span><br><span class="line">            &#125;</span><br><span class="line">            /*</span><br><span class="line">             * Verify that the Class object actually represents an</span><br><span class="line">             * interface.</span><br><span class="line">             */</span><br><span class="line">            if (!interfaceClass .isInterface()) &#123;</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    interfaceClass.getName() + &quot; is not an interface&quot; );</span><br><span class="line">            &#125;</span><br><span class="line">            /*</span><br><span class="line">             * Verify that this interface is not a duplicate.</span><br><span class="line">             */</span><br><span class="line">            if (interfaceSet .put(interfaceClass , Boolean.TRUE) != null) &#123;</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                    &quot;repeated interface: &quot; + interfaceClass .getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String proxyPkg = null;     // package to define proxy class in</span><br><span class="line">        int accessFlags = Modifier.PUBLIC | Modifier. FINAL;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Record the package of a non-public proxy interface so that the</span><br><span class="line">         * proxy class will be defined in the same package.  Verify that</span><br><span class="line">         * all non-public proxy interfaces are in the same package.</span><br><span class="line">         */</span><br><span class="line">        /******** 获取该代理类的名称 ********/</span><br><span class="line">        for (Class&lt;?&gt; intf : interfaces ) &#123;</span><br><span class="line">            int flags = intf .getModifiers();</span><br><span class="line">            if (!Modifier.isPublic( flags)) &#123;</span><br><span class="line">                accessFlags = Modifier.FINAL;</span><br><span class="line">                String name = intf.getName();</span><br><span class="line">                int n = name .lastIndexOf(&apos;.&apos;);</span><br><span class="line">                String pkg = (( n == -1) ? &quot;&quot; : name .substring(0, n + 1));</span><br><span class="line">                if (proxyPkg == null) &#123;</span><br><span class="line">                    proxyPkg = pkg;</span><br><span class="line">                &#125; else if (!pkg .equals(proxyPkg )) &#123;</span><br><span class="line">                    throw new IllegalArgumentException(</span><br><span class="line">                        &quot;non-public interfaces from different packages&quot; );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (proxyPkg == null) &#123;</span><br><span class="line">            // if no non-public proxy interfaces, use com.sun.proxy package</span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Choose a name for the proxy class to generate.</span><br><span class="line">         */</span><br><span class="line">        long num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">        // 代理类的名称一般为包名+$ Proxy+num</span><br><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Generate the specified proxy class.</span><br><span class="line">         */</span><br><span class="line">        /** 通过ProxyGenerator.generateProxyClass来具体创建该代理类的二进制码 **/</span><br><span class="line">        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces , accessFlags) ;</span><br><span class="line">        try &#123;</span><br><span class="line">               // 这是一个native类，通过它来具体加载该代理类，返回响应的Class信息</span><br><span class="line">            return defineClass0( loader, proxyName,</span><br><span class="line">                                proxyClassFile, 0, proxyClassFile .length );</span><br><span class="line">        &#125; catch (ClassFormatError e ) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * A ClassFormatError here means that (barring bugs in the</span><br><span class="line">             * proxy class generation code) there was some other</span><br><span class="line">             * invalid aspect of the arguments supplied to the proxy</span><br><span class="line">             * class creation (such as virtual machine limitations</span><br><span class="line">             * exceeded).</span><br><span class="line">             */</span><br><span class="line">            throw new IllegalArgumentException(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）对传递进来的interface进行判断</p>
<ul>
<li>先判断该interface是否是通过传递进来的ClassLoader来加载的</li>
<li>判断该interface是否为接口</li>
<li>判断该接口数组中是否有重复的类<br>2）获取该代理类的名称;代理类的名称一般为包名+$ Proxy+num<br>3）通过ProxyGenerator.generateProxyClass来具体创建该代理类的二进制码<br>4）defineClass0,这是一个native类，通过它来具体加载该代理类，返回响应的Class信息</li>
</ul>
<p>参考博客：<a href="http://blog.csdn.net/u013256816/article/details/51009592" target="_blank" rel="external">http://blog.csdn.net/u013256816/article/details/51009592</a><br><strong>装饰模式和代理模式的区别 ：</strong><br>装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p>
<p><strong>外观模式和代理模式的区别 ：</strong><br>代理与外观的主要区别在于，代理对象代表一个单一对象而外观对象代表一个子系统，代理的客户对象无法直接访问对象，由代理提供单独的目标对象的访问，而通常外观对象提供对子系统各元件功能的简化的共同层次的调用接口。代理是一种原来对象的代表，其他需要与这个对象打交道的操作都是和这个代表交涉的。</p>
<p><strong>适配器模式和代理模式的区别 ：</strong><br>适配器模式改变所考虑的对象的接口，代理模式不能改变所代理对象的接口。</p>
<h1 id="四、外观模式（Fasade）"><a href="#四、外观模式（Fasade）" class="headerlink" title="四、外观模式（Fasade）"></a>四、外观模式（Fasade）</h1><p><strong>外观模式：</strong>为子系统中的一组接口提供一个一致的界面， Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>引入外观角色之后，用户只需要直接与外观角色交互，用户与子系统之间的复杂关系由外观角色来实现，从而降低了系统的耦合度。<br>即提供一个Facade类，来统一操作子系统；适用于子系统比较复杂的情况。</p>
<p><strong>主要解决问题：</strong>组件的客户和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。<br><strong>举个例子：</strong><br>比如，现在有一辆汽车，我们（客户程序）要启动它，那我们就要发动引擎（子系统1），使四个车轮（子系统2）转动。但是实际中我们并不需要用手推动车轮使其转动，我们踩下油门，此时汽车再根据一些其他的操作使车轮转动。油门就好比系统给我们留下的接口，不论汽车是以何种方式转动车轮，车轮变化成什么牌子的，我们要开走汽车所要做的还是踩下油门。<br><strong>使用外观模式之后的效果：</strong><br><img src="http://img.blog.csdn.net/20160525162105489" alt="这里写图片描述"><br><strong>类图：</strong><br><img src="http://img.blog.csdn.net/20160525163305682" alt="这里写图片描述"></p>
<p><strong>其中涉及到的角色有</strong>：<br><strong>外观角色（Facade）</strong>：是模式的核心，他被客户client角色调用，知道各个子系统的功能。同时根据客户角色已有的需求预订了几种功能组合。<br><strong>子系统角色（Subsystem classes）</strong>：实现子系统的功能，并处理由Facade对象指派的任务。对子系统而言，facade和client角色是未知的，没有Facade的任何相关信息；即没有指向Facade的实例。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子系统类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass1 operation1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass2 operation2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass3 operation3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外观类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    SubClass1 subClass1;</span><br><span class="line">    SubClass2 subClass2;</span><br><span class="line">    SubClass3 subClass3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Facade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subClass1 = <span class="keyword">new</span> SubClass1();</span><br><span class="line">        subClass2 = <span class="keyword">new</span> SubClass2();</span><br><span class="line">        subClass3 = <span class="keyword">new</span> SubClass3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subClass1.operation1();</span><br><span class="line">        subClass2.operation2();</span><br><span class="line">        subClass3.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">        facade.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>适用场合：</strong><br> 1）当需要为复杂子系统提供一个外部简单接口来供用户调用使用时，子系统往往会因为不断演化而变得越来越复杂；当一些用户不需要定制子系统时，facade可以为用户提供一个默认缺省的视图来供使用，当有其他需要定制的用户，可以越过facade进行自行定制；这样的模式在开源项目中比较常见，比如Retrofit这些。<br>2）为了避免客户程序和抽象类存在很大的依赖性，引入facade来使得子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。<br>3）减少子系统之间的耦合；当需要构建一个层次结构的子系统时，使用 facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，可以让子系统仅通过facade进行通讯，从而简化了它们之间的依赖关系。</p>
<p><strong>Facade模式的优缺点：</strong><br><strong>优点：</strong><br><strong>1）松散耦合：</strong>门面模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护<br><strong>简单易用：</strong>门面模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟踪多个子系统内部的模块进行交互，只需要跟门面类交互就可以了<br>更好的划分访问层次：通过合理的使用Facade，可以帮助我们更好的划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地掩藏了内部的细节。<br><strong>缺点：</strong><br>1） 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。<br>2） 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</p>
<p>参考博客：<a href="http://blog.csdn.net/u013256816/article/details/51009480" target="_blank" rel="external">http://blog.csdn.net/u013256816/article/details/51009480</a></p>
<h1 id="五、桥接模式（Bridge）"><a href="#五、桥接模式（Bridge）" class="headerlink" title="五、桥接模式（Bridge）"></a>五、桥接模式（Bridge）</h1><p><strong>意图：</strong>将抽象部分与实现部分分离，使它们都可以独立的变化。<br><strong>适用场景：</strong>将抽象与实现分离<br>    设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：<br>第一种设计方案是为每一种形状都提供一套各种颜色的版本。<br>第二种设计方案是根据实际需要对形状和颜色进行组合<br>    对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。<br><strong>类图：</strong><br><img src="http://img.blog.csdn.net/20160525162407804" alt="这里写图片描述"></p>
<p>实现上面的案例得：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Abstraction抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> IColor color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IShape</span><span class="params">(IColor color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementor实现类接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IColor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteImplementor具体实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorRed</span> <span class="keyword">extends</span> <span class="title">IColor</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Color is Red"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorBlue</span> <span class="keyword">extends</span> <span class="title">IColor</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Color is Blue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RefinedAbstraction扩充抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">IShape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(IColor color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"It is a rectangle"</span>);</span><br><span class="line">        color.operationImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Oval</span> <span class="keyword">extends</span> <span class="title">IShape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Oval</span><span class="params">(IColor color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"It is a Oval"</span>);</span><br><span class="line">        color.operationImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cient使用类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IShape shape1 = <span class="keyword">new</span> Rectangle(<span class="keyword">new</span> ColorRed());</span><br><span class="line">        IShape shape2 = <span class="keyword">new</span> Oval(<span class="keyword">new</span> ColorBlue());</span><br><span class="line">        shape1.operation();</span><br><span class="line">        shape2.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优缺点：</strong><br><strong>1）优点：</strong><br>分离抽象接口及其实现部分。<br>桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。<br>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。<br>实现细节对客户透明，可以对用户隐藏实现细节。<br><strong>2）缺点 ：</strong><br>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进 行设计与编程。<br>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</p>
<p><strong>适用环境：</strong><br>如果你不希望在抽象和实现部分采用固定的绑定关系，可以采用桥接模式，来把抽象和实现部分分开，然后在程序运行期间来动态的设置抽象部分需要用到的具体的实现，还可以动态切换具体的实现。<br>如果出现抽象部分和实现部分都应该可以扩展的情况，可以采用桥接模式，让抽象部分和实现部分可以独立的变化，从而可以灵活的进行单独扩展，而不是搅在一起，扩展一边会影响到另一边。<br>如果希望实现部分的修改，不会对客户产生影响，可以采用桥接模式，客户是面向抽象的接口在运行，实现部分的修改，可以独立于抽象部分，也就不会对客户产生影响了，也可以说对客户是透明的。<br>如果采用继承的实现方案，会导致产生很多子类，对于这种情况，可以考虑采用桥接模式，分析功能变化的原因，看看是否能分离成不同的纬度，然后通过桥接模式来分离它们，从而减少子类的数目。</p>
<h1 id="六、组合模式（Composite）"><a href="#六、组合模式（Composite）" class="headerlink" title="六、组合模式（Composite）"></a>六、组合模式（Composite）</h1><p><strong>概念：</strong>将对象组合成树形结构以表示“部分-整体”的层次结构。 组合模式使得用户对单个对象和组合对象的使用具有唯一性。<br><strong>应用：</strong>组合模式比较典型的应用就是<br>1）文件目录结构<br>2）Android中的ViewGroup和View<br><img src="http://img.blog.csdn.net/20160525162506414" alt="这里写图片描述"></p>
<p><strong>适用性：</strong>组合模式解耦了客户程序与复杂元素内部结构，从而使客户程序可以向处理简单元素一样来处理复杂元素。<br>如果你想要创建层次结构，并可以在其中以相同的方式对待所有元素，那么组合模式就是最理想的选择。<br>1）表示对象的部分-整体层次结构，如树形菜单、文件夹菜单、部门组织架构等。<br>2）用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。<br><strong>类图：</strong><br><img src="http://img.blog.csdn.net/20160525162606697" alt="这里写图片描述"><br><strong>涉及角色：</strong><br>1） Component：是组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component.<br>2） Leaf：在组合中表示叶子节点对象，叶子节点没有子节点。<br>3） Composite：定义树枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加和删除等。<br><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Component</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Leaf "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function">Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Component&gt; childs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Composite</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        childs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Component child : childs)</span><br><span class="line">            child.operation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        childs.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        childs.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> childs.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Component leaf1 = <span class="keyword">new</span> Leaf(<span class="string">"leaf1"</span>);</span><br><span class="line">        Composite com = <span class="keyword">new</span> Composite(<span class="string">"Composite"</span>);</span><br><span class="line">        com.add(leaf1);</span><br><span class="line">        com.add(<span class="keyword">new</span> Leaf(<span class="string">"leaf2"</span>));</span><br><span class="line">        </span><br><span class="line">        Composite com2 = <span class="keyword">new</span> Composite(<span class="string">"Composite2"</span>);</span><br><span class="line">        com2.add(<span class="keyword">new</span> Leaf(<span class="string">"l3"</span>));</span><br><span class="line">        com2.add(com);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优缺点：</strong><br><strong>优点：</strong><br>1）可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易。<br>2）客户端调用简单，客户端可以一致的使用组合结构或其中单个对象。<br>3）定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可以形成复杂的树形结构。<br>4）更容易在组合体内加入对象构件，客户端不必因为加入了新的对象构件而更改原有代码。<br><strong>缺点 ：</strong>使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联</p>
<h1 id="七、享元模式（FlyWeight）"><a href="#七、享元模式（FlyWeight）" class="headerlink" title="七、享元模式（FlyWeight）"></a>七、享元模式（FlyWeight）</h1><p><strong>背景：</strong>面向对象可以非常方便的解决一些扩展性的问题，但是在这个过程中系统务必会产生一些类或者对象，如果系统中存在对象的个数过多时，将会导致系统的性能下降。对于这样的问题解决最简单直接的办法就是减少系统中对象的个数。<br>    享元模式提供了一种解决方案，使用共享技术实现相同或者相似对象的重用。也就是说实现相同或者相似对象的代码共享。<br>Java中最典型的应用就是String：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"a"</span>;</span><br><span class="line">String s2 = <span class="string">"a"</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">// String采用享元模式 存储在常量池</span></span><br></pre></td></tr></table></figure>
<p><strong>定义：</strong>运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。<br><strong>概念：</strong>在了解享元模式之前我们先要了解两个概念：内部状态、外部状态。<br>      <strong>内部状态：</strong>在享元对象内部不随外界环境改变而改变的共享部分。<br>      <strong>外部状态：</strong>随着环境的改变而改变，不能够共享的状态就是外部状态。<br>      由于享元模式区分了内部状态和外部状态，所以我们可以通过设置不同的外部状态使得相同的对象可以具备一些不同的特性，而内部状态设置为相同部分。在我们的程序设计过程中，我们可能会需要大量的细粒度对象来表示对象，如果这些对象除了几个参数不同外其他部分都相同，这个时候我们就可以利用享元模式来大大减少应用程序当中的对象。如何利用享元模式呢？这里我们只需要将他们少部分的不同的部分当做参数移动到类实例的外部去，然后再方法调用的时候将他们传递过来就可以了。这里也就说明了一点：内部状态存储于享元对象内部，而外部状态则应该由客户端来考虑。</p>
<p>享元模式分为两种：<strong>单纯享元模式</strong>和<strong>复合享元模式</strong>两种形式；<br><strong>（一）单纯享元模式：</strong><br>在单纯的享元模式中，所有的享元对象都是可以共享的。<br><strong>类图：</strong><br><img src="http://img.blog.csdn.net/20160525162731976" alt="这里写图片描述"><br><strong>涉及角色：</strong><br><strong>Flyweight:</strong> 抽象享元类。所有具体享元类的超类或者接口，通过这个接口，Flyweight可以接受并作用于外部专题<br><strong>ConcreteFlyweight:</strong> 具体享元类。指定内部状态，为内部状态增加存储空间。<br><strong>FlyweightFactory:</strong> 享元工厂类。用来创建并管理Flyweight对象，它主要用来确保合理地共享Flyweight，当用户请求一个Flyweight时，FlyweightFactory就会提供一个已经创建的Flyweight对象或者新建一个（如果不存在）。<br>    享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。<br><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Flywight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(String externalState)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title">Flywight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String internalState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight</span><span class="params">(String internalState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.internalState = internalState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">(String externalState)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"内部状态:"</span> + internalState);</span><br><span class="line">        System.out.println(<span class="string">"外部状态:"</span> + externalState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Flywight&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flywight <span class="title">getFlyweight</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        Flywight flywight = map.get(state);</span><br><span class="line">        <span class="keyword">if</span> (flywight == <span class="keyword">null</span>) &#123;</span><br><span class="line">            flywight = <span class="keyword">new</span> ConcreteFlyweight(state);</span><br><span class="line">            map.put(state, flywight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flywight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（二）复合享元模式：</strong><br>    在单纯享元模式中，所有的享元对象都是单纯享元对象，也就是说都是可以直接共享的。还有一种较为复杂的情况，将一些单纯享元使用合成模式加以复合，形成复合享元对象。这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。</p>
<p><strong>类图：</strong><br><img src="http://img.blog.csdn.net/20160525162828758" alt="这里写图片描述"><br><strong>角色：</strong><br><strong>抽象享元(Flyweight)</strong> ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。<br><strong>具体享元(ConcreteFlyweight)</strong>：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。<br><strong>复合享元(ConcreteCompositeFlyweight)</strong> ：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象。<br><strong>享元工厂(FlyweightFactory)</strong> ：负责创建和管理享元角色。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Flywight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(String externalState)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title">Flywight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String internalState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight</span><span class="params">(String internalState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.internalState = internalState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">(String externalState)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"内部状态:"</span> + internalState);</span><br><span class="line">        System.out.println(<span class="string">"外部状态:"</span> + externalState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCompositeFlyweight</span> <span class="keyword">extends</span> <span class="title">Flywight</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Flywight&gt; list = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String state, Flywight flywight)</span> </span>&#123;</span><br><span class="line">        list.put(state, flywight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">(String externalState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Flywight&gt; data : list.entrySet()) &#123;</span><br><span class="line">            data.getValue().operation(externalState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Flywight&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flywight <span class="title">getFlyweight</span><span class="params">(List&lt;String&gt; states)</span> </span>&#123;</span><br><span class="line">        ConcreteCompositeFlyweight ccFlyweight = <span class="keyword">new</span> ConcreteCompositeFlyweight();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String state : states)</span><br><span class="line">            ccFlyweight.add(state, getFlyweight(state));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ccFlyweight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flywight <span class="title">getFlyweight</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        Flywight flywight = map.get(state);</span><br><span class="line">        <span class="keyword">if</span> (flywight == <span class="keyword">null</span>) &#123;</span><br><span class="line">            flywight = <span class="keyword">new</span> ConcreteFlyweight(state);</span><br><span class="line">            map.put(state, flywight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flywight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优缺点：</strong><br>享元模式的优点在于它大幅度地降低内存中对象的数量。但是，它做到这一点所付出的代价也是很高的：<br>1）享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。<br>2）享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-View机制深入学习（五） 事件处理机制一" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/10/View机制深入学习（五） 事件处理机制一/" class="article-date">
      <time datetime="2016-05-10T09:28:45.538Z" itemprop="datePublished">2016-05-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/10/View机制深入学习（五） 事件处理机制一/">View机制深入学习（五） 事件处理机制一</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>以TouchEvent为主，看一下View和ViewGroup内部是如何处理Input Events的；<br>首先来看事件的产生来源：</p>
<h1 id="一、获取事件"><a href="#一、获取事件" class="headerlink" title="一、获取事件:"></a>一、获取事件:</h1><p>事件的来源可以分为“软件”，“硬件”两种；<br>主要的事件包含有：<br><strong>按键事件（KeyEvent）</strong>    :即物理按键按下产生的事件，相关的常用物理按键一般有HOME,BACK等<br><strong>触摸事件（TouchEvent）</strong>:<br>鼠标事件（MouseEvent）、轨迹球事件（TrackBallEvent）（这两个已经不常见）；</p>
<p>针对所有事件的共性抽象出了InputEvent接口；其有两个子类：KeyEvent,MotionEvent;</p>
<h2 id="1、事件的投递流程："><a href="#1、事件的投递流程：" class="headerlink" title="1、事件的投递流程："></a>1、事件的投递流程：</h2><p><img src="http://img.blog.csdn.net/20160525165429483" alt="这里写图片描述"></p>
<p><strong>1&gt;源信息采集</strong><br>    对“硬件源”产生的原始信息进行收集；它需要Linux内核驱动的支持，Android系统通过/dev/input下的节点来访问当前发生的事件。<br><strong>2&gt;前期处理</strong><br>    对收集到信息进行筛选以及格式转化<br><strong>3&gt;WMS分配</strong><br>    WMS是窗口的Manager，同时也是InputEvent的派发者。<br><strong>4&gt;应用程序处理</strong><br>    WMS会先把事件传递到对应ViewRootImpl，ViewRootImpl分发事件，传递给相应的DecorView,DecorView在调用Activity中的Window.Callback将事件传递给Activity；然后Activity在通过dispatchTouchEvent分发事件，下面就来到熟悉的View事件分发机制；具体见<a href="http://blog.csdn.net/woliuyunyicai/article/details/49866177" target="_blank" rel="external">《View机制深入学习（四）View的事件分发机制》</a></p>
<h2 id="2、InputManagerService启动"><a href="#2、InputManagerService启动" class="headerlink" title="2、InputManagerService启动:"></a>2、InputManagerService启动:</h2><p>InputManagerService同样也是有SystemServer进程启动，这个在<a href="http://blog.csdn.net/woliuyunyicai/article/details/47749009" target="_blank" rel="external">Android启动过程——init.rc,Zygote,SystemServer</a>中已经提到过，<br>系统启动后创建init进程（pid=1）,init进程创建出Zygote进程，然后Zygote进程孵化出SystemServer进程，在SystemServer进程中创建IMS：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@path</span>: \frameworks\base\services\java\com\android\server\SystemServer.java */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以看到IMS和WMS是紧密相关的</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// @value InputManagerService inputManager</span></span><br><span class="line">        inputManager = <span class="keyword">new</span> InputManagerService(context, wmHandler);</span><br><span class="line"></span><br><span class="line">        Slog.i(TAG, <span class="string">"Window Manager"</span>);</span><br><span class="line">        <span class="comment">// @value WindowManagerService wm</span></span><br><span class="line">        wm = WindowManagerService.main(context, power, display, inputManager,</span><br><span class="line">                uiHandler, wmHandler,</span><br><span class="line">                factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">                !firstBoot, onlyCore);</span><br><span class="line">        ServiceManager.addService(Context.WINDOW_SERVICE, wm);</span><br><span class="line">        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);</span><br><span class="line"></span><br><span class="line">        ActivityManagerService.self().setWindowManager(wm);</span><br><span class="line"></span><br><span class="line">        inputManager.setWindowManagerCallbacks(wm.getInputMonitor());</span><br><span class="line">        inputManager.start();</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、InputMangerService："><a href="#3、InputMangerService：" class="headerlink" title="3、InputMangerService："></a>3、InputMangerService：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\java\com\android\server\input\InputManagerService.java **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputManagerService</span> <span class="keyword">extends</span> <span class="title">IInputManager</span>.<span class="title">Stub</span> <span class="keyword">implements</span> <span class="title">Watchdog</span>.<span class="title">Monitor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指向native端IMS类对象的地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> mPtr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputManagerService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">        <span class="keyword">this</span>.mHandler = <span class="keyword">new</span> InputManagerHandler(DisplayThread.get().getLooper());</span><br><span class="line"></span><br><span class="line">        mUseDevInputEventForAudioJack = context.getResources().getBoolean(R.bool.config_useDevInputEventForAudioJack);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建native IMS对象</span></span><br><span class="line">        mPtr = nativeInit(<span class="keyword">this</span>, mContext, mHandler.getLooper().getQueue());</span><br><span class="line"></span><br><span class="line">        LocalServices.addService(InputManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到Java层的IMS实际上只是对Native层的InputManager的一层包装；其创建主要是native层进行创建，并把native层的InputManager地址赋值给InputManagerService的mPtr变量；<br>而且注意nativeInit中传入了Looper中的MessageQueue变量；</p>
<h2 id="4、native层的InputManagerService——NativeInputManager类："><a href="#4、native层的InputManagerService——NativeInputManager类：" class="headerlink" title="4、native层的InputManagerService——NativeInputManager类："></a>4、native层的InputManagerService——NativeInputManager类：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span></span><br><span class="line"><span class="keyword">class</span> NativeInputManager : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase,</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> InputReaderPolicyInterface,</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> InputDispatcherPolicyInterface,</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> PointerControllerPolicyInterface</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz,</span><br><span class="line">                        jobject serviceObj, jobject contextObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个Message Queue</span></span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"MessageQueue is not initialized."</span>);</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以看到NativeInputManager中包含有一个Looper，用以进行事件分派</span></span><br><span class="line">    NativeInputManager* im = new NativeInputManager(contextObj, serviceObj,</span><br><span class="line">            messageQueue-&gt;getLooper());</span><br><span class="line">    im-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 返回创建的IMS实例对象的地址（强制转化为long类型）</span></span><br><span class="line">    return <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(im);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到首先通过android_os_MessageQueue_getMessageQueue函数获取到本地端的MessageQueue，这个在Handler机制中的本地解析<a href="http://blog.csdn.net/woliuyunyicai/article/details/50780529" target="_blank" rel="external">《Handler机制深入解析》</a>中已经提到，该NativeMessageQueue对象在java层创建Looper时创建实例，然后将地址指针赋值为Looper对应的MessageQueue中的ptr变量中，这里根据指针来获取该NativeMessageQueue对象；<br>根据NativeMessageQueue对象获取其中对应的Looper（native），用以创建NativeInputManger;来看NativeInputManager的构造函数：</p>
<h2 id="5、NativeInputManager-NativeInputManager"><a href="#5、NativeInputManager-NativeInputManager" class="headerlink" title="5、NativeInputManager#NativeInputManager:"></a>5、NativeInputManager#NativeInputManager:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span></span><br><span class="line">NativeInputManager::NativeInputManager(jobject contextObj,</span><br><span class="line">                                       jobject serviceObj, <span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper) :</span><br><span class="line">        mLooper(looper), mInteractive(<span class="literal">true</span>) &#123;</span><br><span class="line">    JNIEnv* env = jniEnv();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局引用</span></span><br><span class="line">    mContextObj = env-&gt;NewGlobalRef(contextObj);</span><br><span class="line">    mServiceObj = env-&gt;NewGlobalRef(serviceObj);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mLocked.systemUiVisibility = ASYSTEM_UI_VISIBILITY_STATUS_BAR_VISIBLE;</span><br><span class="line">        mLocked.pointerSpeed = <span class="number">0</span>;</span><br><span class="line">        mLocked.pointerGesturesEnabled = <span class="literal">true</span>;</span><br><span class="line">        mLocked.showTouches = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建EventHUb</span></span><br><span class="line">    sp&lt;EventHub&gt; eventHub = new EventHub();</span><br><span class="line">    <span class="comment">// 创建InputManager实例</span></span><br><span class="line">    mInputManager = new InputManager(eventHub, this, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NativeInputManager中保存了Looper(native)实例；并且创建了EventHub，以及InputManager两个重要的对象；<br>EventHub从名字就可以看出，它是用来收集以及存储外部的输入事件的；<br>而InputManager则是对Event事件进行处理分发；<br>先来看EventHub：</p>
<h3 id="（一）EventHub："><a href="#（一）EventHub：" class="headerlink" title="（一）EventHub："></a>（一）EventHub：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*\frameworks\native\services\inputflinger\EventHub*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *DEVICE_PATH = <span class="string">"/dev/input"</span>;</span><br><span class="line">EventHub::EventHub(<span class="keyword">void</span>) :</span><br><span class="line">        mBuiltInKeyboardId(NO_BUILT_IN_KEYBOARD), mNextDeviceId(<span class="number">1</span>), mControllerNumbers(),</span><br><span class="line">        mOpeningDevices(<span class="number">0</span>), mClosingDevices(<span class="number">0</span>),</span><br><span class="line">        mNeedToSendFinishedDeviceScan(<span class="literal">false</span>),</span><br><span class="line">        mNeedToReopenDevices(<span class="literal">false</span>), mNeedToScanDevices(<span class="literal">true</span>),</span><br><span class="line">        mPendingEventCount(<span class="number">0</span>), mPendingEventIndex(<span class="number">0</span>), mPendingINotify(<span class="literal">false</span>) &#123;</span><br><span class="line">    acquire_wake_lock(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建epoll对象</span></span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用inotify机制监听文件或目录的移动、读取、写入或删除等事件</span></span><br><span class="line">    <span class="comment">// 创建一个inotify对象</span></span><br><span class="line">    mINotifyFd = inotify_init();</span><br><span class="line">    <span class="comment">// 把监控项添加到mINotifyFd对象的监控列表中</span></span><br><span class="line">    <span class="comment">// 这里监听的文件路径为"/dev/input"</span></span><br><span class="line">    <span class="keyword">int</span> result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> epoll_event eventItem;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(eventItem));</span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_INOTIFY;</span><br><span class="line">    <span class="comment">// 把inotify对象mINotifyFd添加到epoll对象的兴趣列表中，此处采用inotify与epoll机制结合起来检查文件</span></span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> wakeFds[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 创建pipe</span></span><br><span class="line">    result = pipe(wakeFds);</span><br><span class="line"></span><br><span class="line">    mWakeReadPipeFd = wakeFds[<span class="number">0</span>];</span><br><span class="line">    mWakeWritePipeFd = wakeFds[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 设置为非阻塞</span></span><br><span class="line">    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_WAKE;</span><br><span class="line">    <span class="comment">// 添加到epoll的兴趣列表中</span></span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> major, minor;</span><br><span class="line">    getLinuxRelease(&amp;major, &amp;minor);</span><br><span class="line">    <span class="comment">// EPOLLWAKEUP was introduced in kernel 3.5</span></span><br><span class="line">    mUsingEpollWakeup = major &gt; <span class="number">3</span> || (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面进行了一系列的变量的初始化；<br>然后epoll_create创建了一个epoll对象，可以看到和Handler中一样，IMS中也用到了epoll机制进行监听；<br>而后可以看到IMS是INotify机制和Epoll机制同时使用的：inotify_init创建iNotify对象，inotify_add_watch则将”/dev/input”路径添加到监听列表中；当”/dev/input”中文件发生变化，将会产生响应；<br>了解INotifiy文件系统监听机制：<br><a href="https://www.ibm.com/developerworks/cn/linux/l-inotifynew/" target="_blank" rel="external">《inotify – Linux 2.6 内核中的文件系统变化通知机制》</a><br><a href="http://www.infoq.com/cn/articles/inotify-linux-file-system-event-monitoring" target="_blank" rel="external">《Inotify: 高效、实时的Linux文件系统事件监控框架》</a><br>然后将iNotify对象添加到Epoll的兴趣列表中，进行监听；<br>然后同Handler机制，创建一个Pipe，然后设置为非阻塞形式，然后添加到epoll的兴趣列表中；下面就注意在何时调用epoll_wait来开启监听即可；这里仅进行了初始化；</p>
<h3 id="（二）InputManager："><a href="#（二）InputManager：" class="headerlink" title="（二）InputManager："></a>（二）InputManager：</h3><h4 id="1）构造函数："><a href="#1）构造函数：" class="headerlink" title="1）构造函数："></a>1）构造函数：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputManager.cpp **/</span></span><br><span class="line"><span class="keyword">class</span> InputManagerInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    sp&lt;InputReaderInterface&gt; mReader;</span><br><span class="line">    sp&lt;InputReaderThread&gt; mReaderThread;</span><br><span class="line"></span><br><span class="line">    sp&lt;InputDispatcherInterface&gt; mDispatcher;</span><br><span class="line">    sp&lt;InputDispatcherThread&gt; mDispatcherThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    InputManager::InputManager(</span><br><span class="line">            <span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;</span><br><span class="line">        <span class="comment">// 创建InputDispatcher</span></span><br><span class="line">        mDispatcher = new InputDispatcher(dispatcherPolicy);</span><br><span class="line">        <span class="comment">// 创建InputReader</span></span><br><span class="line">        mReader = new InputReader(eventHub, readerPolicy, mDispatcher);</span><br><span class="line">        initialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 进行初始化 **/</span></span><br><span class="line">    <span class="keyword">void</span> InputManager::initialize() &#123;</span><br><span class="line">        <span class="comment">// 创建两个Thread的实例</span></span><br><span class="line">        mReaderThread = new InputReaderThread(mReader);</span><br><span class="line">        mDispatcherThread = new InputDispatcherThread(mDispatcher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>InputManager中传入了前面创建的EventHub对象；然后初始化了两个中重要的类，InputDispatcher，以及InputReader;<br>显然从名字可以看出 InputReader用来读取EventHub中的事件，然后通过InputDiapatcher进行分发（InputReader中持有InputDisptcher的引用）；</p>
<p><strong>先看InputDispatcher:</strong></p>
<h5 id="1-1）InputDispatcher"><a href="#1-1）InputDispatcher" class="headerlink" title="1.1）InputDispatcher:"></a>1.1）InputDispatcher:</h5><p><strong>继承关系：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> InputDispatcher : <span class="keyword">public</span> InputDispatcherInterface</span><br><span class="line"><span class="keyword">class</span> InputDispatcherInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase, <span class="keyword">public</span> InputListenerInterface</span><br></pre></td></tr></table></figure>
<p><strong>构造函数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line">InputDispatcher::InputDispatcher(<span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy) :</span><br><span class="line">    mPolicy(policy),</span><br><span class="line">    mPendingEvent(<span class="literal">NULL</span>), mAppSwitchSawKeyDown(<span class="literal">false</span>), mAppSwitchDueTime(LONG_LONG_MAX),</span><br><span class="line">    mNextUnblockedEvent(<span class="literal">NULL</span>),</span><br><span class="line">    mDispatchEnabled(<span class="literal">false</span>), mDispatchFrozen(<span class="literal">false</span>), mInputFilterEnabled(<span class="literal">false</span>),</span><br><span class="line">    mInputTargetWaitCause(INPUT_TARGET_WAIT_CAUSE_NONE) &#123;</span><br><span class="line">    <span class="comment">// 可以看到这里创建了一个Looper</span></span><br><span class="line">    mLooper = new Looper(false);</span><br><span class="line"></span><br><span class="line">    mKeyRepeatState.lastKeyEntry = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    policy-&gt;getDispatcherConfiguration(&amp;mConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造函数中创建了一个Looper（native），注意这里是新创建了一个Looper对象，和ThreadLocal中该线程中的Looper是没有关系的；<br>再来看InputReader</p>
<h5 id="1-2）InputReader："><a href="#1-2）InputReader：" class="headerlink" title="1.2）InputReader："></a>1.2）InputReader：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> InputReader : <span class="keyword">public</span> InputReaderInterface</span><br><span class="line"><span class="keyword">class</span> InputReaderInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</span><br></pre></td></tr></table></figure>
<p><strong>构造函数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputReader.cpp **/</span></span><br><span class="line">InputReader::InputReader(<span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub, <span class="comment">// 前面提到的创建的EventHub</span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; policy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) :           <span class="comment">// 即传入进来的InputDispatcher</span></span><br><span class="line">        mContext(<span class="keyword">this</span>), mEventHub(eventHub), mPolicy(policy),   <span class="comment">// 一系列初始化</span></span><br><span class="line">        mGlobalMetaState(<span class="number">0</span>), mGeneration(<span class="number">1</span>),</span><br><span class="line">        mDisableVirtualKeysTimeout(LLONG_MIN), mNextTimeout(LLONG_MAX),</span><br><span class="line">        mConfigurationChangesToRefresh(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个QueuedInputListener对象，赋值给mQueuedListener</span></span><br><span class="line">    mQueuedListener = new QueuedInputListener(listener);</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        refreshConfigurationLocked(<span class="number">0</span>);</span><br><span class="line">        updateGlobalMetaStateLocked();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InputReader中包含了前面创建的EventHub，以及用以分发事件的InputDispatcher;在InputReader内部，将其封装成了QueuedInputListener类；</p>
<p>继续InputManager构造函数中内容，initialize进行初始化：</p>
<h4 id="2）InputManager-initialize"><a href="#2）InputManager-initialize" class="headerlink" title="2）InputManager#initialize:"></a>2）InputManager#initialize:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 进行初始化 **/</span></span><br><span class="line"><span class="keyword">void</span> InputManager::initialize() &#123;</span><br><span class="line"><span class="comment">// 创建两个Thread的实例</span></span><br><span class="line">mReaderThread = new InputReaderThread(mReader);</span><br><span class="line">    mDispatcherThread = new InputDispatcherThread(mDispatcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新创建了两个对象，这两个类都是继承Thread的，即对应地使用InputReader，以及InputDispatcher为参数创建了两个线程；<br>分别来看：</p>
<h5 id="2-1-gt-InputReaderThread："><a href="#2-1-gt-InputReaderThread：" class="headerlink" title="2.1&gt; InputReaderThread："></a>2.1&gt; InputReaderThread：</h5><p><strong>2.1.1）InputReaderThread类：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputReader.h **/</span></span><br><span class="line"><span class="comment">/** 无限循环从event hub中读取event,然后读取processes他们  */</span></span><br><span class="line"><span class="keyword">class</span> InputReaderThread : <span class="keyword">public</span> Thread &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    InputReaderThread(<span class="keyword">const</span> sp&lt;InputReaderInterface&gt;&amp; reader);</span><br><span class="line">    <span class="keyword">virtual</span> ~InputReaderThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    sp&lt;InputReaderInterface&gt; mReader;</span><br><span class="line">    <span class="comment">/** 继承Thread的子类必须实现该函数，因为这个其实是Thread的真正执行函数 **/</span></span><br><span class="line">    <span class="comment">// Derived class must implement threadLoop(). The thread starts its life</span></span><br><span class="line">    <span class="comment">// here. There are two ways of using the Thread object:</span></span><br><span class="line">    <span class="comment">// 1) loop: if threadLoop() returns true, it will be called again if</span></span><br><span class="line">    <span class="comment">//          requestExit() wasn't called.</span></span><br><span class="line">    <span class="comment">// 2) once: if threadLoop() returns false, the thread will exit upon return.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到InputReaderThread是一个Thread类，它的线程函数入口为threadLoop;</p>
<p><strong>2.1.2）InputReaderThread类构造函数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputReader.cpp **/</span></span><br><span class="line">    InputReaderThread::InputReaderThread(<span class="keyword">const</span> sp&lt;InputReaderInterface&gt;&amp; reader) :</span><br><span class="line">    Thread(<span class="comment">/*canCallJava*/</span><span class="literal">true</span>), mReader(reader) &#123;</span><br><span class="line">        <span class="comment">// 这里初始化重要变量sp&lt;InputReaderInterface&gt; mReader</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> InputReaderThread::threadLoop() &#123;</span><br><span class="line">        <span class="comment">// 调用mReader中的loopOnce函数，可以看出InputReaderInterface是该类的核心</span></span><br><span class="line">        mReader-&gt;loopOnce();</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>InputReaderThread的核心逻辑为调用InputReader的loopOnce函数；暂且停在这里，因为Thread只是创建，并未运行，等分析到具体运行代码时再作分析；</p>
<h5 id="2-2-gt-InputDispatcherThread"><a href="#2-2-gt-InputDispatcherThread" class="headerlink" title="2.2&gt;InputDispatcherThread"></a>2.2&gt;InputDispatcherThread</h5><p>/<strong> \frameworks\native\services\inputflinger\InputDispatcher.h </strong>/</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> InputDispatcherThread : <span class="keyword">public</span> Thread &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">InputDispatcherThread</span><span class="params">(<span class="keyword">const</span> sp&lt;InputDispatcherInterface&gt;&amp; dispatcher)</span></span>;</span><br><span class="line">    ~InputDispatcherThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">boolthreadLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    sp&lt;InputDispatcherInterface&gt; mDispatcher;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> InputDispatcherThread::threadLoop() &#123;</span><br><span class="line">    mDispatcher-&gt;dispatchOnce();</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 该类同样是一个Thread，其主要运行逻辑即调用InputDispatcher中的dispatchOnce函数；</p>
<p>回到InputManagerService在SystemServer进程中的创建过程知道，接下来创建WindowManagerService，然后将InputManagerService实例传递给WMS，然后调用InputManagerService.start开始工作。</p>
<h2 id="7、InputManagerService-start"><a href="#7、InputManagerService-start" class="headerlink" title="7、InputManagerService#start:"></a>7、InputManagerService#start:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\java\com\android\server\input\InputManagerService.java **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    nativeStart(mPtr);</span><br><span class="line">    <span class="comment">// Add ourself to the Watchdog monitors.</span></span><br><span class="line">    Watchdog.getInstance().addMonitor(<span class="keyword">this</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以看到start仅是对nativeStart本地方法进行封装，继续通过JNI来调用本地端的start函数；注意这里创建了WatchDog看门狗线程，并且把InputManagerService实例添加到WatchDog的监听；系统创建看门狗线程，每隔一段时间向管道中写入数据唤醒InputReader线程（后面会提到）去读取事件，看门狗WatchDog实际上也是一个线程，只不过会定时发送消息给InputReader线程读取输入事件。</p>
<h2 id="8、NativeInputManager-nativeStart"><a href="#8、NativeInputManager-nativeStart" class="headerlink" title="8、NativeInputManager#nativeStart:"></a>8、NativeInputManager#nativeStart:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ptr为创建的IMS实例的地址，这里将其强制转化成为NativeInputManager类</span></span><br><span class="line">    NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里进一步调用InputManager的star方法</span></span><br><span class="line">    <span class="keyword">status_t</span> result = im-&gt;getInputManager()-&gt;start();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Input manager could not be started."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @value sp&lt;InputManager&gt; mInputManager;</span></span><br><span class="line"><span class="keyword">inline</span> sp&lt;InputManager&gt; getInputManager() <span class="keyword">const</span> &#123; return mInputManager; &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里进一步调用了InputManager的start方法；IMS在Native层的主要实现实体其实是InputManager。</p>
<h2 id="9、InputManager-start："><a href="#9、InputManager-start：" class="headerlink" title="9、InputManager#start："></a>9、InputManager#start：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputManager.cpp **/</span></span><br><span class="line"><span class="keyword">class</span> InputManagerInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    sp&lt;InputReaderInterface&gt; mReader;</span><br><span class="line">    sp&lt;InputReaderThread&gt; mReaderThread;</span><br><span class="line"></span><br><span class="line">    sp&lt;InputDispatcherInterface&gt; mDispatcher;</span><br><span class="line">    sp&lt;InputDispatcherThread&gt; mDispatcherThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start函数</span></span><br><span class="line">    <span class="keyword">status_t</span> InputManager::start() &#123;</span><br><span class="line">        <span class="comment">// 可以看到这里会开启两个线程mDispatcherThread，与mReaderThread</span></span><br><span class="line">        <span class="comment">// 分别对应InputReaderThread，InputDispatcherThread</span></span><br><span class="line">        <span class="keyword">status_t</span> result = mDispatcherThread-&gt;run(<span class="string">"InputDispatcher"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">        ......</span><br><span class="line">        result = mReaderThread-&gt;run(<span class="string">"InputReader"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            mDispatcherThread-&gt;requestExit();</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        return OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  回到InputManager中来，来看start函数中所做的工作，在start中调用两个thread的run函数正是开启线程；由Thread的线程入口为threadLoop；前面已经提到了这两个Thread的入口函数，这里来看其中的具体工作逻辑；</p>
<h2 id="10、InputDispatcherThread-amp-InputReaderThread"><a href="#10、InputDispatcherThread-amp-InputReaderThread" class="headerlink" title="10、InputDispatcherThread&amp;InputReaderThread"></a>10、InputDispatcherThread&amp;InputReaderThread</h2><p><strong>InputDispatcherThread#threadLoop:</strong><br>由前面知InputDispatcherThread中主要通过调用InputDispatcher的dispathOnce来实现的；</p>
<h3 id="1）InputDispatcher-dispatchOnce"><a href="#1）InputDispatcher-dispatchOnce" class="headerlink" title="1）InputDispatcher::dispatchOnce:"></a>1）InputDispatcher::dispatchOnce:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mDispatcherIsAliveCondition.broadcast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在没有等待的commands事运行一个dispatch loop，这个loop之后可能enqueue commands</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有等待的commands的话，就运行所有的commands</span></span><br><span class="line">        <span class="comment">// If any commands were run then force the next poll to wake up immediately.</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始状态下是没有事件的，来到mLooper-&gt;pollOnce，了解Handler机制的native层知道，在pollOnce中调用epoll_wait对前面设置的兴趣事件进行监听，然后InputDispatchThread进入休眠等待唤醒；可想而知下面策略是InputReaderThread来对其进行唤醒；</p>
<p><strong>InputReaderThread#threadLoop:</strong><br>InputReaderThread中的主要逻辑是调用InputReader中的loopOnce函数</p>
<h3 id="1）InputReader-loopOnce"><a href="#1）InputReader-loopOnce" class="headerlink" title="1）InputReader#loopOnce :"></a>1）InputReader#loopOnce :</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** \frameworks\native\services\inputflinger\InputReader.h **/</span></span><br><span class="line">    <span class="keyword">class</span> InputReaderInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</span><br><span class="line">    <span class="keyword">class</span> InputReader : <span class="keyword">public</span> InputReaderInterface</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** \frameworks\native\services\inputflinger\InputReader.cpp **/</span></span><br><span class="line"><span class="comment">// loopOnce即事件处理函数</span></span><br><span class="line">    <span class="keyword">void</span> InputReader::loopOnce() &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 其实是通过mEventHub来获取Events的</span></span><br><span class="line">        <span class="comment">// @value sp&lt;EventHubInterface&gt; mEventHub;</span></span><br><span class="line">        <span class="keyword">size_t</span> count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// @value sp&lt;QueuedInputListener&gt; mQueuedListener;</span></span><br><span class="line">        mQueuedListener-&gt;flush();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到这里通过EventHub的getEvents来获取/dev/input中的Event事件，然后用到前面提到的封装了InputDispatcher的QueueListener来分发事件；<br>EventHub获取Events的具体流程：<a href="http://www.feeyan.cn/?p=280" target="_blank" rel="external">Android按键事件传递流程(一)</a><br>主要工作流程是注册这些监听的devices，然后调用epoll_wait使得InputReaderThread等待唤醒；<br>获取Events的过于复杂，直接跳过，来看事件的传递；当获取到Event之后，调用mQueuedListener的flush来传递消息；</p>
<h1 id="二、事件分发"><a href="#二、事件分发" class="headerlink" title="二、事件分发"></a>二、事件分发</h1><p>前面提到使用EventHub的getEvents来获取Events之后，通过mQueuedListener的flush开始消息的分发；</p>
<h2 id="1、QueueInputListener-flush"><a href="#1、QueueInputListener-flush" class="headerlink" title="1、QueueInputListener#flush:"></a>1、QueueInputListener#flush:</h2><h3 id="1）先看QueueInputListener的定义："><a href="#1）先看QueueInputListener的定义：" class="headerlink" title="1）先看QueueInputListener的定义："></a>1）先看QueueInputListener的定义：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputListener.h **/</span></span><br><span class="line"><span class="keyword">class</span> QueuedInputListener : <span class="keyword">public</span> InputListenerInterface &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~QueuedInputListener();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    QueuedInputListener(<span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; innerListener);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyConfigurationChanged</span><span class="params">(<span class="keyword">const</span> NotifyConfigurationChangedArgs* args)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyKey</span><span class="params">(<span class="keyword">const</span> NotifyKeyArgs* args)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyMotion</span><span class="params">(<span class="keyword">const</span> NotifyMotionArgs* args)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifySwitch</span><span class="params">(<span class="keyword">const</span> NotifySwitchArgs* args)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyDeviceReset</span><span class="params">(<span class="keyword">const</span> NotifyDeviceResetArgs* args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    sp&lt;InputListenerInterface&gt; mInnerListener;<span class="comment">// mInnerListner即是InputDispatcher</span></span><br><span class="line">    Vector&lt;NotifyArgs*&gt; mArgsQueue; <span class="comment">// 后面flush函数中将会用到</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在InputReader的构造函数中，传递进来的mInnerListener即为InputDispatcher；</p>
<h3 id="2）flush函数："><a href="#2）flush函数：" class="headerlink" title="2）flush函数："></a>2）flush函数：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputListener.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> QueuedInputListener::flush() &#123;</span><br><span class="line">    <span class="keyword">size_t</span> count = mArgsQueue.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        NotifyArgs* args = mArgsQueue[i];</span><br><span class="line">        <span class="comment">// 调用NotifyArgs。notify函数</span></span><br><span class="line">        args-&gt;notify(mInnerListener);</span><br><span class="line">        <span class="keyword">delete</span> args;</span><br><span class="line">    &#125;</span><br><span class="line">    mArgsQueue.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里仅是一个封装函数，最终调用InputListenerInterface的notifyKey函数</span></span><br><span class="line"><span class="keyword">void</span> NotifyKeyArgs::notify(<span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) <span class="keyword">const</span> &#123;</span><br><span class="line">    listener-&gt;notifyKey(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>前面最终调用InputListenerInterface（即InputDispatcher）的notifyKey回调函数；
总结前面的流程即InputReaderThread通过EventHub不断读取获取event信息，获得事件后，调用InputDispather的notifyKey函数来通知InputDispathcer进行处理。注意这里调用InputDispatcher的notifyKey函数依然是在InputReaderThread线程中进行的，此时InputDispathcerThread仍然是epoll_wait阻塞状态中；
</code></pre><h2 id="2、InputDispatcher-notifyKey："><a href="#2、InputDispatcher-notifyKey：" class="headerlink" title="2、InputDispatcher::notifyKey："></a>2、InputDispatcher::notifyKey：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::notifyKey(<span class="keyword">const</span> NotifyKeyArgs* args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!validateKeyEvent(args-&gt;action)) &#123; <span class="comment">// 判断event是否合法</span></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 初始化KeyEvent</span></span><br><span class="line">    KeyEvent event;</span><br><span class="line">    event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action,</span><br><span class="line">                     flags, keyCode, args-&gt;scanCode, metaState, <span class="number">0</span>,</span><br><span class="line">                     args-&gt;downTime, args-&gt;eventTime);</span><br><span class="line">    <span class="keyword">bool</span> needWake;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        mLock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldSendKeyToInputFilterLocked(args)) &#123;</span><br><span class="line">            mLock.unlock();</span><br><span class="line"></span><br><span class="line">            policyFlags |= POLICY_FLAG_FILTERED;</span><br><span class="line">            <span class="keyword">if</span> (!mPolicy-&gt;filterInputEvent(&amp;event, policyFlags)) &#123;</span><br><span class="line">                return; <span class="comment">// event was consumed by the filter</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mLock.lock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> repeatCount = <span class="number">0</span>;</span><br><span class="line">        KeyEntry* newEntry = new KeyEntry(args-&gt;eventTime,</span><br><span class="line">                                          args-&gt;deviceId, args-&gt;source, policyFlags,</span><br><span class="line">                                          args-&gt;action, flags, keyCode, args-&gt;scanCode,</span><br><span class="line">                                          metaState, repeatCount, args-&gt;downTime);</span><br><span class="line"></span><br><span class="line">        needWake = enqueueInboundEventLocked(newEntry);</span><br><span class="line">        mLock.unlock();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒InputDispatcherThread线程</span></span><br><span class="line">    <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">        mLooper-&gt;wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 该部分对传递过来的按键事件进行检查、验证，之后处理特殊按键，将原始按键信息封装成KeyEntry，再调用enqueueInboundEventLocked函数把KeyEntry添加到InboundQueue队列中，最后调用Looper对象的wake往管道中写入字符唤醒InputDispatcherThread线程（类似于Handler机制中的唤醒）；<br>先来看enqueueInboundEventLocked添加事件到InboundQueue队列中：</p>
<h3 id="1）InputDispatcher-enqueueInboundEventLocked："><a href="#1）InputDispatcher-enqueueInboundEventLocked：" class="headerlink" title="1）InputDispatcher::enqueueInboundEventLocked："></a>1）InputDispatcher::enqueueInboundEventLocked：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">bool</span> InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) &#123;</span><br><span class="line">    <span class="comment">// @value Queue&lt;EventEntry&gt; mInboundQueue;</span></span><br><span class="line">    <span class="keyword">bool</span> needWake = mInboundQueue.isEmpty();</span><br><span class="line">    <span class="comment">// 将entry入队列</span></span><br><span class="line">    mInboundQueue.enqueueAtTail(entry);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> (entry-&gt;type) &#123; <span class="comment">// 如前面所述，InputEvent分为KeyEvent和MotionEvent进行分别处理</span></span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_KEY: ......</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_MOTION: .....</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return needWake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将entry添加到InboundQueue队列尾部；然后判断是否需要唤醒，即needWake是否为true；当mInboundQueue不为空，则明显InputDispathcerThread仍处于运行状态来分发事件，因而不用进行唤醒；而当mInboundQueue为空时，测试InputDispatcherThread进行休眠状态，使用wake对其来唤醒；<br>    InputDispatcherThread之前调用Looper的poolOnce函数阻塞休眠，这里调用wake将其唤醒；因为InputDispatcherThread的threadLoop返回值为true，表示该Thread是循环执行的，故继续调用其dispatchOnce函数；</p>
<h2 id="3、InputDispatcher-dispatchOnce"><a href="#3、InputDispatcher-dispatchOnce" class="headerlink" title="3、InputDispatcher::dispatchOnce:"></a>3、InputDispatcher::dispatchOnce:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mDispatcherIsAliveCondition.broadcast();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 在没有等待的commands事运行一个dispatch loop，这个loop之后可能enqueue commands</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果有等待的commands的话，就运行所有的commands</span></span><br><span class="line">        <span class="comment">// If any commands were run then force the next poll to wake up immediately.</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来到dispatchOnceInnerLocked：</p>
<h2 id="4、InputDispathcer-dispatchOnceInnerLocked"><a href="#4、InputDispathcer-dispatchOnceInnerLocked" class="headerlink" title="4、InputDispathcer#dispatchOnceInnerLocked:"></a>4、InputDispathcer#dispatchOnceInnerLocked:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnceInnerLocked(<span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! mPendingEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInboundQueue.isEmpty()) &#123; <span class="comment">// 当前mInboundQueue已经存在元素</span></span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inbound queue has at least one entry.</span></span><br><span class="line">            mPendingEvent = mInboundQueue.dequeueAtHead();</span><br><span class="line">            traceInboundQueueLengthLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now we have an event to dispatch.</span></span><br><span class="line">    <span class="comment">// All events are eventually dequeued and processed this way, even if we intend to drop them.</span></span><br><span class="line">    ALOG_ASSERT(mPendingEvent != <span class="literal">NULL</span>);</span><br><span class="line">    .......</span><br><span class="line">    <span class="comment">// 根据mPendingEvent的Type的不同分别进行处理</span></span><br><span class="line">    <span class="keyword">switch</span> (mPendingEvent-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_CONFIGURATION_CHANGED: &#123;</span><br><span class="line">            ......</span><br><span class="line">            done = dispatchConfigurationChangedLocked(currentTime, typedEntry);</span><br><span class="line">            dropReason = DROP_REASON_NOT_DROPPED; <span class="comment">// configuration changes are never dropped</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// KeyEvent采用dispatchKeyLocked进行处理</span></span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">            KeyEntry* typedEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(mPendingEvent);</span><br><span class="line">            ......</span><br><span class="line">            done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// MotionEvent采用dispatchMotionLocked进行处理</span></span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">            ......</span><br><span class="line">            done = dispatchMotionLocked(currentTime, typedEntry,</span><br><span class="line">                                        &amp;dropReason, nextWakeupTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOG_ASSERT(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dropReason != DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">            dropInboundEventLocked(mPendingEvent, dropReason);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        releasePendingEventLocked();</span><br><span class="line">        *nextWakeupTime = LONG_LONG_MIN;  <span class="comment">// force next poll to wake up immediately</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到是事件处理机制中常用的处理模式，类似于Handler机制，这里先dequeueAtHead使得InBoundQueue事件队列中的事件出队列（FIFO）；然后根据事件的类似进行不同的处理；如TYPE_KEY类型事件采用dispatchKeyLocked；TYPE_MOTION类型事件采用dispatchMotionLocked处理<br> 下面以KeyEvent为例进行分析,下面忽略对event的具体处理细节，具体来看事件是如何传递的；</p>
<h2 id="5、InputDispatcher-dispatchKeyLocked"><a href="#5、InputDispatcher-dispatchKeyLocked" class="headerlink" title="5、InputDispatcher::dispatchKeyLocked:"></a>5、InputDispatcher::dispatchKeyLocked:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">bool</span> InputDispatcher::dispatchKeyLocked(<span class="keyword">nsecs_t</span> currentTime, KeyEntry* entry,</span><br><span class="line">        DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/** 确定事件的接收方（Target） **/</span></span><br><span class="line">    Vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">            entry, inputTargets, nextWakeupTime);</span><br><span class="line"> </span><br><span class="line">    setInjectionResultLocked(entry, injectionResult);</span><br><span class="line">    addMonitoringTargetsLocked(inputTargets);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** 将消息dispatch给Target **/</span></span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面对event的处理细节忽略，重点来看系统是如何查找event对应的接收方（Target）的，这里的InputTarget指定一个输入事件如何被分发到一个特定窗口。该结构体包含了很多特征变量：x,y坐标，输入事件通道InputChannel等；<br>这里通过findFocusedWindowTargetsLocked来确定InputTarget的，然后调用dispatchEventLocked来将Event分发给具体的Target；<br>接下来分析函数findFocusedWindowTargetsLocked；</p>
<h2 id="6、InputDispatcher-findFocusedWindowTargetsLocked"><a href="#6、InputDispatcher-findFocusedWindowTargetsLocked" class="headerlink" title="6、InputDispatcher::findFocusedWindowTargetsLocked:"></a>6、InputDispatcher::findFocusedWindowTargetsLocked:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">int32_t</span> InputDispatcher::findFocusedWindowTargetsLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> EventEntry* entry, Vector&lt;InputTarget&gt;&amp; inputTargets, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult;</span><br><span class="line">    String8 reason;</span><br><span class="line">    <span class="comment">// mFocusedWindowHandle表示当前焦点窗口的句柄</span></span><br><span class="line">    <span class="comment">// @value sp&lt;InputWindowHandle&gt; mFocusedWindowHandle;</span></span><br><span class="line">    <span class="comment">/** 当获得焦点的窗口为null时，会丢弃这一事件 **/</span></span><br><span class="line">    <span class="keyword">if</span> (mFocusedWindowHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFocusedApplicationHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有焦点窗口，但焦点窗口所在的应用程序进程存在，说明该应程序还在启动过程中，故等待nextWakeupTime后再重试</span></span><br><span class="line">            injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                    mFocusedApplicationHandle, NULL, nextWakeupTime,</span><br><span class="line">                    <span class="string">"Waiting because no window has focus but there is a "</span></span><br><span class="line">                    <span class="string">"focused application that may eventually add a window "</span></span><br><span class="line">                    <span class="string">"when it finishes starting up."</span>);</span><br><span class="line">            <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        injectionResult = INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 如果执行到这里说明当前有焦点窗口 **/</span></span><br><span class="line">    <span class="comment">// 先判断权限</span></span><br><span class="line">    <span class="keyword">if</span> (! checkInjectionPermission(mFocusedWindowHandle, entry-&gt;injectionState)) &#123;</span><br><span class="line">        injectionResult = INPUT_EVENT_INJECTION_PERMISSION_DENIED;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前焦点窗口正在处理上一个事件，采取和最上面一样的作法，等待一段时间后重试</span></span><br><span class="line">    reason = checkWindowReadyForMoreInputLocked(currentTime,</span><br><span class="line">            mFocusedWindowHandle, entry, <span class="string">"focused"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!reason.isEmpty()) &#123;</span><br><span class="line">        injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                mFocusedApplicationHandle, mFocusedWindowHandle, nextWakeupTime, reason.string());</span><br><span class="line">        <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功找到匹配的窗口，通过addWindowTargetLocked添加到inputTargets变量中</span></span><br><span class="line">    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;</span><br><span class="line">    addWindowTargetLocked(mFocusedWindowHandle,</span><br><span class="line">            InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS, BitSet32(<span class="number">0</span>),</span><br><span class="line">            inputTargets);</span><br><span class="line"></span><br><span class="line">Failed:</span><br><span class="line">Unresponsive:</span><br><span class="line">    <span class="keyword">nsecs_t</span> timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);</span><br><span class="line">    updateDispatchStatisticsLocked(currentTime, entry,</span><br><span class="line">            injectionResult, timeSpentWaitingForApplication);</span><br><span class="line">    return injectionResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面查找焦点窗口的逻辑很清晰， 当mFocusedWindowHandle为null时，如果mFocusedApplicationHandle不为null，表示当前没有焦点窗口，但焦点窗口所在的应用程序进程存在，说明该应程序还在启动过程中，故等待nextWakeupTime后再重试；如果mFocusedApplicationHandle为null，则丢弃该事件，因为没有能够接收该事件的窗口；<br>    如果mFocusedWindowHandle不为null，先判断当前窗口是否locked，如果是表示正在处理其他输入事件，这时采用和上面相同的策略，等待一段时间后，然后重试。<br>    当找到匹配的目标窗口之后，赋值给InputTarget；先来看InputTarget的定义：</p>
<h2 id="7、InputTarget"><a href="#7、InputTarget" class="headerlink" title="7、InputTarget:"></a>7、InputTarget:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.h **/</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * An input target specifies how an input event is to be dispatched to a particular window</span><br><span class="line"> * including the window's input channel, control flags, a timeout, and an X / Y offset to</span><br><span class="line"> * be added to input event coordinates to compensate for the absolute position of the</span><br><span class="line"> * window area.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> InputTarget &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; <span class="comment">// 该枚举类列举个关于目标窗口的各种属性值描述</span></span><br><span class="line">        <span class="comment">/* This flag indicates that the event is being delivered to a foreground application. */</span></span><br><span class="line">        FLAG_FOREGROUND = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">// 说明目标窗口是前台应用</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** InputDispatcher与WMS建立关联通信的地方 */</span></span><br><span class="line">    sp&lt;InputChannel&gt; inputChannel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里引出了重要的类InputChannel，InputDispatcher与WMS之间的通信，正是通过InputChannel来实现的。</p>
<p>继续前面的dispatchKeyLocked函数，接下来会调用dispatchEventLocked来传递消息；</p>
<h2 id="8、InputDispatcher-dispatchEventLocked"><a href="#8、InputDispatcher-dispatchEventLocked" class="headerlink" title="8、InputDispatcher#dispatchEventLocked"></a>8、InputDispatcher#dispatchEventLocked</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchEventLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        EventEntry* eventEntry, <span class="keyword">const</span> Vector&lt;InputTarget&gt;&amp; inputTargets) &#123;</span><br><span class="line">    ALOG_ASSERT(eventEntry-&gt;dispatchInProgress); <span class="comment">// should already have been set to true</span></span><br><span class="line"></span><br><span class="line">    pokeUserActivityLocked(eventEntry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputTargets.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> InputTarget&amp; inputTarget = inputTargets.itemAt(i);</span><br><span class="line">        <span class="comment">// 根据inputChannel（其中的fd）来获取对应的Connection</span></span><br><span class="line">        <span class="keyword">ssize_t</span> connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);</span><br><span class="line">        <span class="keyword">if</span> (connectionIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);</span><br><span class="line">            <span class="comment">// 继续向下调用</span></span><br><span class="line">            prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里根据InputChannel的fd值来获取对应的Connection对象，InputChannel以及Connection的相关知识可以西安看第三章；Connection是用来管理InputChannel的变量；然后接着调用 prepareDispatchCycleLocked；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::prepareDispatchCycleLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Split a motion event if needed.</span></span><br><span class="line">    <span class="keyword">if</span> (inputTarget-&gt;flags &amp; InputTarget::FLAG_SPLIT) &#123;</span><br><span class="line">        ALOG_ASSERT(eventEntry-&gt;type == EventEntry::TYPE_MOTION);</span><br><span class="line"></span><br><span class="line">        MotionEntry* originalMotionEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);</span><br><span class="line">        <span class="keyword">if</span> (inputTarget-&gt;pointerIds.count() != originalMotionEntry-&gt;pointerCount) &#123;</span><br><span class="line">            MotionEntry* splitMotionEntry = splitMotionEvent(</span><br><span class="line">                    originalMotionEntry, inputTarget-&gt;pointerIds);</span><br><span class="line">            <span class="keyword">if</span> (!splitMotionEntry) &#123;</span><br><span class="line">                return; <span class="comment">// split event was dropped</span></span><br><span class="line">            &#125;</span><br><span class="line">            enqueueDispatchEntriesLocked(currentTime, connection,</span><br><span class="line">                    splitMotionEntry, inputTarget);</span><br><span class="line">            splitMotionEntry-&gt;release();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not splitting.  Enqueue dispatch entries for the event as is.</span></span><br><span class="line">    enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后接着调用 enqueueDispatchEntriesLocked函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::enqueueDispatchEntriesLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget) &#123;</span><br><span class="line">    <span class="keyword">bool</span> wasEmpty = connection-&gt;outboundQueue.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue dispatch entries for the requested modes.</span></span><br><span class="line">    <span class="comment">// 将dispatch entries入队列</span></span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_OUTSIDE);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_IS);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the outbound queue was previously empty, start the dispatch cycle going.</span></span><br><span class="line">    <span class="comment">// 开始分发事件</span></span><br><span class="line">    <span class="keyword">if</span> (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        startDispatchCycleLocked(currentTime, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enqueueDispatchEntryLocked创建DispatchEntry（按键事件对象），并且把该对象作为一个发送数据包加入到outboundQueue队列中；<br>startDispatchCycleLocked取出outboundQueue队列头元素，赋给dispatchEntry，再取出事件对象KeyEntry，根据事件类型确定case语句分支，如果是按键事件，就调用connection的InputPublisher的publishKeyEvent函数发送到inputchannel中，如果publishKeyEvent返回0，表示按键事件发送成功；<br><strong>InputDispathcer#enqueueDispatchEntryLocked：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::enqueueDispatchEntryLocked(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget,</span><br><span class="line">        <span class="keyword">int32_t</span> dispatchMode) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> inputTargetFlags = inputTarget-&gt;flags;</span><br><span class="line">    <span class="comment">// 如果inputTargetFlags和dispatchMode不匹配</span></span><br><span class="line">    <span class="keyword">if</span> (!(inputTargetFlags &amp; dispatchMode)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    inputTargetFlags = (inputTargetFlags &amp; ~InputTarget::FLAG_DISPATCH_MASK) | dispatchMode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建DispatchEntry</span></span><br><span class="line">    DispatchEntry* dispatchEntry = new DispatchEntry(eventEntry, <span class="comment">// increments ref</span></span><br><span class="line">            inputTargetFlags, inputTarget-&gt;xOffset, inputTarget-&gt;yOffset,</span><br><span class="line">            inputTarget-&gt;scaleFactor);</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue the dispatch entry.</span></span><br><span class="line">    <span class="comment">// 添加到outboundQueue中</span></span><br><span class="line">    connection-&gt;outboundQueue.enqueueAtTail(dispatchEntry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9、InputDispathcer-startDispatchCycleLocked"><a href="#9、InputDispathcer-startDispatchCycleLocked" class="headerlink" title="9、InputDispathcer#startDispatchCycleLocked:"></a>9、InputDispathcer#startDispatchCycleLocked:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::startDispatchCycleLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (connection-&gt;status == Connection::STATUS_NORMAL</span><br><span class="line">            &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 取出outboundQueue的首部元素</span></span><br><span class="line">        DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head;</span><br><span class="line">        dispatchEntry-&gt;deliveryTime = currentTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Publish the event.</span></span><br><span class="line">        <span class="keyword">status_t</span> status;</span><br><span class="line">        EventEntry* eventEntry = dispatchEntry-&gt;eventEntry;</span><br><span class="line">        <span class="comment">// 根据EventEntry的Type类型进行处理</span></span><br><span class="line">        <span class="keyword">switch</span> (eventEntry-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">            KeyEntry* keyEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(eventEntry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Publish the key event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    keyEntry-&gt;deviceId, keyEntry-&gt;source,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags,</span><br><span class="line">                    keyEntry-&gt;keyCode, keyEntry-&gt;scanCode,</span><br><span class="line">                    keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime,</span><br><span class="line">                    keyEntry-&gt;eventTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">            MotionEntry* motionEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);</span><br><span class="line">            ....</span><br><span class="line">            <span class="comment">// Publish the motion event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishMotionEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    motionEntry-&gt;deviceId, motionEntry-&gt;source,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags,</span><br><span class="line">                    motionEntry-&gt;edgeFlags, motionEntry-&gt;metaState, motionEntry-&gt;buttonState,</span><br><span class="line">                    xOffset, yOffset,</span><br><span class="line">                    motionEntry-&gt;xPrecision, motionEntry-&gt;yPrecision,</span><br><span class="line">                    motionEntry-&gt;downTime, motionEntry-&gt;eventTime,</span><br><span class="line">                    motionEntry-&gt;pointerCount, motionEntry-&gt;pointerProperties,</span><br><span class="line">                    usingCoords);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Re-enqueue the event on the wait queue.</span></span><br><span class="line">        <span class="comment">// 事件处理完，将该Entry移除队列</span></span><br><span class="line">        connection-&gt;outboundQueue.dequeue(dispatchEntry);</span><br><span class="line">        traceOutboundQueueLengthLocked(connection);</span><br><span class="line">        connection-&gt;waitQueue.enqueueAtTail(dispatchEntry);</span><br><span class="line">        traceWaitQueueLengthLocked(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>典型的事件处理函数，从outBoundQueue中取出EventEntry，然后根据其Type，是TypeEvent，还是MotionEvent分别进行处理；可以看到KeyEvent使用publishKeyEvent来处理；而MotionEvent采用publishMotionEvent来处理；</p>
<h2 id="10、InputPublisher-publishMotionEvent："><a href="#10、InputPublisher-publishMotionEvent：" class="headerlink" title="10、InputPublisher#publishMotionEvent："></a>10、InputPublisher#publishMotionEvent：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\libs\input\InputTransport.cpp **/</span> </span><br><span class="line"><span class="keyword">status_t</span> InputPublisher::publishMotionEvent(</span><br><span class="line">        <span class="keyword">uint32_t</span> seq,</span><br><span class="line">        <span class="keyword">int32_t</span> deviceId,</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">const</span> PointerProperties* pointerProperties,</span><br><span class="line">        <span class="keyword">const</span> PointerCoords* pointerCoords) &#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="comment">// 一系列的赋值操作</span></span><br><span class="line">    InputMessage msg;</span><br><span class="line">    msg.header.type = InputMessage::TYPE_MOTION;</span><br><span class="line">    msg.body.motion.seq = seq;</span><br><span class="line">    msg.body.motion.deviceId = deviceId;</span><br><span class="line">    ......</span><br><span class="line">    return mChannel-&gt;sendMessage(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InputPublisher的publishMotionEvent中创建一个InputMessage，然后根据传递进来的EventEntry中的值进行赋值，然后调用InputChannel的sendMessage进行事件发送；这里的InputChannel即是下面将会提到的在ViewRootImpl中创建的Server端的InputChannel；</p>
<h2 id="11、InputChannel-sendMessage"><a href="#11、InputChannel-sendMessage" class="headerlink" title="11、InputChannel#sendMessage:"></a>11、InputChannel#sendMessage:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\libs\input\InputTransport.cpp **/</span></span><br><span class="line"><span class="keyword">status_t</span> InputChannel::sendMessage(<span class="keyword">const</span> InputMessage* msg) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> msgLength = msg-&gt;size();</span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// mFd对应socket fd;则例相当于往服务器socket中发送消息</span></span><br><span class="line">        nWrite = ::send(mFd, msg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送失败</span></span><br><span class="line">    <span class="keyword">if</span> (nWrite &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       .....</span><br><span class="line">        return -error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送成功</span></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InputChannel的sendMessage操作即是使用服务器socket send一个Message；下面将会提到socket服务端没有往inputchannel中写入数据时，客户端暂时处于阻塞状态，一旦服务端有了数据后，客户端也被唤醒了。</p>
<p>这里先来了解下这个重要类InputChannel是如何被初始化的；</p>
<h1 id="三、重要的类InputChannel"><a href="#三、重要的类InputChannel" class="headerlink" title="三、重要的类InputChannel:"></a>三、重要的类InputChannel:</h1><h2 id="1、InputChannel定义"><a href="#1、InputChannel定义" class="headerlink" title="1、InputChannel定义:"></a>1、InputChannel定义:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\include\input\InputTransport.h **/</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * An input channel consists of a local unix domain socket used to send and receive</span><br><span class="line"> * input messages across processes.  Each channel has a descriptive name for debugging purposes.</span><br><span class="line"> *</span><br><span class="line"> * Each endpoint has its own InputChannel object that specifies its file descriptor.</span><br><span class="line"> *</span><br><span class="line"> * The input channel is closed when all references to it are released.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// 上面提到InputChannel是使用unix domain socket（UDS）进行通信的，而非Binder</span></span><br><span class="line"><span class="keyword">class</span> InputChannel : <span class="keyword">public</span> RefBase &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span>~InputChannel();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    InputChannel(<span class="keyword">const</span> String8&amp; name, <span class="keyword">int</span> fd); <span class="comment">// fd类似设备描述符</span></span><br><span class="line">    <span class="comment">// 用于打开一个InputChannel对（Pair）,用以实现双向通信</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> status_t <span class="title">openInputChannelPair</span><span class="params">(<span class="keyword">const</span> String8&amp; name,</span><br><span class="line">            sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> String8 <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; returnmName; &#125;</span><br><span class="line">    <span class="function">inlineint <span class="title">getFd</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; returnmFd; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 发送接收信息</span></span><br><span class="line">    <span class="keyword">status_t</span> sendMessage(<span class="keyword">const</span> InputMessage* msg);</span><br><span class="line">    <span class="keyword">status_t</span> receiveMessage(InputMessage* msg);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Returns a new object that has a duplicate of this channel's fd. */</span></span><br><span class="line">    sp&lt;InputChannel&gt; dup() <span class="keyword">const</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    String8 mName;</span><br><span class="line">    <span class="keyword">int</span> mFd;  <span class="comment">// 重点要弄清该变量代表的含义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>InputChannel是可以双向通信的，它通过openInputChannelPair来打开一个InputChannel对，然后sendMessage或者receiveMessage来发送接收消息；<br>InputChannel是通过UDS来实现通信的，Android系统中最为常用的进程间通信时Binder通信，其次便是UDS进行单机内的进程间通信，也称IPC Socket。<br>来看InputChannel的初始化：<br>了解Window的创建过程后，之后有一个重要的对象ViewRootImpl，这里从其setView开始探索：</p>
<h2 id="2、ViewRootImpl-setView"><a href="#2、ViewRootImpl-setView" class="headerlink" title="2、ViewRootImpl#setView:"></a>2、ViewRootImpl#setView:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\core\java\android\view\ViewRootImpl.java **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        .....</span><br><span class="line">        <span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">                &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">            mInputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在Session addToDisplay时，传入mInputChannel</span></span><br><span class="line">            res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                    getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                    mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mInputChannel);</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实Java层的InputChannel只是对native层的封装，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\core\java\android\view\InputChannel.java **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InputChannel</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mPtr; <span class="comment">// used by native code</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> InputChannel[] nativeOpenInputChannelPair(String name);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeDispose</span><span class="params">(<span class="keyword">boolean</span> finalized)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeTransferTo</span><span class="params">(InputChannel other)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeReadFromParcel</span><span class="params">(Parcel parcel)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeWriteToParcel</span><span class="params">(Parcel parcel)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeDup</span><span class="params">(InputChannel target)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> String <span class="title">nativeGetName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WindowSession的具体细节参见<a href="http://blog.csdn.net/woliuyunyicai/article/details/48419135" target="_blank" rel="external">《View机制深入学习（一）》</a>，addToDisplay会继续调用WindowManagerService的addWindow函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\core\java\android\view\WindowManagerService.java **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span><br><span class="line">                     WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span><br><span class="line">                     Rect outContentInsets, Rect outStableInsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">if</span> (outInputChannel != <span class="keyword">null</span> &amp;&amp; (attrs.inputFeatures</span><br><span class="line">            &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">        String name = win.makeInputChannelName();</span><br><span class="line">        <span class="comment">// 打开InputChannel对</span></span><br><span class="line">        InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);</span><br><span class="line">        <span class="comment">// WindowState设置inputChannel变量</span></span><br><span class="line">        win.setInputChannel(inputChannels[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 设置outputChannel</span></span><br><span class="line">        inputChannels[<span class="number">1</span>].transferTo(outInputChannel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// InputManager注册InputChannel</span></span><br><span class="line">        mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在这里通过openInputChannelPair打开InputChannel，前面提到openInputChannelPair就是调用native端InputChannel的openInputChannelPair函数；<br>从这里面还可以看到，创建的InputChannel对，一个用来设置给WindowState，即供Window使用；一个设置给InputManagerService，其实是设置给native端的InputDispatcher，用以分发相应的事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\core\java\android\view\InputChannel.java **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InputChannel[] openInputChannelPair(String name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"name must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nativeOpenInputChannelPair(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> InputChannel[] nativeOpenInputChannelPair(String name);</span><br></pre></td></tr></table></figure>
<p>下面来看native端的InputChannel；</p>
<h2 id="3、InputChannel-openInputChannelPair"><a href="#3、InputChannel-openInputChannelPair" class="headerlink" title="3、InputChannel::openInputChannelPair:"></a>3、InputChannel::openInputChannelPair:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\libs\input\InputTransport.cpp **/</span></span><br><span class="line"><span class="keyword">status_t</span> InputChannel::openInputChannelPair(<span class="keyword">const</span> String8&amp; name,</span><br><span class="line">                                            sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel) &#123;</span><br><span class="line">    <span class="comment">// 建立UDS</span></span><br><span class="line">    <span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 创建一个饱含2个元素的socket数组，socketpair创建一对socket对象，SOCK_SEQPACKET表示创建连续可靠的数据包连接，如果创建成功，返回0，如果返回-1，出错。</span></span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets)) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> result = -errno;</span><br><span class="line">        outServerChannel.clear();</span><br><span class="line">        outClientChannel.clear();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置缓冲区大小</span></span><br><span class="line">    <span class="keyword">int</span> bufferSize = SOCKET_BUFFER_SIZE;</span><br><span class="line">    setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Server与Client端实例</span></span><br><span class="line">    String8 serverChannelName = name;</span><br><span class="line">    serverChannelName.append(<span class="string">" (server)"</span>);</span><br><span class="line">    outServerChannel = new InputChannel(serverChannelName, sockets[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    String8 clientChannelName = name;</span><br><span class="line">    clientChannelName.append(<span class="string">" (client)"</span>);</span><br><span class="line">    outClientChannel = new InputChannel(clientChannelName, sockets[<span class="number">1</span>]);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面创建了一对InputChannel：分别为服务端管道对象outServerChannel和客户端管道对象outClientChannel;inputChannels[0]作为服务端管道提供给InputDispatcher使用，用来发送按键事件；inputChannels[1]作为客户端管道提供给应用程序主线程使用，用来接收、消费按键事件。</p>
<p>创建好InputChannel之后，继续来看addWindow中的InputManagerService注册InputChannel的过程；前面提到，创建的inputChannels[0]即outServerChannel是供IMS中的InputDispatcher使用的，因此这里需要进行注册；</p>
<h2 id="4、InputManagerService-registerInputChannel："><a href="#4、InputManagerService-registerInputChannel：" class="headerlink" title="4、InputManagerService#registerInputChannel："></a>4、InputManagerService#registerInputChannel：</h2><p>直接来到本地端的nativeRegisterInputChannel，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span>  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeRegisterInputChannel</span><span class="params">(JNIEnv* env, jclass clazz,</span><br><span class="line">        jlong ptr, jobject inputChannelObj, jobject inputWindowHandleObj, jboolean monitor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将Java端存储的ptr指针地址转化为NativeInputManager对象</span></span><br><span class="line">    NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据传输进来的inputChannelObj获取InputChannel对象</span></span><br><span class="line">    sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env, inputChannelObj);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 根据传递进来的inputWindowHandleObj来获取InputWindowHandle对象</span></span><br><span class="line">    sp&lt;InputWindowHandle&gt; inputWindowHandle = android_server_InputWindowHandle_getHandle(env, inputWindowHandleObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用NativeInputManager的registerInputChannel进行注册</span></span><br><span class="line">    <span class="keyword">status_t</span> status = im-&gt;registerInputChannel(env, inputChannel, inputWindowHandle, monitor);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的逻辑很清晰，通过java层传递进来的inputChannelObj,inputWindowHandleObj来获取相对应的InputChannel以及InputWindowHandle对象。<br>然后将获得的实例传入到NativeInputManager中的registerInputChannel进行注册；</p>
<h2 id="5、NativeInputManager-registerInputChannel"><a href="#5、NativeInputManager-registerInputChannel" class="headerlink" title="5、NativeInputManager#registerInputChannel:"></a>5、NativeInputManager#registerInputChannel:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span>  </span><br><span class="line"><span class="keyword">status_t</span> NativeInputManager::registerInputChannel(JNIEnv* env,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="keyword">bool</span> monitor) &#123;</span><br><span class="line">    return mInputManager-&gt;getDispatcher()-&gt;registerInputChannel(</span><br><span class="line">            inputChannel, inputWindowHandle, monitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里最终是调用InputManager中的InputDispatcher的registerInputChannel进行注册，这也验证了前面所叙述的服务器端的InputChannel是供以InputDispatcher来使用的。</p>
<h2 id="6、InputDispatcher-registerInputChannel"><a href="#6、InputDispatcher-registerInputChannel" class="headerlink" title="6、InputDispatcher#registerInputChannel:"></a>6、InputDispatcher#registerInputChannel:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span>  </span><br><span class="line"><span class="keyword">status_t</span> InputDispatcher::registerInputChannel(<span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="keyword">bool</span> monitor) &#123;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getConnectionIndexLocked(inputChannel) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            return BAD_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Connection来管理对应的InputChannel以及WindowHandler</span></span><br><span class="line">        sp&lt;Connection&gt; connection = new Connection(inputChannel, inputWindowHandle, monitor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取InputChannel对应的socket Fd;</span></span><br><span class="line">        <span class="keyword">int</span> fd = inputChannel-&gt;getFd();</span><br><span class="line">        <span class="comment">// 类似于key,value形式，将connection与inputChannel的fd建立起关联</span></span><br><span class="line">        mConnectionsByFd.add(fd, connection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (monitor) &#123;</span><br><span class="line">            mMonitoringChannels.push(inputChannel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将InputChannel的fd添加到Looper中epoll的兴趣事件列表中</span></span><br><span class="line">        mLooper-&gt;addFd(fd, <span class="number">0</span>, ALOOPER_EVENT_INPUT, handleReceiveCallback, <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wake the looper because some connections have changed.</span></span><br><span class="line">    <span class="comment">// 因为connection已经发生了变化，则唤醒Looper</span></span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过InputChannel以及InputWindowHandle来创建相对应的Connection；Connetction是用来管理InputChannel的，Connection存储在 mConnectionsByFd的，它通过key-value形式进行存储，Connection的关键字使用InputChannel创建时的socket的fd来标识。</p>
<p>然后将InputChannel的fd添加到Looper的epoll兴趣列表中，注意这里的Looper对应的是InputDispatcherThread中的Looper；当server端的InputChannel有事件传递时，这时Looper会被唤醒，执行handleReceiveCallback回调；</p>
<p>服务器端InputChannel使用InputManagerService的registerInputChannel来实现，而客户端的InputChannel则通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputChannels[1].transferTo(outInputChannel);</span><br></pre></td></tr></table></figure>
<p>来实现；</p>
<h2 id="7、InputChannel-transferTo："><a href="#7、InputChannel-transferTo：" class="headerlink" title="7、InputChannel#transferTo："></a>7、InputChannel#transferTo：</h2><p>直接来到对应的native层的transferTo:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @path: \frameworks\base\core\jni\android_view_InputChannel.cpp */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_view_InputChannel_nativeTransferTo</span><span class="params">(JNIEnv* env, jobject obj,</span><br><span class="line">        jobject otherObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (android_view_InputChannel_getNativeInputChannel(env, otherObj) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>,</span><br><span class="line">                <span class="string">"Other object already has a native input channel."</span>);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建InputChannel</span></span><br><span class="line">    NativeInputChannel* nativeInputChannel =</span><br><span class="line">            android_view_InputChannel_getNativeInputChannel(env, obj);</span><br><span class="line">    android_view_InputChannel_setNativeInputChannel(env, otherObj, nativeInputChannel);</span><br><span class="line">    android_view_InputChannel_setNativeInputChannel(env, obj, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意函数中出现的几个变量对应的含义：<br>obj：本地方法所在对象的引用，对应inputChannels[1]客户端对象的引用<br>otherObj：在ViewRootImpl中创建的InputChannel对象<br>具体不再细述，就是将本地端的InputChannel[1]赋值给Java端的outInputChannel对象；</p>
<p>在前面第二章末已经提出，使用InputPublisher来将Message传递给InputChannel，这里是发送事件；而相对应的，会有一个是用来接收事件的，其类名为InputConsumer；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Retrofit源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/06/Retrofit源码解析/" class="article-date">
      <time datetime="2016-05-06T13:23:44.358Z" itemprop="datePublished">2016-05-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/06/Retrofit源码解析/">Retrofit源码解析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="https://github.com/square" target="_blank" rel="external">square</a>公司开源了一系列的优秀库，比如<a href="https://github.com/square/retrofit" target="_blank" rel="external">Retrofit</a>,<a href="https://github.com/square/okhttp" target="_blank" rel="external">OkHttp</a>,<a href="https://github.com/square/picasso" target="_blank" rel="external">Picasso</a>等，<br>前面简单分析了<a href="http://blog.csdn.net/woliuyunyicai/article/details/51417839" target="_blank" rel="external">Picasso的源码</a>，这里来分析下Retrofit的使用：</p>
<h1 id="一、gradle添加依赖"><a href="#一、gradle添加依赖" class="headerlink" title="一、gradle添加依赖"></a>一、gradle添加依赖</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'com.squareup.okhttp:okhttp:2.4.0'</span></span><br><span class="line">compile <span class="string">'com.squareup.okhttp:okhttp-urlconnection:2.4.0'</span></span><br><span class="line">compile <span class="string">'com.squareup.okio:okio:1.5.0'</span></span><br><span class="line">compile <span class="string">'com.google.code.gson:gson:2.2.4'</span></span><br><span class="line"></span><br><span class="line">compile <span class="string">'com.squareup.retrofit:retrofit:2.0.0-beta2'</span></span><br><span class="line">compile <span class="string">'com.squareup.retrofit:adapter-rxjava:2.0.0-beta2'</span></span><br><span class="line">compile <span class="string">'com.squareup.retrofit:converter-gson:2.0.0-beta2'</span></span><br><span class="line"></span><br><span class="line">compile <span class="string">'io.reactivex:rxandroid:1.1.0'</span></span><br><span class="line">compile <span class="string">'io.reactivex:rxjava:1.1.0'</span></span><br></pre></td></tr></table></figure>
<p><strong>盗两张网上的图：</strong><br>下面是从创建Retrofit出发，具体的使用流程；Retrofit最终的请求操作都是交由okHttp去执行的，执行的结果返回Response，再根据转换器进行解析成相对应的返回类型T;<br>Retrofit中使用了动态代理，方便了使用；通过retrofit.create返回的其实是个动态代理类，所有具体的处理逻辑交由MethodHandler进行处理；<br><img src="http://img.blog.csdn.net/20160525163915246" alt="这里写图片描述"><br>下面是Retrofit系统中的整个类图，有点像外观模式，Retrofit持有所有子系统的引用；Retrofit比较重要的是两个Factory，一个使用来生成CallAdapter的CallAdapterFactory；一个是用来转换结果的ConvertFactory；这两个都可以用户自己进行添加。<br>在自定义的Service中，每一个method对应一个MethodHandler,MethodHandler持有retrofit，前面两个Factory以及生成Request的RequestFactory；在okHttp中，Request需要自己进行定义创建，而Retrofit简化了这个操作，进行了相应的封装，使用注解的方式来定义Request的相关参数信息；注解信息的解析则在RequestFactory中完成，通过RequestFactoryParser对注解信息进行简单解析，RequestBuilderAction是解析method中参数中的注解如@Path这些产生的中间产物，最终通过RequestBuilder来具体产生一个Request，RequestBuilder中持有okHttp中的Request.Builder类的引用，其创建Request过程其实都是交给okHttp来操作的；<br>生成的Request最终封装成为一个OkHttpCall，OkHttpCall则可以看做是对okHttp中Call的通过，它的enqueue等网络请求操作都是委托个给okHttp来操作的；同时对okHttp的返回Response进行解析，使用convertFactory，将其解析为用户所期望的返回类型；<br><img src="http://img.blog.csdn.net/20160525163925856" alt="这里写图片描述"></p>
<h1 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h1><h2 id="（一）使用Call形式"><a href="#（一）使用Call形式" class="headerlink" title="（一）使用Call形式"></a>（一）使用Call形式</h2><h3 id="1、定义请求接口："><a href="#1、定义请求接口：" class="headerlink" title="1、定义请求接口："></a>1、定义请求接口：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetrofirHttpService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"&#123;user&#125;"</span>)</span><br><span class="line">    <span class="function">Call&lt;UserInfo&gt; <span class="title">getData</span><span class="params">(@Path(<span class="string">"user"</span>)</span> String user)</span>;</span><br><span class="line">&#125;</span><br><span class="line">注：UserInfo是自己定义的解析类：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">    String username;</span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、使用GET获取信息："><a href="#2、使用GET获取信息：" class="headerlink" title="2、使用GET获取信息："></a>2、使用GET获取信息：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始的CallBack方式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getUseCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加拦截器</span></span><br><span class="line">    OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    client.interceptors().add(<span class="keyword">new</span> LoggingInterceptor());</span><br><span class="line"></span><br><span class="line">    Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="string">"http://115.156.187.146/TransferServer/"</span>)</span><br><span class="line">            .client(client)                                     <span class="comment">// 添加okHttp</span></span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create()) <span class="comment">// GSON进行转换</span></span><br><span class="line">            .build();</span><br><span class="line">    RetrofirHttpService apiStores = retrofit.create(RetrofirHttpService.class);</span><br><span class="line">    Call&lt;UserInfo&gt; call = apiStores.getData(<span class="string">"ServerMain.php"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步调用</span></span><br><span class="line">    call.enqueue(<span class="keyword">new</span> Callback&lt;UserInfo&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Response&lt;UserInfo&gt; response, Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">            UserInfo data = response.body();</span><br><span class="line">            LogUtils.i(<span class="string">"Call Result:"</span> + data.m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            LogUtils.e(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="（二）使用RxJava形式"><a href="#（二）使用RxJava形式" class="headerlink" title="（二）使用RxJava形式"></a>（二）使用RxJava形式</h2><h3 id="1、定义请求接口"><a href="#1、定义请求接口" class="headerlink" title="1、定义请求接口"></a>1、定义请求接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RxHttpService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"&#123;path&#125;"</span>)</span><br><span class="line">    <span class="function">Observable&lt;UserInfo&gt; <span class="title">getData</span><span class="params">(@Path(<span class="string">"path"</span>)</span> String path)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、具体使用"><a href="#2、具体使用" class="headerlink" title="2、具体使用"></a>2、具体使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用RxJava方式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getUseRxJava</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加拦截器</span></span><br><span class="line">    OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    client.interceptors().add(<span class="keyword">new</span> LoggingInterceptor());</span><br><span class="line"></span><br><span class="line">    Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="string">"http://115.156.187.146/TransferServer/"</span>)</span><br><span class="line">            .client(client)  <span class="comment">// 添加okHttp</span></span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create()) <span class="comment">// GSON进行转换</span></span><br><span class="line">            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    RxHttpService apiStores = retrofit.create(RxHttpService.class);</span><br><span class="line">    Observable&lt;UserInfo&gt; observable = apiStores.getData(<span class="string">"ServerMain.php"</span>);</span><br><span class="line">    observable.subscribeOn(Schedulers.io())</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Observer&lt;UserInfo&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(UserInfo user)</span> </span>&#123;</span><br><span class="line">                    LogUtils.i(<span class="string">"Call Result:"</span> + user.m);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">                    LogUtils.e(error.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、源码分析："><a href="#三、源码分析：" class="headerlink" title="三、源码分析："></a>三、源码分析：</h1><h2 id="（一）先来看创建动态代理类的过程："><a href="#（一）先来看创建动态代理类的过程：" class="headerlink" title="（一）先来看创建动态代理类的过程："></a>（一）先来看创建动态代理类的过程：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RxHttpService apiStores = retrofit.create(RxHttpService.class);</span><br></pre></td></tr></table></figure>
<p>动态代理的知识具体见<a href="http://blog.csdn.net/woliuyunyicai/article/details/51381807" target="_blank" rel="external">《 设计模式汇总：结构型模型（上）》</a>中的代理模式中的解释。</p>
<h3 id="1）Retrofit-create"><a href="#1）Retrofit-create" class="headerlink" title="1）Retrofit#create:"></a>1）Retrofit#create:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Create an implementation of the API defined by the &#123;<span class="doctag">@code</span> service&#125; interface. */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) <span class="comment">// Single-interface proxy creation guarded by parameter safety.</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    Utils.validateServiceInterface(service);</span><br><span class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">        eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;service&#125;,</span><br><span class="line">            <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span><br><span class="line">                        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">                    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">                        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> loadMethodHandler(method).invoke(args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准的动态代理创建过程；<br>来看代理类和委托类之间的中间InvocationHandler类的invoke函数具体执行逻辑；<br><code>loadMethodHandler(method).invoke(args);</code></p>
<h3 id="2）Retrofit-loadMethodHandler"><a href="#2）Retrofit-loadMethodHandler" class="headerlink" title="2）Retrofit#loadMethodHandler:"></a>2）Retrofit#loadMethodHandler:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MethodHandler&lt;?&gt;&gt; methodHandlerCache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">MethodHandler&lt;?&gt; loadMethodHandler(Method method) &#123;</span><br><span class="line">    MethodHandler&lt;?&gt; handler;</span><br><span class="line">    <span class="keyword">synchronized</span> (methodHandlerCache) &#123;</span><br><span class="line">        handler = methodHandlerCache.get(method);</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handler = MethodHandler.create(<span class="keyword">this</span>, method);</span><br><span class="line">            methodHandlerCache.put(method, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Retrofit维护了一个method对应的Map，这里将method都封装成一个MethodHandler类（可以当作是委托类）；调用代理类，其实就是调用MethodHandler的invoke;所以具体的实现逻辑都在MethodHandler中；</p>
<h2 id="（二）MethodHanlder"><a href="#（二）MethodHanlder" class="headerlink" title="（二）MethodHanlder"></a>（二）MethodHanlder</h2><h3 id="1）MethodHandler类："><a href="#1）MethodHandler类：" class="headerlink" title="1）MethodHandler类："></a>1）MethodHandler类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// MethodHandler持有一个retrofit对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Retrofit retrofit;</span><br><span class="line">    <span class="comment">// 类似于Volley中的 Request ，包含了HTTP请求的Url、Header信息，MediaType、Method以及RequestAction数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestFactory requestFactory;</span><br><span class="line">    <span class="comment">// HTTP请求返回数据的类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;T&gt; callAdapter;</span><br><span class="line">    <span class="comment">// 对返回数据进行转换的类型转换器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;ResponseBody, T&gt; responseConverter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MethodHandler</span><span class="params">(Retrofit retrofit, RequestFactory requestFactory,</span><br><span class="line">                          CallAdapter&lt;T&gt; callAdapter, Converter&lt;ResponseBody, T&gt; responseConverter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">        <span class="keyword">this</span>.requestFactory = requestFactory;</span><br><span class="line">        <span class="keyword">this</span>.callAdapter = callAdapter;</span><br><span class="line">        <span class="keyword">this</span>.responseConverter = responseConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一次请求的最终具体调用的函数</span></span><br><span class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以发现最终是调用callAdapter的adapt函数</span></span><br><span class="line">        <span class="comment">// 并且将相应的请求事务封装成一个OkHttpCall类进行处理</span></span><br><span class="line">        <span class="keyword">return</span> callAdapter.adapt(<span class="keyword">new</span> OkHttpCall&lt;&gt;(retrofit, requestFactory, responseConverter, args));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用该静态类创建一个MethodHandler实例</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">static</span> MethodHandler&lt;?&gt; create(Retrofit retrofit, Method method) &#123;</span><br><span class="line">        <span class="comment">// 创建CallAdapter</span></span><br><span class="line">        CallAdapter&lt;Object&gt; callAdapter = (CallAdapter&lt;Object&gt;) createCallAdapter(method, retrofit);</span><br><span class="line">        <span class="comment">// 根据callAdapter来获取相应的返回类型</span></span><br><span class="line">        Type responseType = callAdapter.responseType();</span><br><span class="line">        <span class="comment">// 创建结果类型转换器</span></span><br><span class="line">        Converter&lt;ResponseBody, Object&gt; responseConverter =</span><br><span class="line">                (Converter&lt;ResponseBody, Object&gt;) createResponseConverter(method, retrofit, responseType);</span><br><span class="line">        <span class="comment">// 创建RequestFactory</span></span><br><span class="line">        RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodHandler&lt;&gt;(retrofit, requestFactory, callAdapter, responseConverter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建相应的CallAdapter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CallAdapter&lt;?&gt; createCallAdapter(Method method, Retrofit retrofit) &#123;</span><br><span class="line">        <span class="comment">// 这个method即为service中自定义的一个方法，一般返回都是泛型类</span></span><br><span class="line">        Type returnType = method.getGenericReturnType();</span><br><span class="line">        <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Utils.methodError(method,</span><br><span class="line">                    <span class="string">"Method return type must not include a type variable or wildcard: %s"</span>, returnType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Utils.methodError(method, <span class="string">"Service methods cannot return void."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取Method上对应的注解即（GET这些）</span></span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据注解来获取相应的Adapter</span></span><br><span class="line">            <span class="keyword">return</span> retrofit.callAdapter(returnType, annotations);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">            <span class="keyword">throw</span> Utils.methodError(e, method, <span class="string">"Unable to create call adapter for %s"</span>, returnType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后也是调用retrofit来实现的；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Converter&lt;ResponseBody, ?&gt; createResponseConverter(Method method,</span><br><span class="line">                                                                      Retrofit retrofit, Type responseType) &#123;</span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> retrofit.responseConverter(responseType, annotations);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">            <span class="keyword">throw</span> Utils.methodError(e, method, <span class="string">"Unable to create converter for %s"</span>, responseType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MethodHandler是系统为定义的每一个Service中的method中创建的一个具体执行类，通过调用其invoke函数，来执行具体的请求的逻辑；<br>它主要包含四个变量：<br><strong>Retrofit:</strong> MethodHandler持有一个retrofit对象<br><code>private final Retrofit retrofit;</code><br><strong>RequestFactory:</strong> 类似于Volley中的 Request ，包含了HTTP请求的Url、Header信息，MediaType、Method以及RequestAction数组<br><code>private final RequestFactory requestFactory;</code><br><strong>CallAdapter:</strong> HTTP请求返回数据的类型<br><code>private final CallAdapter&lt;T&gt; callAdapter;</code><br><strong>ResponseConverter:</strong> 对返回数据进行转换的类型转换器<br><code>private final Converter&lt;ResponseBody, T&gt; responseConverter;</code><br>具体来看每个变量的创建；</p>
<h3 id="2）Retrofit-callAdapter"><a href="#2）Retrofit-callAdapter" class="headerlink" title="2）Retrofit#callAdapter:"></a>2）Retrofit#callAdapter:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; adapterFactories;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;</span><br><span class="line">    <span class="keyword">return</span> nextCallAdapter(<span class="keyword">null</span>, returnType, annotations);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns the &#123;<span class="doctag">@link</span> CallAdapter&#125; for &#123;<span class="doctag">@code</span> returnType&#125; from the available &#123;<span class="doctag">@linkplain</span></span><br><span class="line"> * #callAdapterFactories() factories&#125; except &#123;<span class="doctag">@code</span> skipPast&#125;.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// 返回相关的可用的CallAdapter（除了指定跳过的skipPast）</span></span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?&gt; nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,</span><br><span class="line">                                      Annotation[] annotations) &#123;</span><br><span class="line">    checkNotNull(returnType, <span class="string">"returnType == null"</span>);</span><br><span class="line">    checkNotNull(annotations, <span class="string">"annotations == null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = adapterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历adapterFactories中所有的Factory</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">        CallAdapter&lt;?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 如果找到，则返回该Adapter</span></span><br><span class="line">        <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> adapter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果获取不到相应的CallAdapter，则抛出异常</span></span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"Could not locate call adapter for "</span>)</span><br><span class="line">            .append(returnType)</span><br><span class="line">            .append(<span class="string">". Tried:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">        builder.append(<span class="string">"\n * "</span>).append(adapterFactories.get(i).getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (skipPast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        builder.append(<span class="string">"\nSkipped:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; start; i++) &#123;</span><br><span class="line">            builder.append(<span class="string">"\n * "</span>).append(adapterFactories.get(i).getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RetroFit中有一个adapterFactories保存了所有CallAdapter.Factory,通过遍历这些factory来获取相应符合的CallAdapter;<br>先来看adapterFactories都保存了哪些Factory；从Retrofit创建开始</p>
<h2 id="（三）Retrofit的创建"><a href="#（三）Retrofit的创建" class="headerlink" title="（三）Retrofit的创建"></a>（三）Retrofit的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BaseUrl baseUrl;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; adapterFactories;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Retrofit</span><span class="params">(OkHttpClient client, BaseUrl baseUrl, List&lt;Converter.Factory&gt; converterFactories,</span><br><span class="line">                 List&lt;CallAdapter.Factory&gt; adapterFactories, Executor callbackExecutor,</span><br><span class="line">                 <span class="keyword">boolean</span> validateEagerly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">    <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">    <span class="keyword">this</span>.converterFactories = converterFactories;</span><br><span class="line">    <span class="keyword">this</span>.adapterFactories = adapterFactories;</span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    <span class="keyword">this</span>.validateEagerly = validateEagerly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Create the &#123;<span class="doctag">@link</span> Retrofit&#125; instances. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base URL required."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认使用OkhttpClient</span></span><br><span class="line">    OkHttpClient client = <span class="keyword">this</span>.client;</span><br><span class="line">    <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">        client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向adapterFactories添加了一个默认的CallAdapterFactory</span></span><br><span class="line">    <span class="comment">// 如果前面add了CallAdpterfactory（如RxJavaCallAdapterFactory），则可以看到默认的Factory会添加到用户指定的Factory后面</span></span><br><span class="line">    <span class="comment">// 则在遍历的时候，会优先遍历用户指定的Factory</span></span><br><span class="line">    List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.adapterFactories);</span><br><span class="line">    adapterFactories.add(Platform.get().defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make a defensive copy of the converters.</span></span><br><span class="line">    List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.converterFactories);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(client, baseUrl, converterFactories, adapterFactories, callbackExecutor,</span><br><span class="line">            validateEagerly);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 用户添加自定义的CallAdapterFactory</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">addCallAdapterFactory</span><span class="params">(CallAdapter.Factory factory)</span> </span>&#123;</span><br><span class="line">    adapterFactories.add(checkNotNull(factory, <span class="string">"factory == null"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户可以根据自己需要来添加自定义的CallAdapterFactory，这里来看系统默认的CallAdapterFactory；<br>Platform.get()是根据系统不同来创建不同的运行环境，比如是再Android上还是Java上运行时由区别的，如下所示：</p>
<h3 id="1）Platform"><a href="#1）Platform" class="headerlink" title="1）Platform:"></a>1）Platform:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Platform PLATFORM = findPlatform();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Platform <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PLATFORM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Platform <span class="title">findPlatform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是Android系统</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"android.os.Build"</span>);</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Android();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是Java系统</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"java.util.Optional"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Java8();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是其他系统</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Platform();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建默认的CallAdapterFactory过程</span></span><br><span class="line">        <span class="meta">@Override</span> CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果没有指定callbackExecutor，或者为null，则新创建一个MainThreadExecutor</span></span><br><span class="line">                callbackExecutor = <span class="keyword">new</span> MainThreadExecutor();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该Executor的主要工作逻辑就是调用主线程的Looper来创建一个对应的Handler</span></span><br><span class="line">        <span class="comment">// 执行execute就是操作Handler进行post事件（Runnable）</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                handler.post(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到对应不同的系统平台，Retrofit提供了不同的Platform版本； 默认的CallAdapterFactory是个ExecutorCallAdapterFactory，它是通过callbackExecutor来创建的；<br>如果用户没有执行相应的callbackExecutor，系统或创建一个默认的MainThreadExecutor，该MainThreadExecutor的主要执行逻辑就是使用主线程的Handler来post Runnable消息；<br>然后Retrofit把ExecutorCallAdapterFactory实例添加到adapterFactories中；</p>
<h3 id="2）继续前面MethodHandler的查找CallAdapter的逻辑："><a href="#2）继续前面MethodHandler的查找CallAdapter的逻辑：" class="headerlink" title="2）继续前面MethodHandler的查找CallAdapter的逻辑："></a>2）继续前面MethodHandler的查找CallAdapter的逻辑：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CallAdapter&lt;?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallAdapterFactory</span> <span class="keyword">implements</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">    ExecutorCallAdapterFactory(Executor callbackExecutor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CallAdapter&lt;Call&lt;?&gt;&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">        <span class="comment">// 根据returnType获得具体的返回类型</span></span><br><span class="line">        <span class="keyword">if</span> (Utils.getRawType(returnType) != Call.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Type responseType = Utils.getCallResponseType(returnType);</span><br><span class="line">        <span class="comment">// 返回一个CallAdapter</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> responseType;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用adapt返回一个ExecutorCallbackCall类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;R&gt; <span class="function">Call&lt;R&gt; <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 将前面所有的逻辑串在一起，使用动态代理创建的代理类使用的InvokeHandler，调用其invoke来实现一个具体的方法调用；委托类是系统自定义创建的MethodHandler，系统根据method来创建相应的MethodHandler;MethodHandler中持有对CallAdapter的引用，CallAdapter是通过相应的CallAdpterFactory来创建的，如果加入了自定义的比如RxJava，最终会添加到Retrofit中的一个factory链表中，系统通过扫描链表来获取合适的CallAdpterFactory来创建CallAdapter;<br>如果没有自定义CallAdapterFactory，则会默认生成一个CallAdapterFactory;通过这个默认的Factory会创建一个默认的CallAdapter；<br>代理类的方法实现，是通过InvokeHandler的invoke来实现的；在系统定义的Invokehandler中进而调用MethodHandler的invoke函数，该invoke函数会继续调用CallAdpter的adapt,由上知，最终返回一个ExecutorCallbackCall类；</p>
<p>继续来看ExecutorCallbackCall类：</p>
<h3 id="3）ExecutorCallbackCall类："><a href="#3）ExecutorCallbackCall类：" class="headerlink" title="3）ExecutorCallbackCall类："></a>3）ExecutorCallbackCall类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallAdapterFactory</span> <span class="keyword">implements</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这里的Call传递进来的是一个封装好的OkHttpCall类</span></span><br><span class="line">        ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">            <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">            <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">            delegate.enqueue(<span class="keyword">new</span> ExecutorCallback&lt;&gt;(callbackExecutor, callback));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> delegate.execute();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            delegate.cancel();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"CloneDoesntCallSuperClone"</span>) <span class="comment">// Performing deep clone.</span></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;T&gt; <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallback</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Callback&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">        ExecutorCallback(Executor callbackExecutor, Callback&lt;T&gt; delegate) &#123;</span><br><span class="line">            <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">            <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(<span class="keyword">final</span> Response&lt;T&gt; response, <span class="keyword">final</span> Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">            callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    delegate.onResponse(response, retrofit);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">            callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    delegate.onFailure(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来ExecutorCallbackCall也是一个代理类，它的委托类是OkHttpCall；所以使用默认的CallAdapterFactory返回的是一个封装了OkHttpCall的一个Call类，其具体的类型是ExecutorCallbackCall；</p>
<h3 id="4）OkHttpCall"><a href="#4）OkHttpCall" class="headerlink" title="4）OkHttpCall:"></a>4）OkHttpCall:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Retrofit retrofit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestFactory requestFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;ResponseBody, T&gt; responseConverter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> com.squareup.okhttp.Call rawCall;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> executed; <span class="comment">// Guarded by this.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled;</span><br><span class="line"></span><br><span class="line">    OkHttpCall(Retrofit retrofit, RequestFactory requestFactory,</span><br><span class="line">               Converter&lt;ResponseBody, T&gt; responseConverter, Object[] args) &#123;</span><br><span class="line">        <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">        <span class="keyword">this</span>.requestFactory = requestFactory;</span><br><span class="line">        <span class="keyword">this</span>.responseConverter = responseConverter;</span><br><span class="line">        <span class="keyword">this</span>.args = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"CloneDoesntCallSuperClone"</span>)</span><br><span class="line">    <span class="comment">// We are a final type &amp; this saves clearing state.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OkHttpCall&lt;T&gt; <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OkHttpCall&lt;&gt;(retrofit, requestFactory, responseConverter, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看enqueue操作；在用户代码中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;UserInfo&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Response&lt;UserInfo&gt; response, Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">        UserInfo data = response.body();</span><br><span class="line">        LogUtils.i(<span class="string">"Call Result:"</span> + data.m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        LogUtils.e(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>由前面知这里的Call对应的是一个ExecutorCallbackCall，来看起enqueue操作：</p>
<h3 id="5）ExecutorCallbackCall-enqueue"><a href="#5）ExecutorCallbackCall-enqueue" class="headerlink" title="5）ExecutorCallbackCall#enqueue:"></a>5）ExecutorCallbackCall#enqueue:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    delegate.enqueue(<span class="keyword">new</span> ExecutorCallback&lt;&gt;(callbackExecutor, callback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delegate对应的即是OkHttpCall,先来看其enqueue传入的参数： ExecutorCallback<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallback</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callback&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    ExecutorCallback(Executor callbackExecutor, Callback&lt;T&gt; delegate) &#123;</span><br><span class="line">        <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(<span class="keyword">final</span> Response&lt;T&gt; response, <span class="keyword">final</span> Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">        callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                delegate.onResponse(response, retrofit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">        callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                delegate.onFailure(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ExecutorCallback也是一个代理类，用来封装用户定义的Callback，即类内部的变量delegate；callbackExecutor是查找Platform过程中new Android时创建的，其execute的逻辑较为简单，就是使用主线程对应的Handler来将Runnable事件post出去；可以看到，这里最终的响应都会在主线程中，而且调用用户自定义的onResponse和onFailure;<br>ExecutorCallback的主要作用就是封装Callback，将Callback的响应切换到主线程中；</p>
<h3 id="6）继续来看对应的OkHttpCall的enqueue操作："><a href="#6）继续来看对应的OkHttpCall的enqueue操作：" class="headerlink" title="6）继续来看对应的OkHttpCall的enqueue操作："></a>6）继续来看对应的OkHttpCall的enqueue操作：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意okHttp的call和retrofit的Call是不同</span></span><br><span class="line">    com.squareup.okhttp.Call rawCall;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个okhttp类型的Call</span></span><br><span class="line">        rawCall = createRawCall();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        callback.onFailure(t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果取消</span></span><br><span class="line">    <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">        rawCall.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.rawCall = rawCall;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Call中事务全部委托给okHttp来操作</span></span><br><span class="line">    <span class="comment">// 调用okHttp的enqueue，使用okHttp的Callback来封装retrofit中的Callback</span></span><br><span class="line">    rawCall.enqueue(<span class="keyword">new</span> com.squareup.okhttp.Callback() &#123;</span><br><span class="line">        <span class="comment">// 请求失败的响应</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailure</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                callback.onFailure(e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 请求成功的响应</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callSuccess</span><span class="params">(Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                callback.onResponse(response, retrofit);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Request request, IOException e)</span> </span>&#123;</span><br><span class="line">            callFailure(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(com.squareup.okhttp.Response rawResponse)</span> </span>&#123;</span><br><span class="line">            Response&lt;T&gt; response;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获得结果，并且解析结果</span></span><br><span class="line">                response = parseResponse(rawResponse);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                callFailure(e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            callSuccess(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OkHttpCall是对OkHttp里面的Call的封装，将所有的操作都委托给该Call进行操作；这里主要的是通过retrofit的call来创建一个okHttp的Call类；这里通过createRawCall来创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> com.squareup.okhttp.<span class="function">Call <span class="title">createRawCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> retrofit.client().newCall(requestFactory.create(args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里是通过okHttpClient来创建的一个Call；首先来看 requestFactory是如何根据args参数来创建一个相应的Call的；<br>先来看requestFactory，它是MethodHandler中创建传递过来的；<br><code>RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);</code></p>
<h2 id="（四）RequestFactory："><a href="#（四）RequestFactory：" class="headerlink" title="（四）RequestFactory："></a>（四）RequestFactory：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestFactoryParser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> RequestFactory <span class="title">parse</span><span class="params">(Method method, Type responseType, Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">        RequestFactoryParser parser = <span class="keyword">new</span> RequestFactoryParser(method);</span><br><span class="line">        <span class="comment">// Method对应的注解这里解析</span></span><br><span class="line">        parser.parseMethodAnnotations(responseType);</span><br><span class="line">        parser.parseParameters(retrofit);</span><br><span class="line">        <span class="comment">// 创建一个RequestFactory</span></span><br><span class="line">        <span class="keyword">return</span> parser.toRequestFactory(retrofit.baseUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RequestFactoryParser</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RequestFactoryParser主要是根据method对应的注解及返回类型进行相应解析，得出相应的解析结果，然后创建一个RequestFactory来保存所有解析后结果，供创建OkHttpCall来使用。</p>
<h3 id="lt-一-gt-parseMethodAnnotations："><a href="#lt-一-gt-parseMethodAnnotations：" class="headerlink" title="&lt;一&gt;parseMethodAnnotations："></a>&lt;一&gt;parseMethodAnnotations：</h3><h4 id="1）RequestFactoryParser-parseMethodAnnotations："><a href="#1）RequestFactoryParser-parseMethodAnnotations：" class="headerlink" title="1）RequestFactoryParser#parseMethodAnnotations："></a>1）RequestFactoryParser#parseMethodAnnotations：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是对注解进行解析的核心代码</span></span><br><span class="line"><span class="comment">// 根据注解类型的不同（即请求类型类型的不同进行相应解析）</span></span><br><span class="line"><span class="comment">// 这里也对应的retrofit的基本用法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseMethodAnnotations</span><span class="params">(Type responseType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : method.getAnnotations()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> DELETE) &#123;</span><br><span class="line">            parseHttpMethodAndPath(<span class="string">"DELETE"</span>, ((DELETE) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> GET) &#123;</span><br><span class="line">            parseHttpMethodAndPath(<span class="string">"GET"</span>, ((GET) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HEAD) &#123;</span><br><span class="line">            parseHttpMethodAndPath(<span class="string">"HEAD"</span>, ((HEAD) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (!Void.class.equals(responseType)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> methodError(method, <span class="string">"HEAD method must use Void as response type."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PATCH) &#123;</span><br><span class="line">            parseHttpMethodAndPath(<span class="string">"PATCH"</span>, ((PATCH) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> POST) &#123;</span><br><span class="line">            parseHttpMethodAndPath(<span class="string">"POST"</span>, ((POST) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PUT) &#123;</span><br><span class="line">            parseHttpMethodAndPath(<span class="string">"PUT"</span>, ((PUT) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HTTP) &#123;</span><br><span class="line">            HTTP http = (HTTP) annotation;</span><br><span class="line">            parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Headers) &#123;</span><br><span class="line">            <span class="comment">// 只有Headers是通过parseHeaders来解析的</span></span><br><span class="line">            String[] headersToParse = ((Headers) annotation).value();</span><br><span class="line">            <span class="keyword">if</span> (headersToParse.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> methodError(method, <span class="string">"@Headers annotation is empty."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            headers = parseHeaders(headersToParse);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Multipart) &#123;</span><br><span class="line">            <span class="comment">// 可以看到Multipart和FormUrlEncoded不能同时定义</span></span><br><span class="line">            <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">                <span class="keyword">throw</span> methodError(method, <span class="string">"Only one encoding annotation is allowed."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            isMultipart = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> FormUrlEncoded) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">                <span class="keyword">throw</span> methodError(method, <span class="string">"Only one encoding annotation is allowed."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            isFormEncoded = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">"HTTP method annotation is required (e.g., @GET, @POST, etc.)."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不存在实体，但是用户定义为isMultipart或者isFormEncoded类型，则会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!hasBody) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">            <span class="keyword">throw</span> methodError(method,</span><br><span class="line">                    <span class="string">"Multipart can only be specified on HTTP methods with request body (e.g., @POST)."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">            <span class="keyword">throw</span> methodError(method,</span><br><span class="line">                    <span class="string">"FormUrlEncoded can only be specified on HTTP methods with request body "</span></span><br><span class="line">                            + <span class="string">"(e.g., @POST)."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是对注解进行解析的核心代码 ，根据注解类型的不同（即请求类型类型的不同） 进行相应解析，这里也对应的retrofit的基本用法；<br>可以看到除了headers使用的parseheader进行解析外，其他都是通过 parseHttpMethodAndPath进行解析的；这里来重点分析下parseHttpMethodAndPath；</p>
<h4 id="2）parseHttpMethodAndPath："><a href="#2）parseHttpMethodAndPath：" class="headerlink" title="2）parseHttpMethodAndPath："></a>2）parseHttpMethodAndPath：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数只是先做了一个前期判断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseHttpMethodAndPath</span><span class="params">(String httpMethod, String value, <span class="keyword">boolean</span> hasBody)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">"Only one HTTP method is allowed. Found: %s and %s."</span>,</span><br><span class="line">                <span class="keyword">this</span>.httpMethod, httpMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对应"GET","POST"等</span></span><br><span class="line">    <span class="keyword">this</span>.httpMethod = httpMethod;</span><br><span class="line">    <span class="comment">// 标注有没有实体</span></span><br><span class="line">    <span class="keyword">this</span>.hasBody = hasBody;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注解值为空直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断URL是否已经有查询字符串query string</span></span><br><span class="line">    <span class="comment">// Get the relative URL path and existing query string, if present.</span></span><br><span class="line">    <span class="keyword">int</span> question = value.indexOf(<span class="string">'?'</span>);</span><br><span class="line">    <span class="keyword">if</span> (question != -<span class="number">1</span> &amp;&amp; question &lt; value.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 保证URL的查询字符串中没有&#123;...&#125;之类的字符</span></span><br><span class="line">        <span class="comment">// Ensure the query string does not have any named parameters.</span></span><br><span class="line">        String queryParams = value.substring(question + <span class="number">1</span>);</span><br><span class="line">        Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);</span><br><span class="line">        <span class="keyword">if</span> (queryParamMatcher.find()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> methodError(method, <span class="string">"URL query string \"%s\" must not have replace block. "</span></span><br><span class="line">                    + <span class="string">"For dynamic query parameters use @Query."</span>, queryParams);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体的解析继续由parsePathParameters来完成</span></span><br><span class="line">    <span class="keyword">this</span>.relativeUrl = value;</span><br><span class="line">    <span class="keyword">this</span>.relativeUrlParamNames = parsePathParameters(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数仅是做了一个简单的前期判断，将method对应的请求类型（httpMethod） ，注解值（relativeUrl），以及是否包含实体信息（hasBody）赋值给该RequestFactoryParser;<br>来看POST和GET的简单调用实例：<br><code>parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);</code><br><code>parseHttpMethodAndPath(&quot;POST&quot;, ((POST) annotation).value(), true);</code><br>继续来看解析函数parsePathParameters :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM = <span class="string">"[a-zA-Z][a-zA-Z0-9_-]*"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PARAM_URL_REGEX = Pattern.compile(<span class="string">"\\&#123;("</span> + PARAM + <span class="string">")\\&#125;"</span>);</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Gets the set of unique path parameters used in the given URI. If a parameter is used twice</span><br><span class="line"> * in the URI, it will only show up once in the set.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// 检测出路径中所有&#123;..&#125;的字段，如&#123;user&#125;等，添加到一个Set中（因此不会重复添加）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Set&lt;String&gt; <span class="title">parsePathParameters</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    Matcher m = PARAM_URL_REGEX.matcher(path);</span><br><span class="line">    Set&lt;String&gt; patterns = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">        patterns.add(m.group(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> patterns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一步仅是根据正则表达式获取URL中所有{…}类型的数据，添加到patterns这个Set中，然后返回给RequestFactoryParser，对relativeUrlParamNames进行赋值；</p>
<p>第一步解析完毕，来到第二步parseParameters：</p>
<h3 id="lt-二-gt-parseParameters："><a href="#lt-二-gt-parseParameters：" class="headerlink" title="&lt;二&gt;parseParameters："></a>&lt;二&gt;parseParameters：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseParameters</span><span class="params">(Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">    Type[] methodParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">    <span class="comment">// 获取method所有参数中的所有的注解信息</span></span><br><span class="line">    Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> gotField = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> gotPart = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> gotBody = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> gotPath = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> gotQuery = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> gotUrl = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = methodParameterAnnotationArrays.length;</span><br><span class="line">    <span class="comment">// 这里是一个重要的类</span></span><br><span class="line">    RequestBuilderAction[] requestBuilderActions = <span class="keyword">new</span> RequestBuilderAction[count];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Type methodParameterType = methodParameterTypes[i];</span><br><span class="line">        Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i];</span><br><span class="line">        <span class="keyword">if</span> (methodParameterAnnotations != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Annotation methodParameterAnnotation : methodParameterAnnotations) &#123;</span><br><span class="line">                RequestBuilderAction action = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 解析URL</span></span><br><span class="line">                <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Url) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (gotUrl) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"Multiple @Url method annotations found."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (gotPath) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Path parameters may not be used with @Url."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (gotQuery) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"A @Url parameter must not come after a @Query"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (methodParameterType != String.class) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Url must be String type."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (relativeUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Url cannot be used with @%s URL"</span>, httpMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                    gotUrl = <span class="keyword">true</span>;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Url();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Path) &#123; <span class="comment">// 解析Path注解</span></span><br><span class="line">                    <span class="keyword">if</span> (gotQuery) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"A @Path parameter must not come after a @Query."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (gotUrl) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Path parameters may not be used with @Url."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (relativeUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Path can only be used with relative url on @%s"</span>,</span><br><span class="line">                                httpMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                    gotPath = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    Path path = (Path) methodParameterAnnotation;</span><br><span class="line">                    String name = path.value();</span><br><span class="line">                    validatePathName(i, name);</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Path(name, path.encoded());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Query) &#123; <span class="comment">// 解析Query注解</span></span><br><span class="line">                    Query query = (Query) methodParameterAnnotation;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Query(query.value(), query.encoded());</span><br><span class="line">                    gotQuery = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> QueryMap) &#123; <span class="comment">// 解析QueryMap注解</span></span><br><span class="line">                    <span class="keyword">if</span> (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@QueryMap parameter type must be Map."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    QueryMap queryMap = (QueryMap) methodParameterAnnotation;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.QueryMap(queryMap.encoded());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Header) &#123; <span class="comment">// 解析header注解</span></span><br><span class="line">                    Header header = (Header) methodParameterAnnotation;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Header(header.value());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Field) &#123; <span class="comment">// 解析Field注解</span></span><br><span class="line">                    <span class="keyword">if</span> (!isFormEncoded) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Field parameters can only be used with form encoding."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Field field = (Field) methodParameterAnnotation;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Field(field.value(), field.encoded());</span><br><span class="line">                    gotField = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> FieldMap) &#123; <span class="comment">// 解析FieldMap</span></span><br><span class="line">                    <span class="keyword">if</span> (!isFormEncoded) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@FieldMap parameters can only be used with form encoding."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@FieldMap parameter type must be Map."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    FieldMap fieldMap = (FieldMap) methodParameterAnnotation;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.FieldMap(fieldMap.encoded());</span><br><span class="line">                    gotField = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Part) &#123; <span class="comment">// 解析Part</span></span><br><span class="line">                    <span class="keyword">if</span> (!isMultipart) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Part parameters can only be used with multipart encoding."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Part part = (Part) methodParameterAnnotation;</span><br><span class="line">                    com.squareup.okhttp.Headers headers = com.squareup.okhttp.Headers.of(</span><br><span class="line">                            <span class="string">"Content-Disposition"</span>, <span class="string">"form-data; name=\""</span> + part.value() + <span class="string">"\""</span>,</span><br><span class="line">                            <span class="string">"Content-Transfer-Encoding"</span>, part.encoding());</span><br><span class="line">                    Converter&lt;?, RequestBody&gt; converter;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        converter =</span><br><span class="line">                                retrofit.requestConverter(methodParameterType, methodParameterAnnotations);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">                        <span class="keyword">throw</span> parameterError(e, i, <span class="string">"Unable to create @Part converter for %s"</span>,</span><br><span class="line">                                methodParameterType);</span><br><span class="line">                    &#125;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Part&lt;&gt;(headers, converter);</span><br><span class="line">                    gotPart = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> PartMap) &#123; <span class="comment">//解析PartMap</span></span><br><span class="line">                    <span class="keyword">if</span> (!isMultipart) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i,</span><br><span class="line">                                <span class="string">"@PartMap parameters can only be used with multipart encoding."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@PartMap parameter type must be Map."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    PartMap partMap = (PartMap) methodParameterAnnotation;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.PartMap(retrofit, partMap.encoding(),</span><br><span class="line">                            methodParameterAnnotations);</span><br><span class="line">                    gotPart = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Body) &#123; <span class="comment">// 解析Body</span></span><br><span class="line">                    <span class="keyword">if</span> (isFormEncoded || isMultipart) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i,</span><br><span class="line">                                <span class="string">"@Body parameters cannot be used with form or multi-part encoding."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (gotBody) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"Multiple @Body method annotations found."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Converter&lt;?, RequestBody&gt; converter;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        converter =</span><br><span class="line">                                retrofit.requestConverter(methodParameterType, methodParameterAnnotations);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">                        <span class="keyword">throw</span> parameterError(e, i, <span class="string">"Unable to create @Body converter for %s"</span>,</span><br><span class="line">                                methodParameterType);</span><br><span class="line">                    &#125;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Body&lt;&gt;(converter);</span><br><span class="line">                    gotBody = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (action != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (requestBuilderActions[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"Multiple Retrofit annotations found, only one allowed."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    requestBuilderActions[i] = action;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (requestBuilderActions[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> parameterError(i, <span class="string">"No Retrofit annotation found."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (relativeUrl == <span class="keyword">null</span> &amp;&amp; !gotUrl) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">"Missing either @%s URL or @Url parameter."</span>, httpMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">"Non-body HTTP method cannot contain @Body."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">"Form-encoded method must contain at least one @Field."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">"Multipart method must contain at least one @Part."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.requestBuilderActions = requestBuilderActions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是根据method里面对应的参数中的注解比如<code>@(Url,Path,Query,QueryMap,Header,Field,FieldMap,Part,PartMap,Body)</code>，它们的解析操作都是通过创建一个RequestBuilderAction类进行相应的解析，比如@Path，解析则调用的是创建一个RequestBuilderAction.Path，Path类是RequestBuilderAction的静态内部类，继承了RequestBuilderAction；最后所有参数中的注解对应一个RequestBuilderAction数组requestBuilderActions，把这个数组赋值给RequestFactoryParser;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBuilderAction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(RequestBuilder builder, Object value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RequestBuilderAction是个抽象类，它内部有一个perform的抽象方法；还有一些具体的内部类继承该方法，根据不同的注解，来创建不同的静态内部类，这些静态内部类都继承了RequestBuilderAction，并且重写了自己的perform方法；<br>如Path:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Path</span> <span class="keyword">extends</span> <span class="title">RequestBuilderAction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> encoded;</span><br><span class="line"></span><br><span class="line">  Path(String name, <span class="keyword">boolean</span> encoded) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = checkNotNull(name, <span class="string">"name == null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.encoded = encoded;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">perform</span><span class="params">(RequestBuilder builder, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">          <span class="string">"Path parameter \""</span> + name + <span class="string">"\" value must not be null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.addPathParam(name, value.toString(), encoded);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这里涉及到一个 RequestBuilder的概念，等到具体使用的时候再进行分析；</p>
<h3 id="lt-三-gt-parser-toRequestFactory-retrofit-baseUrl"><a href="#lt-三-gt-parser-toRequestFactory-retrofit-baseUrl" class="headerlink" title="&lt;三&gt;parser.toRequestFactory(retrofit.baseUrl())"></a>&lt;三&gt;parser.toRequestFactory(retrofit.baseUrl())</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RequestFactory <span class="title">toRequestFactory</span><span class="params">(BaseUrl baseUrl)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RequestFactory(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody,</span><br><span class="line">      isFormEncoded, isMultipart, requestBuilderActions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一步将所有解析完的信息封装成一个 RequestFactory；<br>则继续来看第（三）步中okHttp创建Call是传递进来的参数：requestFactory.create(args)</p>
<h4 id="1）RequestFactory-create"><a href="#1）RequestFactory-create" class="headerlink" title="1）RequestFactory#create:"></a>1）RequestFactory#create:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BaseUrl baseUrl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String relativeUrl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Headers headers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MediaType contentType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> hasBody;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isFormEncoded;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isMultipart;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestBuilderAction[] requestBuilderActions;</span><br><span class="line"></span><br><span class="line">    RequestFactory(String method, BaseUrl baseUrl, String relativeUrl, Headers headers,</span><br><span class="line">                   MediaType contentType, <span class="keyword">boolean</span> hasBody, <span class="keyword">boolean</span> isFormEncoded, <span class="keyword">boolean</span> isMultipart,</span><br><span class="line">                   RequestBuilderAction[] requestBuilderActions) &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">        <span class="keyword">this</span>.relativeUrl = relativeUrl;</span><br><span class="line">        <span class="keyword">this</span>.headers = headers;</span><br><span class="line">        <span class="keyword">this</span>.contentType = contentType;</span><br><span class="line">        <span class="keyword">this</span>.hasBody = hasBody;</span><br><span class="line">        <span class="keyword">this</span>.isFormEncoded = isFormEncoded;</span><br><span class="line">        <span class="keyword">this</span>.isMultipart = isMultipart;</span><br><span class="line">        <span class="keyword">this</span>.requestBuilderActions = requestBuilderActions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Request <span class="title">create</span><span class="params">(Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个RequestBuilder，它是真正创建Request的类</span></span><br><span class="line">        RequestBuilder requestBuilder =</span><br><span class="line">                <span class="keyword">new</span> RequestBuilder(method, baseUrl.url(), relativeUrl, headers, contentType, hasBody,</span><br><span class="line">                        isFormEncoded, isMultipart);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 前面解析method参数中的注解获取到的RequestBuilderAction</span></span><br><span class="line">            RequestBuilderAction[] actions = requestBuilderActions;</span><br><span class="line">            <span class="keyword">if</span> (actions.length != args.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Argument count ("</span></span><br><span class="line">                        + args.length</span><br><span class="line">                        + <span class="string">") doesn't match action count ("</span></span><br><span class="line">                        + actions.length</span><br><span class="line">                        + <span class="string">")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = args.length; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="comment">// 这里调用RequestBuilderAction的perform进行创建</span></span><br><span class="line">                actions[i].perform(requestBuilder, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建造者模型，返回一个build</span></span><br><span class="line">        <span class="keyword">return</span> requestBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到RequestFactory在create时创建了一个RequestBuilder，它是一个典型的Builder模式，也就是类似OkHttp的Request Buidler模式，由用户调用builder自定义来转化为通过注解方式进行定义，而Retrofit通过解析注解信息，分析用户行为，然后将解析信息添加到requestBuidler中来自行构造Request；它暴漏出注解定义的方式，而将具体的Request Builder细节隐藏了。<br>这里终点来看RequestBuidler，前面分析method参数类型获得的RequestBuilderAction，其具体的perform也是通过RequestBuilderAction来实现的；</p>
<h3 id="lt-四-gt-RequestBuilder："><a href="#lt-四-gt-RequestBuilder：" class="headerlink" title="&lt;四&gt;RequestBuilder："></a>&lt;四&gt;RequestBuilder：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBuilder</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注意这里的Request对应的是okHttp的request</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Request.Builder requestBuilder;</span><br><span class="line">    RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,</span><br><span class="line">                   MediaType contentType, <span class="keyword">boolean</span> hasBody, <span class="keyword">boolean</span> isFormEncoded, <span class="keyword">boolean</span> isMultipart) &#123;</span><br><span class="line"><span class="keyword">this</span>.method = method;</span><br><span class="line"><span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line"><span class="keyword">this</span>.relativeUrl = relativeUrl;</span><br><span class="line"><span class="keyword">this</span>.requestBuilder = <span class="keyword">new</span> Request.Builder();</span><br><span class="line"><span class="keyword">this</span>.contentType = contentType;</span><br><span class="line"><span class="keyword">this</span>.hasBody = hasBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (headers != <span class="keyword">null</span>) &#123;</span><br><span class="line">requestBuilder.headers(headers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line"><span class="comment">// Will be set to 'body' in 'build'.</span></span><br><span class="line">formEncodingBuilder = <span class="keyword">new</span> FormEncodingBuilder();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line"><span class="comment">// Will be set to 'body' in 'build'.</span></span><br><span class="line">multipartBuilder = <span class="keyword">new</span> MultipartBuilder();</span><br><span class="line">            multipartBuilder.type(MultipartBuilder.FORM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Retrofit默认是通过okHttp来实现的，RequestBuidler其实将所有Request创建的任务交给真正的类Okhttp中的Request.Builder进行构造器request；相应的FormEncodingBuilder以及MultipartBuilder也都是okHttp内部的；<br>RequestBuilderAction中的perform也都是通过RequestBuidler的函数来实现的，比如@Path:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Path</span> <span class="keyword">extends</span> <span class="title">RequestBuilderAction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> encoded;</span><br><span class="line"></span><br><span class="line">    Path(String name, <span class="keyword">boolean</span> encoded) &#123;</span><br><span class="line">       <span class="keyword">this</span>.name = checkNotNull(name, <span class="string">"name == null"</span>);</span><br><span class="line">       <span class="keyword">this</span>.encoded = encoded;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">perform</span><span class="params">(RequestBuilder builder, Object value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">       <span class="string">"Path parameter \""</span> + name + <span class="string">"\" value must not be null."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       builder.addPathParam(name, value.toString(), encoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到调用的RequestBuilder的addPathParam方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addPathParam</span><span class="params">(String name, String value, <span class="keyword">boolean</span> encoded)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (relativeUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// The relative URL is cleared when the first query parameter is set.</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">     &#125;</span><br><span class="line">    relativeUrl = relativeUrl.replace(<span class="string">"&#123;"</span> + name + <span class="string">"&#125;"</span>, canonicalize(value, encoded));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再来看RequestFactory#create的返回值，即RequestBuilder.builder:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Request <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  HttpUrl url;</span><br><span class="line">  HttpUrl.Builder urlBuilder = <span class="keyword">this</span>.urlBuilder;</span><br><span class="line">  <span class="keyword">if</span> (urlBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    url = urlBuilder.build();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No query parameters triggered builder creation, just combine the relative URL and base URL.</span></span><br><span class="line">    url = baseUrl.resolve(relativeUrl);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RequestBody body = <span class="keyword">this</span>.body;</span><br><span class="line">  <span class="keyword">if</span> (body == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Try to pull from one of the builders.</span></span><br><span class="line">    <span class="keyword">if</span> (formEncodingBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      body = formEncodingBuilder.build();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (multipartBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      body = multipartBuilder.build();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasBody) &#123;</span><br><span class="line">      <span class="comment">// Body is absent, make an empty body.</span></span><br><span class="line">      body = RequestBody.create(<span class="keyword">null</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MediaType contentType = <span class="keyword">this</span>.contentType;</span><br><span class="line">  <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">      body = <span class="keyword">new</span> ContentTypeOverridingRequestBody(body, contentType);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      requestBuilder.addHeader(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> requestBuilder</span><br><span class="line">      .url(url)</span><br><span class="line">      .method(method, body)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可想而知最后调用的是okHttp总的builder来具体创建一个Request,具体的创建细节见okHttp源码解析；<br>因此返回的是一个okHttp中的Request；来看具体的创建：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">retrofit.client().newCall(requestFactory.create(args));</span><br><span class="line">OkHttpClient#newCall:</span><br><span class="line">/**</span><br><span class="line"> * Prepares the &#123;@code request&#125; to be executed at some point in the future.</span><br><span class="line"> */</span><br><span class="line">public Call newCall(Request request) &#123;</span><br><span class="line">    return new Call(this, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将Request封装成一个Call；因此，接下来的所有网络请求操作都交由okHttp进行处理；</p>
<h3 id="（五）这里来看具体的对返回结果的转换："><a href="#（五）这里来看具体的对返回结果的转换：" class="headerlink" title="（五）这里来看具体的对返回结果的转换："></a>（五）这里来看具体的对返回结果的转换：</h3><p>在调用OkHttpCall的enqueue时，可以看到Callback中会对结果Response(okHttp中的)进行进一步解析，然后将解析后的结果通过Retrofit中定义的callback进行返回，返回的结果为Response<t>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">rawCall.enqueue(<span class="keyword">new</span> com.squareup.okhttp.Callback() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailure</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                callback.onFailure(e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callSuccess</span><span class="params">(Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            callback.onResponse(response, retrofit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Request request, IOException e)</span> </span>&#123;</span><br><span class="line">        callFailure(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(com.squareup.okhttp.Response rawResponse)</span> </span>&#123;</span><br><span class="line">        Response&lt;T&gt; response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response = parseResponse(rawResponse);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            callFailure(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        callSuccess(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></t></p>
<p>可以看到主要解析过程则在于parseResponse中；</p>
<h4 id="1）OkHttpCall-parseResponse："><a href="#1）OkHttpCall-parseResponse：" class="headerlink" title="1）OkHttpCall#parseResponse："></a>1）OkHttpCall#parseResponse：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(com.squareup.okhttp.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ResponseBody rawBody = rawResponse.body();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove the body's source (the only stateful object) so we can pass the response along.</span></span><br><span class="line">    rawResponse = rawResponse.newBuilder()</span><br><span class="line">            .body(<span class="keyword">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> code = rawResponse.code();</span><br><span class="line">    <span class="comment">// 如果请求失败</span></span><br><span class="line">    <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">            ResponseBody bufferedBody = Utils.readBodyToBytesIfNecessary(rawBody);</span><br><span class="line">            <span class="keyword">return</span> Response.error(bufferedBody, rawResponse);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeQuietly(rawBody);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有数据返回情况，则不用进行解析</span></span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Response.success(<span class="keyword">null</span>, rawResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ExceptionCatchingRequestBody是对okHttp的RequestBody类的一个封装</span></span><br><span class="line">    ExceptionCatchingRequestBody catchingBody = <span class="keyword">new</span> ExceptionCatchingRequestBody(rawBody);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 利用变换器进行转换</span></span><br><span class="line">        T body = responseConverter.convert(catchingBody);</span><br><span class="line">        <span class="comment">// 将转换后的实体结果和原Response封装成一个Response&lt;T&gt;</span></span><br><span class="line">        <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></span><br><span class="line">        <span class="comment">// a runtime exception.</span></span><br><span class="line">        catchingBody.throwIfCaught();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当请求发生错误，获取204情况没有实体返回时，自然不用对实体进行转化；而对于实体的转换是通过最初定义的转换器来（这里用的是GSON）来进行covert的；然后将转换后的结果同原始okHttp返回的Response封装成一个Response<t>进行返回；<br>先来看传递进来的转换器：</t></p>
<h4 id="2）ConverterFactory："><a href="#2）ConverterFactory：" class="headerlink" title="2）ConverterFactory："></a>2）ConverterFactory：</h4><p>是通过在build retrofit的时候添加的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">        .baseUrl("http://115.156.187.146/TransferServer/")</span><br><span class="line">        .client(client)                                     // 添加okHttp</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create()) // GSON进行转换</span><br><span class="line">        .build();</span><br><span class="line">Retrofit#ConverterFactory:</span><br><span class="line">/** Add converter factory for serialization and deserialization of objects. */</span><br><span class="line">public Builder addConverterFactory(Converter.Factory converterFactory) &#123;</span><br><span class="line">    converterFactories.add(checkNotNull(converterFactory, "converterFactory == null"));</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由前面的分析知，在创建MethodHandler时，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MethodHandler&lt;?&gt; create(Retrofit retrofit, Method method) &#123;</span><br><span class="line">    CallAdapter&lt;Object&gt; callAdapter = (CallAdapter&lt;Object&gt;) createCallAdapter(method, retrofit);</span><br><span class="line">    Type responseType = callAdapter.responseType();</span><br><span class="line">    <span class="comment">// 创建转换器</span></span><br><span class="line">    Converter&lt;ResponseBody, Object&gt; responseConverter =</span><br><span class="line">            (Converter&lt;ResponseBody, Object&gt;) createResponseConverter(method, retrofit, responseType);</span><br><span class="line">    RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MethodHandler&lt;&gt;(retrofit, requestFactory, callAdapter, responseConverter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Converter&lt;ResponseBody, ?&gt; createResponseConverter(Method method,</span><br><span class="line">                                                                  Retrofit retrofit, Type responseType) &#123;</span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> retrofit.responseConverter(responseType, annotations);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">        <span class="keyword">throw</span> Utils.methodError(e, method, <span class="string">"Unable to create converter for %s"</span>, responseType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进而根据返回数据类型调用Retrofit.responseConverter来创建；下面基本上和CallAdapterFactory基本相同的流程；通过遍历converterFactories链表进行获取相应的解析Converter:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">responseConverter</span><span class="params">(Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">    checkNotNull(type, <span class="string">"type == null"</span>);</span><br><span class="line">    checkNotNull(annotations, <span class="string">"annotations == null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 重点看这个解析函数</span></span><br><span class="line">        Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">                converterFactories.get(i).fromResponseBody(type, annotations);</span><br><span class="line">        <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            <span class="keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"Could not locate ResponseBody converter for "</span>)</span><br><span class="line">            .append(type)</span><br><span class="line">            .append(<span class="string">". Tried:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (Converter.Factory converterFactory : converterFactories) &#123;</span><br><span class="line">        builder.append(<span class="string">"\n * "</span>).append(converterFactory.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要的逻辑在：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重点看这个解析函数</span></span><br><span class="line">        Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">                converterFactories.get(i).fromResponseBody(type, annotations);</span><br><span class="line">这里的converterFactories.get(i)即是通过GsonConverterFactory.create()创建的GSON转换器；来看其具体细节；</span><br></pre></td></tr></table></figure></p>
<h4 id="3）GsonConverterFactory："><a href="#3）GsonConverterFactory：" class="headerlink" title="3）GsonConverterFactory："></a>3）GsonConverterFactory：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonConverterFactory</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Create an instance using a default &#123;<span class="doctag">@link</span> Gson&#125; instance for conversion. Encoding to JSON and</span><br><span class="line">   * decoding from JSON (when no charset is specified by a header) will use UTF-8.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GsonConverterFactory <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> Gson());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Create an instance using &#123;<span class="doctag">@code</span> gson&#125; for conversion. Encoding to JSON and</span><br><span class="line">   * decoding from JSON (when no charset is specified by a header) will use UTF-8.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GsonConverterFactory <span class="title">create</span><span class="params">(Gson gson)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GsonConverterFactory(gson);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">GsonConverterFactory</span><span class="params">(Gson gson)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (gson == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"gson == null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.gson = gson;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; fromResponseBody(Type type, Annotation[] annotations) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GsonResponseBodyConverter&lt;&gt;(gson, type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Converter&lt;?, RequestBody&gt; toRequestBody(Type type, Annotation[] annotations) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GsonRequestBodyConverter&lt;&gt;(gson, type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这个Factory很简单，就是持有了一个GSON实例对象；<br>上面调用了fromResponseBody，这里根据returntype来创建一个GsonRequestBodyConverter：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonRequestBodyConverter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">T</span>, <span class="title">RequestBody</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE = MediaType.parse(<span class="string">"application/json; charset=UTF-8"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset UTF_8 = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line"></span><br><span class="line">    GsonRequestBodyConverter(Gson gson, Type type) &#123;</span><br><span class="line">        <span class="keyword">this</span>.gson = gson;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestBody <span class="title">convert</span><span class="params">(T value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Buffer buffer = <span class="keyword">new</span> Buffer();</span><br><span class="line">        Writer writer = <span class="keyword">new</span> OutputStreamWriter(buffer.outputStream(), UTF_8);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            gson.toJson(value, type, writer);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e); <span class="comment">// Writing to Buffer does no I/O.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RequestBody.create(MEDIA_TYPE, buffer.readByteString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其转换函数convert逻辑也较为简单，将工作交给gson就可以了；所以Retrofit的解析工作在okHttp的Call返回结果时，在其okHttp的Callback中进行解析，解析过程也较为简单，通过获取返回类型Returntype，然后使用gson进行解析即可；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ArrayMapy、SparseArray源码学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/06/ArrayMapy、SparseArray源码学习/" class="article-date">
      <time datetime="2016-05-06T08:39:33.378Z" itemprop="datePublished">2016-05-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/06/ArrayMapy、SparseArray源码学习/">ArrayMapy、SparseArray源码学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>ArrayMap和SparseArray是Android中提供用来替代HashMap实现内存优化的集合类，来具体看下其源码实现：</p>
<h1 id="ArrayMap简单分析"><a href="#ArrayMap简单分析" class="headerlink" title="ArrayMap简单分析"></a>ArrayMap简单分析</h1><h2 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a>存储原理</h2><p>HashMap是使用一个table数组来存储；发生冲突时采用链地址法以链表或者红黑树的形式进行存储；<br>而ArrayMap使用的是两个数组，mHash数组用来存储hash值（顺序存储）；mArray在对应位置存储（比如mHash存储位置为index），偶数位（index&lt;&lt;1）存储key;奇数位(index&lt;&lt;+1)存储value;<br>发生冲突时，mHash把相同的hash组放在一起存储（因为mHash是按照hash值大小顺序来存储的）；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] mHashes;</span><br><span class="line">    Object[] mArray;</span><br><span class="line">    <span class="keyword">int</span> mSize;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayMap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">            mHashes = EmptyArray.INT;</span><br><span class="line">            mArray = EmptyArray.OBJECT;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            allocArrays(capacity);</span><br><span class="line">        &#125;</span><br><span class="line">        mSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加元素put操作"><a href="#添加元素put操作" class="headerlink" title="添加元素put操作"></a>添加元素put操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        hash = <span class="number">0</span>;</span><br><span class="line">        index = indexOfNull();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 根据hash值查找key对应的位置</span></span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = indexOf(key, hash);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 大于0表示该元素已经存在，这里直接覆盖即可</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        index = (index&lt;&lt;<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> V old = (V)mArray[index];</span><br><span class="line">        mArray[index] = value;</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;0表示不存在，取反得到插入位置</span></span><br><span class="line">    index = ~index;</span><br><span class="line">    <span class="comment">// 插入前判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (mSize &gt;= mHashes.length) &#123;</span><br><span class="line">        <span class="comment">// 重新分配空间大小</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = mSize &gt;= (BASE_SIZE*<span class="number">2</span>) ? (mSize+(mSize&gt;&gt;<span class="number">1</span>))</span><br><span class="line">                : (mSize &gt;= BASE_SIZE ? (BASE_SIZE*<span class="number">2</span>) : BASE_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] ohashes = mHashes;</span><br><span class="line">        <span class="keyword">final</span> Object[] oarray = mArray;</span><br><span class="line">        <span class="comment">// 分配数组空间</span></span><br><span class="line">        allocArrays(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原始数组拷贝到新分配的数组中</span></span><br><span class="line">        <span class="keyword">if</span> (mHashes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"put: copy 0-"</span> + mSize + <span class="string">" to 0"</span>);</span><br><span class="line">            System.arraycopy(ohashes, <span class="number">0</span>, mHashes, <span class="number">0</span>, ohashes.length);</span><br><span class="line">            System.arraycopy(oarray, <span class="number">0</span>, mArray, <span class="number">0</span>, oarray.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的空间</span></span><br><span class="line">        freeArrays(ohashes, oarray, mSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单的插入操作</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; mSize) &#123;</span><br><span class="line">        System.arraycopy(mHashes, index, mHashes, index + <span class="number">1</span>, mSize - index);</span><br><span class="line">        System.arraycopy(mArray, index &lt;&lt; <span class="number">1</span>, mArray, (index + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>, (mSize - index) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应位置进行赋值</span></span><br><span class="line">    mHashes[index] = hash;</span><br><span class="line">    mArray[index&lt;&lt;<span class="number">1</span>] = key;</span><br><span class="line">    mArray[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] = value;</span><br><span class="line">    mSize++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>查找插入位置：</strong><br>HashMap是根据key的hashcode，然后将其高低十六位相与hash&amp;（hash&gt;&gt;&gt;16）,进而与table数组的长度length相与（hash&amp;(length-1)）来找到对应的table数组插入位置；<br>而ArrayMap是通过ContainerHelpers的binarySearch即二分查找的方法，根据key的hash值来查找mHash数组（顺序数组），找到对应的index；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分法查找对应位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object key, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = mSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Important fast case: if nothing is in here, nothing to look for.</span></span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ~<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找，查找结果</span></span><br><span class="line">    <span class="keyword">int</span> index = ContainerHelpers.binarySearch(mHashes, N, hash);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the hash code wasn't found, then we have no entry for this key.</span></span><br><span class="line">    <span class="comment">// &lt;0表示没有查找到</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决冲突，双向进行查找一次相同的hash值，比较key值是否匹配</span></span><br><span class="line">    <span class="comment">// If the key at the returned index matches, that's what we want.</span></span><br><span class="line">    <span class="keyword">if</span> (key.equals(mArray[index&lt;&lt;<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search for a matching key after the index.</span></span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">for</span> (end = index + <span class="number">1</span>; end &lt; N &amp;&amp; mHashes[end] == hash; end++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.equals(mArray[end &lt;&lt; <span class="number">1</span>])) <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search for a matching key before the index.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; mHashes[i] == hash; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.equals(mArray[i &lt;&lt; <span class="number">1</span>])) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Key not found -- return negative value indicating where a</span></span><br><span class="line">    <span class="comment">// new entry for this key should go.  We use the end of the</span></span><br><span class="line">    <span class="comment">// hash chain to reduce the number of array entries that will</span></span><br><span class="line">    <span class="comment">// need to be copied when inserting.</span></span><br><span class="line">    <span class="keyword">return</span> ~end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>简单的二分查找：</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is Arrays.binarySearch(), but doesn't do any argument validation.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> size, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> midVal = array[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (midVal &lt; value) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; value) &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;  <span class="comment">// value found</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ~lo;  <span class="comment">// value not present</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>冲突解决：</strong><br>HashMap是采用遍历链表来实现；而ArrayMap的mHash表中可能存在多个相同的hash值，即冲突；它通过二分查找，找到相应的一个相等值，然后以这个值为中心，分别向前向后遍历，比较对应的key值是否相等；</p>
<p><strong>继续看前面的put过程：</strong><br>未找到情况：当没有找到对应的hash值，或者相同的hash，但没有找到相等的key的情况，这个时候，查找结果index表示待插入的位置，未找到返回index的取反（~index）;便于插入操作判断是进行插入还是重写；</p>
<p><strong>覆盖操作：</strong><br>如果index&gt;=0表示当期key值已存在，则需要进行覆盖，将mArray[(index&lt;&lt;1) + 1]即value赋值为新的value值，然后返回old value值；<br>如果index&lt;0，表示需要执行插入操作，~index即为新元素要插入的位置；</p>
<p><strong>扩充容量：</strong><br>再插入之前，首先判断当前存储空间是否足够，HashMap的扩容时机是总空间超过容量<em>状态因子时，而ArrayMap是当mHash的大小超过MAX_SIZE，即进行扩容，扩容的算法为：<br>n = mSize &gt;= (BASE_SIZE</em>2) ? (mSize+(mSize&gt;&gt;1))<br>        : (mSize &gt;= BASE_SIZE ? (BASE_SIZE*2) : BASE_SIZE);<br>BASE_SIZE=4;即容量大于8的时候，扩容1.5倍；容量大于4小于8时，直接分配空间为8；否则分配空间为4；<br>扩充容量的操作和ArrayList差不多，都是操作数组进行复制。注意这里mHash和mArray都要复制；</p>
<p><strong>插入操作：</strong><br>插入操作也是简单的数组已知index进行插入问题，简单的arraycopy；</p>
<h2 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h2><p>较为简单，通过mHash数组获取存储位置，&lt;0表示没有找到，否则返回value值即可；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = indexOfKey(key);</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> ? (V)mArray[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="remove操作"><a href="#remove操作" class="headerlink" title="remove操作"></a>remove操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找对应的index进行remove</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = indexOfKey(key);</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> removeAt(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Remove the key/value mapping at the given index.</span><br><span class="line"> * <span class="doctag">@param</span> index The desired index, must be between 0 and &#123;<span class="doctag">@link</span> #size()&#125;-1.</span><br><span class="line"> * <span class="doctag">@return</span> Returns the value that was stored at this index.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object old = mArray[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (mSize &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Now empty.</span></span><br><span class="line">        <span class="comment">// 删除之后数组中元素就为空了，所以进行空间释放</span></span><br><span class="line">        freeArrays(mHashes, mArray, mSize);</span><br><span class="line">        mHashes = EmptyArray.INT;</span><br><span class="line">        mArray = EmptyArray.OBJECT;</span><br><span class="line">        mSize = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果空余空间过多，将要收缩空间</span></span><br><span class="line">        <span class="keyword">if</span> (mHashes.length &gt; (BASE_SIZE*<span class="number">2</span>) &amp;&amp; mSize &lt; mHashes.length/<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// Shrunk enough to reduce size of arrays.  We don't allow it to</span></span><br><span class="line">            <span class="comment">// shrink smaller than (BASE_SIZE*2) to avoid flapping between</span></span><br><span class="line">            <span class="comment">// that and BASE_SIZE.</span></span><br><span class="line">            <span class="comment">// 收缩空间大小</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> n = mSize &gt; (BASE_SIZE*<span class="number">2</span>) ? (mSize + (mSize&gt;&gt;<span class="number">1</span>)) : (BASE_SIZE*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] ohashes = mHashes;</span><br><span class="line">            <span class="keyword">final</span> Object[] oarray = mArray;</span><br><span class="line">            allocArrays(n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 简单的数组元素删除操作</span></span><br><span class="line">            mSize--;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"remove: copy from 0-"</span> + index + <span class="string">" to 0"</span>);</span><br><span class="line">                System.arraycopy(ohashes, <span class="number">0</span>, mHashes, <span class="number">0</span>, index);</span><br><span class="line">                System.arraycopy(oarray, <span class="number">0</span>, mArray, <span class="number">0</span>, index &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; mSize) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"remove: copy from "</span> + (index+<span class="number">1</span>) + <span class="string">"-"</span> + mSize</span><br><span class="line">                        + <span class="string">" to "</span> + index);</span><br><span class="line">                System.arraycopy(ohashes, index + <span class="number">1</span>, mHashes, index, mSize - index);</span><br><span class="line">                System.arraycopy(oarray, (index + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>, mArray, index &lt;&lt; <span class="number">1</span>,</span><br><span class="line">                        (mSize - index) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mSize--;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; mSize) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"remove: move "</span> + (index+<span class="number">1</span>) + <span class="string">"-"</span> + mSize</span><br><span class="line">                        + <span class="string">" to "</span> + index);</span><br><span class="line">                System.arraycopy(mHashes, index + <span class="number">1</span>, mHashes, index, mSize - index);</span><br><span class="line">                System.arraycopy(mArray, (index + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>, mArray, index &lt;&lt; <span class="number">1</span>,</span><br><span class="line">                        (mSize - index) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mArray[mSize &lt;&lt; <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">            mArray[(mSize &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (V)old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayMap的remove操作，除了将元素从数组指定位置删除之外；当数组的空余空间过多时，还需要对空间进行紧缩。<br>紧缩的时机是mHashes.length &gt; (BASE_SIZE*2) &amp;&amp; mSize &lt; mHashes.length/3；<br>即mHash数组的容量大于8，并且当前存储的元素不足总空间的三分之一，则进行紧缩，来节省内存使用。</p>
<h1 id="SparseArray简单分析："><a href="#SparseArray简单分析：" class="headerlink" title="SparseArray简单分析："></a>SparseArray简单分析：</h1><p>SparseArray是用来替代HashpMap<integer,xxx>的，即key的类型为Integer，ArrayMap避免了int的自动装箱操作，和ArrayMap的原理大致相同，也是使用了两个数组mKeys、mValues来分别存储key值和value值。避免了对int类型的key再进行Hash。<br>同样查找元素的操作也是通过二分法，基本原理和ArrayMap大致相同；这里有个区别是，当删除元素时，并不立即将对应key删除，然后占一个空位便于以后今后复用；当空间紧张时，再进行统一删除，避免了频繁的数组移动操作；<br><strong>1）put操作：</strong></integer,xxx></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 二分查找位置</span></span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到对应元素</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mValues[i] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = ~i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里是进行复用之前已经删过的元素</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class="line">            mKeys[i] = key;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果数组空间不够继续存储时，对原数组进行GC</span></span><br><span class="line">        <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">            gc();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Search again because indices may have changed.</span></span><br><span class="line">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行插入操作</span></span><br><span class="line">        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</span><br><span class="line">        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">        mSize++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到和ArrayMap基本相同，也是通过二分查找找到对应的存储位置，然后执行插入，只不过这里多个一个删除元素复用的情况；来看一下删除的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    delete(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mValues[i] != DELETED) &#123;</span><br><span class="line">            mValues[i] = DELETED;</span><br><span class="line">            mGarbage = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Removes the mapping at the specified index.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mValues[index] != DELETED) &#123;</span><br><span class="line">        mValues[index] = DELETED;</span><br><span class="line">        mGarbage = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到删除逻辑中只是将要删除的元素的value值设置成了一个DELETE的空对象，并未进行移位删除操作；它的移位删除操作统一放在了put里面数组空间不够用时进行的gc函数中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Log.e("SparseArray", "gc start with " + mSize);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = mSize;</span><br><span class="line">    <span class="keyword">int</span> o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] keys = mKeys;</span><br><span class="line">    Object[] values = mValues;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Object val = values[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val != DELETED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != o) &#123;</span><br><span class="line">                keys[o] = keys[i];</span><br><span class="line">                values[o] = val;</span><br><span class="line">                values[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            o++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mGarbage = <span class="keyword">false</span>;</span><br><span class="line">    mSize = o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Log.e("SparseArray", "gc end with " + mSize);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的数组紧缩操作，从前往后扫描，将非DELETE元素通过交换紧缩到前面空间中来；</p>
<p>因此综上来看，ArrayMap和SparseMap都是通过数组来实现的，一个数组存储hash值（key值），用以通过二分查找查找key对应的存储位置；相对于HashMap的查询效率O(1)而言，ArrayMap和 SparseMap的查询效率O(lgn)并不出色，而且涉及到大量的数组移位操作；但是ArrayMap和 SparseMap最大的好处是节省空间，而且提供了良好的及时进行空间紧缩，特别适合Android这些内存空间比较紧张的开发环境。而SparseMap是对应HashMap特殊情况的优化，在key为Integer时，避免了装箱操作。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016 流云易采
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8">
  
  <title>Liuyunyicai</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Liuyunyicai">
<meta property="og:url" content="http://liuyunyicai.github.io/index.html">
<meta property="og:site_name" content="Liuyunyicai">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Liuyunyicai">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Liuyunyicai" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
      <link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet">
  
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
      <style> .article { opacity: 0;} </style>
  
  <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/clipboard.js/1.5.9/clipboard.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
          fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
          scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.0.9/scrollreveal.min.js"
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/liuyunyicai.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">流云易采</a></h1>
        </hgroup>

        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">文章列表</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/979724798@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" target="_blank" href="http://blog.csdn.net/woliuyunyicai" title="CSDN"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">Android,Java</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">流云易采</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/liuyunyicai.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">流云易采</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">文章列表</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/979724798@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa CSDN" target="_blank" href="http://blog.csdn.net/woliuyunyicai" title="CSDN"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-View机制深入学习（五） 事件处理机制一" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/10/View机制深入学习（五） 事件处理机制一/" class="article-date">
      <time datetime="2016-05-10T09:28:45.538Z" itemprop="datePublished">2016-05-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/10/View机制深入学习（五） 事件处理机制一/">View机制深入学习（五） 事件处理机制一</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>以TouchEvent为主，看一下View和ViewGroup内部是如何处理Input Events的；<br>首先来看事件的产生来源：</p>
<p>#一、获取事件:</p>
<p>事件的来源可以分为“软件”，“硬件”两种；<br>主要的事件包含有：<br><strong>按键事件（KeyEvent）</strong>    :即物理按键按下产生的事件，相关的常用物理按键一般有HOME,BACK等<br><strong>触摸事件（TouchEvent）</strong>:<br>鼠标事件（MouseEvent）、轨迹球事件（TrackBallEvent）（这两个已经不常见）；</p>
<p>针对所有事件的共性抽象出了InputEvent接口；其有两个子类：KeyEvent,MotionEvent;</p>
<h2 id="1、事件的投递流程："><a href="#1、事件的投递流程：" class="headerlink" title="1、事件的投递流程："></a>1、事件的投递流程：</h2><p><img src="http://chuantu.biz/t4/12/1462870025x3738746571.png" alt="enter image description here"></p>
<p><strong>1&gt;源信息采集</strong><br>    对“硬件源”产生的原始信息进行收集；它需要Linux内核驱动的支持，Android系统通过/dev/input下的节点来访问当前发生的事件。<br><strong>2&gt;前期处理</strong><br>    对收集到信息进行筛选以及格式转化<br><strong>3&gt;WMS分配</strong><br>    WMS是窗口的Manager，同时也是InputEvent的派发者。<br><strong>4&gt;应用程序处理</strong><br>    WMS会先把事件传递到对应ViewRootImpl，ViewRootImpl分发事件，传递给相应的DecorView,DecorView在调用Activity中的Window.Callback将事件传递给Activity；然后Activity在通过dispatchTouchEvent分发事件，下面就来到熟悉的View事件分发机制；具体见<a href="http://blog.csdn.net/woliuyunyicai/article/details/49866177" target="_blank" rel="external">《View机制深入学习（四）View的事件分发机制》</a></p>
<h2 id="2、InputManagerService启动"><a href="#2、InputManagerService启动" class="headerlink" title="2、InputManagerService启动:"></a>2、InputManagerService启动:</h2><p>InputManagerService同样也是有SystemServer进程启动，这个在<a href="http://blog.csdn.net/woliuyunyicai/article/details/47749009" target="_blank" rel="external">Android启动过程——init.rc,Zygote,SystemServer</a>中已经提到过，<br>系统启动后创建init进程（pid=1）,init进程创建出Zygote进程，然后Zygote进程孵化出SystemServer进程，在SystemServer进程中创建IMS：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@path</span>: \frameworks\base\services\java\com\android\server\SystemServer.java */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以看到IMS和WMS是紧密相关的</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// @value InputManagerService inputManager</span></span><br><span class="line">        inputManager = <span class="keyword">new</span> InputManagerService(context, wmHandler);</span><br><span class="line"></span><br><span class="line">        Slog.i(TAG, <span class="string">"Window Manager"</span>);</span><br><span class="line">        <span class="comment">// @value WindowManagerService wm</span></span><br><span class="line">        wm = WindowManagerService.main(context, power, display, inputManager,</span><br><span class="line">                uiHandler, wmHandler,</span><br><span class="line">                factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">                !firstBoot, onlyCore);</span><br><span class="line">        ServiceManager.addService(Context.WINDOW_SERVICE, wm);</span><br><span class="line">        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);</span><br><span class="line"></span><br><span class="line">        ActivityManagerService.self().setWindowManager(wm);</span><br><span class="line"></span><br><span class="line">        inputManager.setWindowManagerCallbacks(wm.getInputMonitor());</span><br><span class="line">        inputManager.start();</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、InputMangerService："><a href="#3、InputMangerService：" class="headerlink" title="3、InputMangerService："></a>3、InputMangerService：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\java\com\android\server\input\InputManagerService.java **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputManagerService</span> <span class="keyword">extends</span> <span class="title">IInputManager</span>.<span class="title">Stub</span> <span class="keyword">implements</span> <span class="title">Watchdog</span>.<span class="title">Monitor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指向native端IMS类对象的地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> mPtr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputManagerService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">        <span class="keyword">this</span>.mHandler = <span class="keyword">new</span> InputManagerHandler(DisplayThread.get().getLooper());</span><br><span class="line"></span><br><span class="line">        mUseDevInputEventForAudioJack = context.getResources().getBoolean(R.bool.config_useDevInputEventForAudioJack);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建native IMS对象</span></span><br><span class="line">        mPtr = nativeInit(<span class="keyword">this</span>, mContext, mHandler.getLooper().getQueue());</span><br><span class="line"></span><br><span class="line">        LocalServices.addService(InputManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到Java层的IMS实际上只是对Native层的InputManager的一层包装；其创建主要是native层进行创建，并把native层的InputManager地址赋值给InputManagerService的mPtr变量；<br>而且注意nativeInit中传入了Looper中的MessageQueue变量；</p>
<h2 id="4、native层的InputManagerService——NativeInputManager类："><a href="#4、native层的InputManagerService——NativeInputManager类：" class="headerlink" title="4、native层的InputManagerService——NativeInputManager类："></a>4、native层的InputManagerService——NativeInputManager类：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span></span><br><span class="line"><span class="keyword">class</span> NativeInputManager : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase,</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> InputReaderPolicyInterface,</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> InputDispatcherPolicyInterface,</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> PointerControllerPolicyInterface</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz,</span><br><span class="line">                        jobject serviceObj, jobject contextObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个Message Queue</span></span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"MessageQueue is not initialized."</span>);</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以看到NativeInputManager中包含有一个Looper，用以进行事件分派</span></span><br><span class="line">    NativeInputManager* im = new NativeInputManager(contextObj, serviceObj,</span><br><span class="line">            messageQueue-&gt;getLooper());</span><br><span class="line">    im-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 返回创建的IMS实例对象的地址（强制转化为long类型）</span></span><br><span class="line">    return <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(im);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到首先通过android_os_MessageQueue_getMessageQueue函数获取到本地端的MessageQueue，这个在Handler机制中的本地解析<a href="http://blog.csdn.net/woliuyunyicai/article/details/50780529" target="_blank" rel="external">《Handler机制深入解析》</a>中已经提到，该NativeMessageQueue对象在java层创建Looper时创建实例，然后将地址指针赋值为Looper对应的MessageQueue中的ptr变量中，这里根据指针来获取该NativeMessageQueue对象；<br>根据NativeMessageQueue对象获取其中对应的Looper（native），用以创建NativeInputManger;来看NativeInputManager的构造函数：</p>
<h2 id="5、NativeInputManager-NativeInputManager"><a href="#5、NativeInputManager-NativeInputManager" class="headerlink" title="5、NativeInputManager#NativeInputManager:"></a>5、NativeInputManager#NativeInputManager:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span></span><br><span class="line">NativeInputManager::NativeInputManager(jobject contextObj,</span><br><span class="line">                                       jobject serviceObj, <span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper) :</span><br><span class="line">        mLooper(looper), mInteractive(<span class="literal">true</span>) &#123;</span><br><span class="line">    JNIEnv* env = jniEnv();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局引用</span></span><br><span class="line">    mContextObj = env-&gt;NewGlobalRef(contextObj);</span><br><span class="line">    mServiceObj = env-&gt;NewGlobalRef(serviceObj);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mLocked.systemUiVisibility = ASYSTEM_UI_VISIBILITY_STATUS_BAR_VISIBLE;</span><br><span class="line">        mLocked.pointerSpeed = <span class="number">0</span>;</span><br><span class="line">        mLocked.pointerGesturesEnabled = <span class="literal">true</span>;</span><br><span class="line">        mLocked.showTouches = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建EventHUb</span></span><br><span class="line">    sp&lt;EventHub&gt; eventHub = new EventHub();</span><br><span class="line">    <span class="comment">// 创建InputManager实例</span></span><br><span class="line">    mInputManager = new InputManager(eventHub, this, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NativeInputManager中保存了Looper(native)实例；并且创建了EventHub，以及InputManager两个重要的对象；<br>EventHub从名字就可以看出，它是用来收集以及存储外部的输入事件的；<br>而InputManager则是对Event事件进行处理分发；<br>先来看EventHub：</p>
<h3 id="（一）EventHub："><a href="#（一）EventHub：" class="headerlink" title="（一）EventHub："></a>（一）EventHub：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*\frameworks\native\services\inputflinger\EventHub*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *DEVICE_PATH = <span class="string">"/dev/input"</span>;</span><br><span class="line">EventHub::EventHub(<span class="keyword">void</span>) :</span><br><span class="line">        mBuiltInKeyboardId(NO_BUILT_IN_KEYBOARD), mNextDeviceId(<span class="number">1</span>), mControllerNumbers(),</span><br><span class="line">        mOpeningDevices(<span class="number">0</span>), mClosingDevices(<span class="number">0</span>),</span><br><span class="line">        mNeedToSendFinishedDeviceScan(<span class="literal">false</span>),</span><br><span class="line">        mNeedToReopenDevices(<span class="literal">false</span>), mNeedToScanDevices(<span class="literal">true</span>),</span><br><span class="line">        mPendingEventCount(<span class="number">0</span>), mPendingEventIndex(<span class="number">0</span>), mPendingINotify(<span class="literal">false</span>) &#123;</span><br><span class="line">    acquire_wake_lock(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建epoll对象</span></span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用inotify机制监听文件或目录的移动、读取、写入或删除等事件</span></span><br><span class="line">    <span class="comment">// 创建一个inotify对象</span></span><br><span class="line">    mINotifyFd = inotify_init();</span><br><span class="line">    <span class="comment">// 把监控项添加到mINotifyFd对象的监控列表中</span></span><br><span class="line">    <span class="comment">// 这里监听的文件路径为"/dev/input"</span></span><br><span class="line">    <span class="keyword">int</span> result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> epoll_event eventItem;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(eventItem));</span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_INOTIFY;</span><br><span class="line">    <span class="comment">// 把inotify对象mINotifyFd添加到epoll对象的兴趣列表中，此处采用inotify与epoll机制结合起来检查文件</span></span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> wakeFds[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 创建pipe</span></span><br><span class="line">    result = pipe(wakeFds);</span><br><span class="line"></span><br><span class="line">    mWakeReadPipeFd = wakeFds[<span class="number">0</span>];</span><br><span class="line">    mWakeWritePipeFd = wakeFds[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 设置为非阻塞</span></span><br><span class="line">    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_WAKE;</span><br><span class="line">    <span class="comment">// 添加到epoll的兴趣列表中</span></span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> major, minor;</span><br><span class="line">    getLinuxRelease(&amp;major, &amp;minor);</span><br><span class="line">    <span class="comment">// EPOLLWAKEUP was introduced in kernel 3.5</span></span><br><span class="line">    mUsingEpollWakeup = major &gt; <span class="number">3</span> || (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面进行了一系列的变量的初始化；<br>然后epoll_create创建了一个epoll对象，可以看到和Handler中一样，IMS中也用到了epoll机制进行监听；<br>而后可以看到IMS是INotify机制和Epoll机制同时使用的：inotify_init创建iNotify对象，inotify_add_watch则将”/dev/input”路径添加到监听列表中；当”/dev/input”中文件发生变化，将会产生响应；<br>了解INotifiy文件系统监听机制：<br><a href="https://www.ibm.com/developerworks/cn/linux/l-inotifynew/" target="_blank" rel="external">《inotify – Linux 2.6 内核中的文件系统变化通知机制》</a><br><a href="http://www.infoq.com/cn/articles/inotify-linux-file-system-event-monitoring" target="_blank" rel="external">《Inotify: 高效、实时的Linux文件系统事件监控框架》</a><br>然后将iNotify对象添加到Epoll的兴趣列表中，进行监听；<br>然后同Handler机制，创建一个Pipe，然后设置为非阻塞形式，然后添加到epoll的兴趣列表中；下面就注意在何时调用epoll_wait来开启监听即可；这里仅进行了初始化；</p>
<h3 id="（二）InputManager："><a href="#（二）InputManager：" class="headerlink" title="（二）InputManager："></a>（二）InputManager：</h3><h4 id="1）构造函数："><a href="#1）构造函数：" class="headerlink" title="1）构造函数："></a>1）构造函数：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputManager.cpp **/</span></span><br><span class="line"><span class="keyword">class</span> InputManagerInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    sp&lt;InputReaderInterface&gt; mReader;</span><br><span class="line">    sp&lt;InputReaderThread&gt; mReaderThread;</span><br><span class="line"></span><br><span class="line">    sp&lt;InputDispatcherInterface&gt; mDispatcher;</span><br><span class="line">    sp&lt;InputDispatcherThread&gt; mDispatcherThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    InputManager::InputManager(</span><br><span class="line">            <span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;</span><br><span class="line">        <span class="comment">// 创建InputDispatcher</span></span><br><span class="line">        mDispatcher = new InputDispatcher(dispatcherPolicy);</span><br><span class="line">        <span class="comment">// 创建InputReader</span></span><br><span class="line">        mReader = new InputReader(eventHub, readerPolicy, mDispatcher);</span><br><span class="line">        initialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 进行初始化 **/</span></span><br><span class="line">    <span class="keyword">void</span> InputManager::initialize() &#123;</span><br><span class="line">        <span class="comment">// 创建两个Thread的实例</span></span><br><span class="line">        mReaderThread = new InputReaderThread(mReader);</span><br><span class="line">        mDispatcherThread = new InputDispatcherThread(mDispatcher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>InputManager中传入了前面创建的EventHub对象；然后初始化了两个中重要的类，InputDispatcher，以及InputReader;<br>显然从名字可以看出 InputReader用来读取EventHub中的事件，然后通过InputDiapatcher进行分发（InputReader中持有InputDisptcher的引用）；</p>
<p><strong>先看InputDispatcher:</strong></p>
<h5 id="1-1）InputDispatcher"><a href="#1-1）InputDispatcher" class="headerlink" title="1.1）InputDispatcher:"></a>1.1）InputDispatcher:</h5><p><strong>继承关系：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> InputDispatcher : <span class="keyword">public</span> InputDispatcherInterface</span><br><span class="line"><span class="keyword">class</span> InputDispatcherInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase, <span class="keyword">public</span> InputListenerInterface</span><br></pre></td></tr></table></figure>
<p><strong>构造函数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line">InputDispatcher::InputDispatcher(<span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy) :</span><br><span class="line">    mPolicy(policy),</span><br><span class="line">    mPendingEvent(<span class="literal">NULL</span>), mAppSwitchSawKeyDown(<span class="literal">false</span>), mAppSwitchDueTime(LONG_LONG_MAX),</span><br><span class="line">    mNextUnblockedEvent(<span class="literal">NULL</span>),</span><br><span class="line">    mDispatchEnabled(<span class="literal">false</span>), mDispatchFrozen(<span class="literal">false</span>), mInputFilterEnabled(<span class="literal">false</span>),</span><br><span class="line">    mInputTargetWaitCause(INPUT_TARGET_WAIT_CAUSE_NONE) &#123;</span><br><span class="line">    <span class="comment">// 可以看到这里创建了一个Looper</span></span><br><span class="line">    mLooper = new Looper(false);</span><br><span class="line"></span><br><span class="line">    mKeyRepeatState.lastKeyEntry = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    policy-&gt;getDispatcherConfiguration(&amp;mConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造函数中创建了一个Looper（native），注意这里是新创建了一个Looper对象，和ThreadLocal中该线程中的Looper是没有关系的；<br>再来看InputReader</p>
<h5 id="1-2）InputReader："><a href="#1-2）InputReader：" class="headerlink" title="1.2）InputReader："></a>1.2）InputReader：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> InputReader : <span class="keyword">public</span> InputReaderInterface</span><br><span class="line"><span class="keyword">class</span> InputReaderInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</span><br></pre></td></tr></table></figure>
<p><strong>构造函数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputReader.cpp **/</span></span><br><span class="line">InputReader::InputReader(<span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub, <span class="comment">// 前面提到的创建的EventHub</span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; policy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) :           <span class="comment">// 即传入进来的InputDispatcher</span></span><br><span class="line">        mContext(<span class="keyword">this</span>), mEventHub(eventHub), mPolicy(policy),   <span class="comment">// 一系列初始化</span></span><br><span class="line">        mGlobalMetaState(<span class="number">0</span>), mGeneration(<span class="number">1</span>),</span><br><span class="line">        mDisableVirtualKeysTimeout(LLONG_MIN), mNextTimeout(LLONG_MAX),</span><br><span class="line">        mConfigurationChangesToRefresh(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个QueuedInputListener对象，赋值给mQueuedListener</span></span><br><span class="line">    mQueuedListener = new QueuedInputListener(listener);</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        refreshConfigurationLocked(<span class="number">0</span>);</span><br><span class="line">        updateGlobalMetaStateLocked();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InputReader中包含了前面创建的EventHub，以及用以分发事件的InputDispatcher;在InputReader内部，将其封装成了QueuedInputListener类；</p>
<p>继续InputManager构造函数中内容，initialize进行初始化：</p>
<h4 id="2）InputManager-initialize"><a href="#2）InputManager-initialize" class="headerlink" title="2）InputManager#initialize:"></a>2）InputManager#initialize:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 进行初始化 **/</span></span><br><span class="line"><span class="keyword">void</span> InputManager::initialize() &#123;</span><br><span class="line"><span class="comment">// 创建两个Thread的实例</span></span><br><span class="line">mReaderThread = new InputReaderThread(mReader);</span><br><span class="line">    mDispatcherThread = new InputDispatcherThread(mDispatcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新创建了两个对象，这两个类都是继承Thread的，即对应地使用InputReader，以及InputDispatcher为参数创建了两个线程；<br>分别来看：</p>
<h5 id="2-1-gt-InputReaderThread："><a href="#2-1-gt-InputReaderThread：" class="headerlink" title="2.1&gt; InputReaderThread："></a>2.1&gt; InputReaderThread：</h5><p><strong>2.1.1）InputReaderThread类：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputReader.h **/</span></span><br><span class="line"><span class="comment">/** 无限循环从event hub中读取event,然后读取processes他们  */</span></span><br><span class="line"><span class="keyword">class</span> InputReaderThread : <span class="keyword">public</span> Thread &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    InputReaderThread(<span class="keyword">const</span> sp&lt;InputReaderInterface&gt;&amp; reader);</span><br><span class="line">    <span class="keyword">virtual</span> ~InputReaderThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    sp&lt;InputReaderInterface&gt; mReader;</span><br><span class="line">    <span class="comment">/** 继承Thread的子类必须实现该函数，因为这个其实是Thread的真正执行函数 **/</span></span><br><span class="line">    <span class="comment">// Derived class must implement threadLoop(). The thread starts its life</span></span><br><span class="line">    <span class="comment">// here. There are two ways of using the Thread object:</span></span><br><span class="line">    <span class="comment">// 1) loop: if threadLoop() returns true, it will be called again if</span></span><br><span class="line">    <span class="comment">//          requestExit() wasn't called.</span></span><br><span class="line">    <span class="comment">// 2) once: if threadLoop() returns false, the thread will exit upon return.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到InputReaderThread是一个Thread类，它的线程函数入口为threadLoop;</p>
<p><strong>2.1.2）InputReaderThread类构造函数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputReader.cpp **/</span></span><br><span class="line">    InputReaderThread::InputReaderThread(<span class="keyword">const</span> sp&lt;InputReaderInterface&gt;&amp; reader) :</span><br><span class="line">    Thread(<span class="comment">/*canCallJava*/</span><span class="literal">true</span>), mReader(reader) &#123;</span><br><span class="line">        <span class="comment">// 这里初始化重要变量sp&lt;InputReaderInterface&gt; mReader</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> InputReaderThread::threadLoop() &#123;</span><br><span class="line">        <span class="comment">// 调用mReader中的loopOnce函数，可以看出InputReaderInterface是该类的核心</span></span><br><span class="line">        mReader-&gt;loopOnce();</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>InputReaderThread的核心逻辑为调用InputReader的loopOnce函数；暂且停在这里，因为Thread只是创建，并未运行，等分析到具体运行代码时再作分析；</p>
<h5 id="2-2-gt-InputDispatcherThread"><a href="#2-2-gt-InputDispatcherThread" class="headerlink" title="2.2&gt;InputDispatcherThread"></a>2.2&gt;InputDispatcherThread</h5><p>/<strong> \frameworks\native\services\inputflinger\InputDispatcher.h </strong>/</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> InputDispatcherThread : <span class="keyword">public</span> Thread &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">InputDispatcherThread</span><span class="params">(<span class="keyword">const</span> sp&lt;InputDispatcherInterface&gt;&amp; dispatcher)</span></span>;</span><br><span class="line">    ~InputDispatcherThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">boolthreadLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    sp&lt;InputDispatcherInterface&gt; mDispatcher;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> InputDispatcherThread::threadLoop() &#123;</span><br><span class="line">    mDispatcher-&gt;dispatchOnce();</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 该类同样是一个Thread，其主要运行逻辑即调用InputDispatcher中的dispatchOnce函数；</p>
<p>回到InputManagerService在SystemServer进程中的创建过程知道，接下来创建WindowManagerService，然后将InputManagerService实例传递给WMS，然后调用InputManagerService.start开始工作。</p>
<h2 id="7、InputManagerService-start"><a href="#7、InputManagerService-start" class="headerlink" title="7、InputManagerService#start:"></a>7、InputManagerService#start:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\java\com\android\server\input\InputManagerService.java **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    nativeStart(mPtr);</span><br><span class="line">    <span class="comment">// Add ourself to the Watchdog monitors.</span></span><br><span class="line">    Watchdog.getInstance().addMonitor(<span class="keyword">this</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以看到start仅是对nativeStart本地方法进行封装，继续通过JNI来调用本地端的start函数；注意这里创建了WatchDog看门狗线程，并且把InputManagerService实例添加到WatchDog的监听；系统创建看门狗线程，每隔一段时间向管道中写入数据唤醒InputReader线程（后面会提到）去读取事件，看门狗WatchDog实际上也是一个线程，只不过会定时发送消息给InputReader线程读取输入事件。</p>
<h2 id="8、NativeInputManager-nativeStart"><a href="#8、NativeInputManager-nativeStart" class="headerlink" title="8、NativeInputManager#nativeStart:"></a>8、NativeInputManager#nativeStart:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ptr为创建的IMS实例的地址，这里将其强制转化成为NativeInputManager类</span></span><br><span class="line">    NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里进一步调用InputManager的star方法</span></span><br><span class="line">    <span class="keyword">status_t</span> result = im-&gt;getInputManager()-&gt;start();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Input manager could not be started."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @value sp&lt;InputManager&gt; mInputManager;</span></span><br><span class="line"><span class="keyword">inline</span> sp&lt;InputManager&gt; getInputManager() <span class="keyword">const</span> &#123; return mInputManager; &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里进一步调用了InputManager的start方法；IMS在Native层的主要实现实体其实是InputManager。</p>
<h2 id="9、InputManager-start："><a href="#9、InputManager-start：" class="headerlink" title="9、InputManager#start："></a>9、InputManager#start：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputManager.cpp **/</span></span><br><span class="line"><span class="keyword">class</span> InputManagerInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    sp&lt;InputReaderInterface&gt; mReader;</span><br><span class="line">    sp&lt;InputReaderThread&gt; mReaderThread;</span><br><span class="line"></span><br><span class="line">    sp&lt;InputDispatcherInterface&gt; mDispatcher;</span><br><span class="line">    sp&lt;InputDispatcherThread&gt; mDispatcherThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start函数</span></span><br><span class="line">    <span class="keyword">status_t</span> InputManager::start() &#123;</span><br><span class="line">        <span class="comment">// 可以看到这里会开启两个线程mDispatcherThread，与mReaderThread</span></span><br><span class="line">        <span class="comment">// 分别对应InputReaderThread，InputDispatcherThread</span></span><br><span class="line">        <span class="keyword">status_t</span> result = mDispatcherThread-&gt;run(<span class="string">"InputDispatcher"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">        ......</span><br><span class="line">        result = mReaderThread-&gt;run(<span class="string">"InputReader"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            mDispatcherThread-&gt;requestExit();</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        return OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  回到InputManager中来，来看start函数中所做的工作，在start中调用两个thread的run函数正是开启线程；由Thread的线程入口为threadLoop；前面已经提到了这两个Thread的入口函数，这里来看其中的具体工作逻辑；</p>
<h2 id="10、InputDispatcherThread-amp-InputReaderThread"><a href="#10、InputDispatcherThread-amp-InputReaderThread" class="headerlink" title="10、InputDispatcherThread&amp;InputReaderThread"></a>10、InputDispatcherThread&amp;InputReaderThread</h2><p><strong>InputDispatcherThread#threadLoop:</strong><br>由前面知InputDispatcherThread中主要通过调用InputDispatcher的dispathOnce来实现的；</p>
<h3 id="1）InputDispatcher-dispatchOnce"><a href="#1）InputDispatcher-dispatchOnce" class="headerlink" title="1）InputDispatcher::dispatchOnce:"></a>1）InputDispatcher::dispatchOnce:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mDispatcherIsAliveCondition.broadcast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在没有等待的commands事运行一个dispatch loop，这个loop之后可能enqueue commands</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有等待的commands的话，就运行所有的commands</span></span><br><span class="line">        <span class="comment">// If any commands were run then force the next poll to wake up immediately.</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始状态下是没有事件的，来到mLooper-&gt;pollOnce，了解Handler机制的native层知道，在pollOnce中调用epoll_wait对前面设置的兴趣事件进行监听，然后InputDispatchThread进入休眠等待唤醒；可想而知下面策略是InputReaderThread来对其进行唤醒；</p>
<p><strong>InputReaderThread#threadLoop:</strong><br>InputReaderThread中的主要逻辑是调用InputReader中的loopOnce函数</p>
<h3 id="1）InputReader-loopOnce"><a href="#1）InputReader-loopOnce" class="headerlink" title="1）InputReader#loopOnce :"></a>1）InputReader#loopOnce :</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** \frameworks\native\services\inputflinger\InputReader.h **/</span></span><br><span class="line">    <span class="keyword">class</span> InputReaderInterface : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</span><br><span class="line">    <span class="keyword">class</span> InputReader : <span class="keyword">public</span> InputReaderInterface</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** \frameworks\native\services\inputflinger\InputReader.cpp **/</span></span><br><span class="line"><span class="comment">// loopOnce即事件处理函数</span></span><br><span class="line">    <span class="keyword">void</span> InputReader::loopOnce() &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 其实是通过mEventHub来获取Events的</span></span><br><span class="line">        <span class="comment">// @value sp&lt;EventHubInterface&gt; mEventHub;</span></span><br><span class="line">        <span class="keyword">size_t</span> count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// @value sp&lt;QueuedInputListener&gt; mQueuedListener;</span></span><br><span class="line">        mQueuedListener-&gt;flush();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到这里通过EventHub的getEvents来获取/dev/input中的Event事件，然后用到前面提到的封装了InputDispatcher的QueueListener来分发事件；<br>EventHub获取Events的具体流程：<a href="http://www.feeyan.cn/?p=280" target="_blank" rel="external">Android按键事件传递流程(一)</a><br>主要工作流程是注册这些监听的devices，然后调用epoll_wait使得InputReaderThread等待唤醒；<br>获取Events的过于复杂，直接跳过，来看事件的传递；当获取到Event之后，调用mQueuedListener的flush来传递消息；</p>
<h1 id="二、事件分发"><a href="#二、事件分发" class="headerlink" title="二、事件分发"></a>二、事件分发</h1><p>前面提到使用EventHub的getEvents来获取Events之后，通过mQueuedListener的flush开始消息的分发；</p>
<h2 id="1、QueueInputListener-flush"><a href="#1、QueueInputListener-flush" class="headerlink" title="1、QueueInputListener#flush:"></a>1、QueueInputListener#flush:</h2><h3 id="1）先看QueueInputListener的定义："><a href="#1）先看QueueInputListener的定义：" class="headerlink" title="1）先看QueueInputListener的定义："></a>1）先看QueueInputListener的定义：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputListener.h **/</span></span><br><span class="line"><span class="keyword">class</span> QueuedInputListener : <span class="keyword">public</span> InputListenerInterface &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~QueuedInputListener();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    QueuedInputListener(<span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; innerListener);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyConfigurationChanged</span><span class="params">(<span class="keyword">const</span> NotifyConfigurationChangedArgs* args)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyKey</span><span class="params">(<span class="keyword">const</span> NotifyKeyArgs* args)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyMotion</span><span class="params">(<span class="keyword">const</span> NotifyMotionArgs* args)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifySwitch</span><span class="params">(<span class="keyword">const</span> NotifySwitchArgs* args)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyDeviceReset</span><span class="params">(<span class="keyword">const</span> NotifyDeviceResetArgs* args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    sp&lt;InputListenerInterface&gt; mInnerListener;<span class="comment">// mInnerListner即是InputDispatcher</span></span><br><span class="line">    Vector&lt;NotifyArgs*&gt; mArgsQueue; <span class="comment">// 后面flush函数中将会用到</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在InputReader的构造函数中，传递进来的mInnerListener即为InputDispatcher；</p>
<h3 id="2）flush函数："><a href="#2）flush函数：" class="headerlink" title="2）flush函数："></a>2）flush函数：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputListener.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> QueuedInputListener::flush() &#123;</span><br><span class="line">    <span class="keyword">size_t</span> count = mArgsQueue.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        NotifyArgs* args = mArgsQueue[i];</span><br><span class="line">        <span class="comment">// 调用NotifyArgs。notify函数</span></span><br><span class="line">        args-&gt;notify(mInnerListener);</span><br><span class="line">        <span class="keyword">delete</span> args;</span><br><span class="line">    &#125;</span><br><span class="line">    mArgsQueue.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里仅是一个封装函数，最终调用InputListenerInterface的notifyKey函数</span></span><br><span class="line"><span class="keyword">void</span> NotifyKeyArgs::notify(<span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) <span class="keyword">const</span> &#123;</span><br><span class="line">    listener-&gt;notifyKey(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>前面最终调用InputListenerInterface（即InputDispatcher）的notifyKey回调函数；
总结前面的流程即InputReaderThread通过EventHub不断读取获取event信息，获得事件后，调用InputDispather的notifyKey函数来通知InputDispathcer进行处理。注意这里调用InputDispatcher的notifyKey函数依然是在InputReaderThread线程中进行的，此时InputDispathcerThread仍然是epoll_wait阻塞状态中；
</code></pre><h2 id="2、InputDispatcher-notifyKey："><a href="#2、InputDispatcher-notifyKey：" class="headerlink" title="2、InputDispatcher::notifyKey："></a>2、InputDispatcher::notifyKey：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::notifyKey(<span class="keyword">const</span> NotifyKeyArgs* args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!validateKeyEvent(args-&gt;action)) &#123; <span class="comment">// 判断event是否合法</span></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 初始化KeyEvent</span></span><br><span class="line">    KeyEvent event;</span><br><span class="line">    event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action,</span><br><span class="line">                     flags, keyCode, args-&gt;scanCode, metaState, <span class="number">0</span>,</span><br><span class="line">                     args-&gt;downTime, args-&gt;eventTime);</span><br><span class="line">    <span class="keyword">bool</span> needWake;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        mLock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldSendKeyToInputFilterLocked(args)) &#123;</span><br><span class="line">            mLock.unlock();</span><br><span class="line"></span><br><span class="line">            policyFlags |= POLICY_FLAG_FILTERED;</span><br><span class="line">            <span class="keyword">if</span> (!mPolicy-&gt;filterInputEvent(&amp;event, policyFlags)) &#123;</span><br><span class="line">                return; <span class="comment">// event was consumed by the filter</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mLock.lock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> repeatCount = <span class="number">0</span>;</span><br><span class="line">        KeyEntry* newEntry = new KeyEntry(args-&gt;eventTime,</span><br><span class="line">                                          args-&gt;deviceId, args-&gt;source, policyFlags,</span><br><span class="line">                                          args-&gt;action, flags, keyCode, args-&gt;scanCode,</span><br><span class="line">                                          metaState, repeatCount, args-&gt;downTime);</span><br><span class="line"></span><br><span class="line">        needWake = enqueueInboundEventLocked(newEntry);</span><br><span class="line">        mLock.unlock();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒InputDispatcherThread线程</span></span><br><span class="line">    <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">        mLooper-&gt;wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 该部分对传递过来的按键事件进行检查、验证，之后处理特殊按键，将原始按键信息封装成KeyEntry，再调用enqueueInboundEventLocked函数把KeyEntry添加到InboundQueue队列中，最后调用Looper对象的wake往管道中写入字符唤醒InputDispatcherThread线程（类似于Handler机制中的唤醒）；<br>先来看enqueueInboundEventLocked添加事件到InboundQueue队列中：</p>
<h3 id="1）InputDispatcher-enqueueInboundEventLocked："><a href="#1）InputDispatcher-enqueueInboundEventLocked：" class="headerlink" title="1）InputDispatcher::enqueueInboundEventLocked："></a>1）InputDispatcher::enqueueInboundEventLocked：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">bool</span> InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) &#123;</span><br><span class="line">    <span class="comment">// @value Queue&lt;EventEntry&gt; mInboundQueue;</span></span><br><span class="line">    <span class="keyword">bool</span> needWake = mInboundQueue.isEmpty();</span><br><span class="line">    <span class="comment">// 将entry入队列</span></span><br><span class="line">    mInboundQueue.enqueueAtTail(entry);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> (entry-&gt;type) &#123; <span class="comment">// 如前面所述，InputEvent分为KeyEvent和MotionEvent进行分别处理</span></span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_KEY: ......</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_MOTION: .....</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return needWake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将entry添加到InboundQueue队列尾部；然后判断是否需要唤醒，即needWake是否为true；当mInboundQueue不为空，则明显InputDispathcerThread仍处于运行状态来分发事件，因而不用进行唤醒；而当mInboundQueue为空时，测试InputDispatcherThread进行休眠状态，使用wake对其来唤醒；<br>    InputDispatcherThread之前调用Looper的poolOnce函数阻塞休眠，这里调用wake将其唤醒；因为InputDispatcherThread的threadLoop返回值为true，表示该Thread是循环执行的，故继续调用其dispatchOnce函数；</p>
<h2 id="3、InputDispatcher-dispatchOnce"><a href="#3、InputDispatcher-dispatchOnce" class="headerlink" title="3、InputDispatcher::dispatchOnce:"></a>3、InputDispatcher::dispatchOnce:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mDispatcherIsAliveCondition.broadcast();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 在没有等待的commands事运行一个dispatch loop，这个loop之后可能enqueue commands</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果有等待的commands的话，就运行所有的commands</span></span><br><span class="line">        <span class="comment">// If any commands were run then force the next poll to wake up immediately.</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来到dispatchOnceInnerLocked：</p>
<h2 id="4、InputDispathcer-dispatchOnceInnerLocked"><a href="#4、InputDispathcer-dispatchOnceInnerLocked" class="headerlink" title="4、InputDispathcer#dispatchOnceInnerLocked:"></a>4、InputDispathcer#dispatchOnceInnerLocked:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnceInnerLocked(<span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! mPendingEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInboundQueue.isEmpty()) &#123; <span class="comment">// 当前mInboundQueue已经存在元素</span></span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inbound queue has at least one entry.</span></span><br><span class="line">            mPendingEvent = mInboundQueue.dequeueAtHead();</span><br><span class="line">            traceInboundQueueLengthLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now we have an event to dispatch.</span></span><br><span class="line">    <span class="comment">// All events are eventually dequeued and processed this way, even if we intend to drop them.</span></span><br><span class="line">    ALOG_ASSERT(mPendingEvent != <span class="literal">NULL</span>);</span><br><span class="line">    .......</span><br><span class="line">    <span class="comment">// 根据mPendingEvent的Type的不同分别进行处理</span></span><br><span class="line">    <span class="keyword">switch</span> (mPendingEvent-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_CONFIGURATION_CHANGED: &#123;</span><br><span class="line">            ......</span><br><span class="line">            done = dispatchConfigurationChangedLocked(currentTime, typedEntry);</span><br><span class="line">            dropReason = DROP_REASON_NOT_DROPPED; <span class="comment">// configuration changes are never dropped</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// KeyEvent采用dispatchKeyLocked进行处理</span></span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">            KeyEntry* typedEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(mPendingEvent);</span><br><span class="line">            ......</span><br><span class="line">            done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// MotionEvent采用dispatchMotionLocked进行处理</span></span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">            ......</span><br><span class="line">            done = dispatchMotionLocked(currentTime, typedEntry,</span><br><span class="line">                                        &amp;dropReason, nextWakeupTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOG_ASSERT(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dropReason != DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">            dropInboundEventLocked(mPendingEvent, dropReason);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        releasePendingEventLocked();</span><br><span class="line">        *nextWakeupTime = LONG_LONG_MIN;  <span class="comment">// force next poll to wake up immediately</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到是事件处理机制中常用的处理模式，类似于Handler机制，这里先dequeueAtHead使得InBoundQueue事件队列中的事件出队列（FIFO）；然后根据事件的类似进行不同的处理；如TYPE_KEY类型事件采用dispatchKeyLocked；TYPE_MOTION类型事件采用dispatchMotionLocked处理<br> 下面以KeyEvent为例进行分析,下面忽略对event的具体处理细节，具体来看事件是如何传递的；</p>
<h2 id="5、InputDispatcher-dispatchKeyLocked"><a href="#5、InputDispatcher-dispatchKeyLocked" class="headerlink" title="5、InputDispatcher::dispatchKeyLocked:"></a>5、InputDispatcher::dispatchKeyLocked:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">bool</span> InputDispatcher::dispatchKeyLocked(<span class="keyword">nsecs_t</span> currentTime, KeyEntry* entry,</span><br><span class="line">        DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/** 确定事件的接收方（Target） **/</span></span><br><span class="line">    Vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">            entry, inputTargets, nextWakeupTime);</span><br><span class="line"> </span><br><span class="line">    setInjectionResultLocked(entry, injectionResult);</span><br><span class="line">    addMonitoringTargetsLocked(inputTargets);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** 将消息dispatch给Target **/</span></span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面对event的处理细节忽略，重点来看系统是如何查找event对应的接收方（Target）的，这里的InputTarget指定一个输入事件如何被分发到一个特定窗口。该结构体包含了很多特征变量：x,y坐标，输入事件通道InputChannel等；<br>这里通过findFocusedWindowTargetsLocked来确定InputTarget的，然后调用dispatchEventLocked来将Event分发给具体的Target；<br>接下来分析函数findFocusedWindowTargetsLocked；</p>
<h2 id="6、InputDispatcher-findFocusedWindowTargetsLocked"><a href="#6、InputDispatcher-findFocusedWindowTargetsLocked" class="headerlink" title="6、InputDispatcher::findFocusedWindowTargetsLocked:"></a>6、InputDispatcher::findFocusedWindowTargetsLocked:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">int32_t</span> InputDispatcher::findFocusedWindowTargetsLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> EventEntry* entry, Vector&lt;InputTarget&gt;&amp; inputTargets, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult;</span><br><span class="line">    String8 reason;</span><br><span class="line">    <span class="comment">// mFocusedWindowHandle表示当前焦点窗口的句柄</span></span><br><span class="line">    <span class="comment">// @value sp&lt;InputWindowHandle&gt; mFocusedWindowHandle;</span></span><br><span class="line">    <span class="comment">/** 当获得焦点的窗口为null时，会丢弃这一事件 **/</span></span><br><span class="line">    <span class="keyword">if</span> (mFocusedWindowHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFocusedApplicationHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有焦点窗口，但焦点窗口所在的应用程序进程存在，说明该应程序还在启动过程中，故等待nextWakeupTime后再重试</span></span><br><span class="line">            injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                    mFocusedApplicationHandle, NULL, nextWakeupTime,</span><br><span class="line">                    <span class="string">"Waiting because no window has focus but there is a "</span></span><br><span class="line">                    <span class="string">"focused application that may eventually add a window "</span></span><br><span class="line">                    <span class="string">"when it finishes starting up."</span>);</span><br><span class="line">            <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        injectionResult = INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 如果执行到这里说明当前有焦点窗口 **/</span></span><br><span class="line">    <span class="comment">// 先判断权限</span></span><br><span class="line">    <span class="keyword">if</span> (! checkInjectionPermission(mFocusedWindowHandle, entry-&gt;injectionState)) &#123;</span><br><span class="line">        injectionResult = INPUT_EVENT_INJECTION_PERMISSION_DENIED;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前焦点窗口正在处理上一个事件，采取和最上面一样的作法，等待一段时间后重试</span></span><br><span class="line">    reason = checkWindowReadyForMoreInputLocked(currentTime,</span><br><span class="line">            mFocusedWindowHandle, entry, <span class="string">"focused"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!reason.isEmpty()) &#123;</span><br><span class="line">        injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                mFocusedApplicationHandle, mFocusedWindowHandle, nextWakeupTime, reason.string());</span><br><span class="line">        <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功找到匹配的窗口，通过addWindowTargetLocked添加到inputTargets变量中</span></span><br><span class="line">    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;</span><br><span class="line">    addWindowTargetLocked(mFocusedWindowHandle,</span><br><span class="line">            InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS, BitSet32(<span class="number">0</span>),</span><br><span class="line">            inputTargets);</span><br><span class="line"></span><br><span class="line">Failed:</span><br><span class="line">Unresponsive:</span><br><span class="line">    <span class="keyword">nsecs_t</span> timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);</span><br><span class="line">    updateDispatchStatisticsLocked(currentTime, entry,</span><br><span class="line">            injectionResult, timeSpentWaitingForApplication);</span><br><span class="line">    return injectionResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面查找焦点窗口的逻辑很清晰， 当mFocusedWindowHandle为null时，如果mFocusedApplicationHandle不为null，表示当前没有焦点窗口，但焦点窗口所在的应用程序进程存在，说明该应程序还在启动过程中，故等待nextWakeupTime后再重试；如果mFocusedApplicationHandle为null，则丢弃该事件，因为没有能够接收该事件的窗口；<br>    如果mFocusedWindowHandle不为null，先判断当前窗口是否locked，如果是表示正在处理其他输入事件，这时采用和上面相同的策略，等待一段时间后，然后重试。<br>    当找到匹配的目标窗口之后，赋值给InputTarget；先来看InputTarget的定义：</p>
<h2 id="7、InputTarget"><a href="#7、InputTarget" class="headerlink" title="7、InputTarget:"></a>7、InputTarget:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.h **/</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * An input target specifies how an input event is to be dispatched to a particular window</span><br><span class="line"> * including the window's input channel, control flags, a timeout, and an X / Y offset to</span><br><span class="line"> * be added to input event coordinates to compensate for the absolute position of the</span><br><span class="line"> * window area.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> InputTarget &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123; <span class="comment">// 该枚举类列举个关于目标窗口的各种属性值描述</span></span><br><span class="line">        <span class="comment">/* This flag indicates that the event is being delivered to a foreground application. */</span></span><br><span class="line">        FLAG_FOREGROUND = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">// 说明目标窗口是前台应用</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** InputDispatcher与WMS建立关联通信的地方 */</span></span><br><span class="line">    sp&lt;InputChannel&gt; inputChannel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里引出了重要的类InputChannel，InputDispatcher与WMS之间的通信，正是通过InputChannel来实现的。</p>
<p>继续前面的dispatchKeyLocked函数，接下来会调用dispatchEventLocked来传递消息；</p>
<h2 id="8、InputDispatcher-dispatchEventLocked"><a href="#8、InputDispatcher-dispatchEventLocked" class="headerlink" title="8、InputDispatcher#dispatchEventLocked"></a>8、InputDispatcher#dispatchEventLocked</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchEventLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        EventEntry* eventEntry, <span class="keyword">const</span> Vector&lt;InputTarget&gt;&amp; inputTargets) &#123;</span><br><span class="line">    ALOG_ASSERT(eventEntry-&gt;dispatchInProgress); <span class="comment">// should already have been set to true</span></span><br><span class="line"></span><br><span class="line">    pokeUserActivityLocked(eventEntry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputTargets.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> InputTarget&amp; inputTarget = inputTargets.itemAt(i);</span><br><span class="line">        <span class="comment">// 根据inputChannel（其中的fd）来获取对应的Connection</span></span><br><span class="line">        <span class="keyword">ssize_t</span> connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);</span><br><span class="line">        <span class="keyword">if</span> (connectionIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);</span><br><span class="line">            <span class="comment">// 继续向下调用</span></span><br><span class="line">            prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里根据InputChannel的fd值来获取对应的Connection对象，InputChannel以及Connection的相关知识可以西安看第三章；Connection是用来管理InputChannel的变量；然后接着调用 prepareDispatchCycleLocked；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::prepareDispatchCycleLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Split a motion event if needed.</span></span><br><span class="line">    <span class="keyword">if</span> (inputTarget-&gt;flags &amp; InputTarget::FLAG_SPLIT) &#123;</span><br><span class="line">        ALOG_ASSERT(eventEntry-&gt;type == EventEntry::TYPE_MOTION);</span><br><span class="line"></span><br><span class="line">        MotionEntry* originalMotionEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);</span><br><span class="line">        <span class="keyword">if</span> (inputTarget-&gt;pointerIds.count() != originalMotionEntry-&gt;pointerCount) &#123;</span><br><span class="line">            MotionEntry* splitMotionEntry = splitMotionEvent(</span><br><span class="line">                    originalMotionEntry, inputTarget-&gt;pointerIds);</span><br><span class="line">            <span class="keyword">if</span> (!splitMotionEntry) &#123;</span><br><span class="line">                return; <span class="comment">// split event was dropped</span></span><br><span class="line">            &#125;</span><br><span class="line">            enqueueDispatchEntriesLocked(currentTime, connection,</span><br><span class="line">                    splitMotionEntry, inputTarget);</span><br><span class="line">            splitMotionEntry-&gt;release();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not splitting.  Enqueue dispatch entries for the event as is.</span></span><br><span class="line">    enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后接着调用 enqueueDispatchEntriesLocked函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::enqueueDispatchEntriesLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget) &#123;</span><br><span class="line">    <span class="keyword">bool</span> wasEmpty = connection-&gt;outboundQueue.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue dispatch entries for the requested modes.</span></span><br><span class="line">    <span class="comment">// 将dispatch entries入队列</span></span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_OUTSIDE);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_IS);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the outbound queue was previously empty, start the dispatch cycle going.</span></span><br><span class="line">    <span class="comment">// 开始分发事件</span></span><br><span class="line">    <span class="keyword">if</span> (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        startDispatchCycleLocked(currentTime, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enqueueDispatchEntryLocked创建DispatchEntry（按键事件对象），并且把该对象作为一个发送数据包加入到outboundQueue队列中；<br>startDispatchCycleLocked取出outboundQueue队列头元素，赋给dispatchEntry，再取出事件对象KeyEntry，根据事件类型确定case语句分支，如果是按键事件，就调用connection的InputPublisher的publishKeyEvent函数发送到inputchannel中，如果publishKeyEvent返回0，表示按键事件发送成功；<br><strong>InputDispathcer#enqueueDispatchEntryLocked：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::enqueueDispatchEntryLocked(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget,</span><br><span class="line">        <span class="keyword">int32_t</span> dispatchMode) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> inputTargetFlags = inputTarget-&gt;flags;</span><br><span class="line">    <span class="comment">// 如果inputTargetFlags和dispatchMode不匹配</span></span><br><span class="line">    <span class="keyword">if</span> (!(inputTargetFlags &amp; dispatchMode)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    inputTargetFlags = (inputTargetFlags &amp; ~InputTarget::FLAG_DISPATCH_MASK) | dispatchMode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建DispatchEntry</span></span><br><span class="line">    DispatchEntry* dispatchEntry = new DispatchEntry(eventEntry, <span class="comment">// increments ref</span></span><br><span class="line">            inputTargetFlags, inputTarget-&gt;xOffset, inputTarget-&gt;yOffset,</span><br><span class="line">            inputTarget-&gt;scaleFactor);</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue the dispatch entry.</span></span><br><span class="line">    <span class="comment">// 添加到outboundQueue中</span></span><br><span class="line">    connection-&gt;outboundQueue.enqueueAtTail(dispatchEntry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9、InputDispathcer-startDispatchCycleLocked"><a href="#9、InputDispathcer-startDispatchCycleLocked" class="headerlink" title="9、InputDispathcer#startDispatchCycleLocked:"></a>9、InputDispathcer#startDispatchCycleLocked:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::startDispatchCycleLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (connection-&gt;status == Connection::STATUS_NORMAL</span><br><span class="line">            &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 取出outboundQueue的首部元素</span></span><br><span class="line">        DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head;</span><br><span class="line">        dispatchEntry-&gt;deliveryTime = currentTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Publish the event.</span></span><br><span class="line">        <span class="keyword">status_t</span> status;</span><br><span class="line">        EventEntry* eventEntry = dispatchEntry-&gt;eventEntry;</span><br><span class="line">        <span class="comment">// 根据EventEntry的Type类型进行处理</span></span><br><span class="line">        <span class="keyword">switch</span> (eventEntry-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">            KeyEntry* keyEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(eventEntry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Publish the key event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    keyEntry-&gt;deviceId, keyEntry-&gt;source,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags,</span><br><span class="line">                    keyEntry-&gt;keyCode, keyEntry-&gt;scanCode,</span><br><span class="line">                    keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime,</span><br><span class="line">                    keyEntry-&gt;eventTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">            MotionEntry* motionEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);</span><br><span class="line">            ....</span><br><span class="line">            <span class="comment">// Publish the motion event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishMotionEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    motionEntry-&gt;deviceId, motionEntry-&gt;source,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags,</span><br><span class="line">                    motionEntry-&gt;edgeFlags, motionEntry-&gt;metaState, motionEntry-&gt;buttonState,</span><br><span class="line">                    xOffset, yOffset,</span><br><span class="line">                    motionEntry-&gt;xPrecision, motionEntry-&gt;yPrecision,</span><br><span class="line">                    motionEntry-&gt;downTime, motionEntry-&gt;eventTime,</span><br><span class="line">                    motionEntry-&gt;pointerCount, motionEntry-&gt;pointerProperties,</span><br><span class="line">                    usingCoords);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Re-enqueue the event on the wait queue.</span></span><br><span class="line">        <span class="comment">// 事件处理完，将该Entry移除队列</span></span><br><span class="line">        connection-&gt;outboundQueue.dequeue(dispatchEntry);</span><br><span class="line">        traceOutboundQueueLengthLocked(connection);</span><br><span class="line">        connection-&gt;waitQueue.enqueueAtTail(dispatchEntry);</span><br><span class="line">        traceWaitQueueLengthLocked(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>典型的事件处理函数，从outBoundQueue中取出EventEntry，然后根据其Type，是TypeEvent，还是MotionEvent分别进行处理；可以看到KeyEvent使用publishKeyEvent来处理；而MotionEvent采用publishMotionEvent来处理；</p>
<h2 id="10、InputPublisher-publishMotionEvent："><a href="#10、InputPublisher-publishMotionEvent：" class="headerlink" title="10、InputPublisher#publishMotionEvent："></a>10、InputPublisher#publishMotionEvent：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\libs\input\InputTransport.cpp **/</span> </span><br><span class="line"><span class="keyword">status_t</span> InputPublisher::publishMotionEvent(</span><br><span class="line">        <span class="keyword">uint32_t</span> seq,</span><br><span class="line">        <span class="keyword">int32_t</span> deviceId,</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">const</span> PointerProperties* pointerProperties,</span><br><span class="line">        <span class="keyword">const</span> PointerCoords* pointerCoords) &#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="comment">// 一系列的赋值操作</span></span><br><span class="line">    InputMessage msg;</span><br><span class="line">    msg.header.type = InputMessage::TYPE_MOTION;</span><br><span class="line">    msg.body.motion.seq = seq;</span><br><span class="line">    msg.body.motion.deviceId = deviceId;</span><br><span class="line">    ......</span><br><span class="line">    return mChannel-&gt;sendMessage(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InputPublisher的publishMotionEvent中创建一个InputMessage，然后根据传递进来的EventEntry中的值进行赋值，然后调用InputChannel的sendMessage进行事件发送；这里的InputChannel即是下面将会提到的在ViewRootImpl中创建的Server端的InputChannel；</p>
<h2 id="11、InputChannel-sendMessage"><a href="#11、InputChannel-sendMessage" class="headerlink" title="11、InputChannel#sendMessage:"></a>11、InputChannel#sendMessage:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\libs\input\InputTransport.cpp **/</span></span><br><span class="line"><span class="keyword">status_t</span> InputChannel::sendMessage(<span class="keyword">const</span> InputMessage* msg) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> msgLength = msg-&gt;size();</span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// mFd对应socket fd;则例相当于往服务器socket中发送消息</span></span><br><span class="line">        nWrite = ::send(mFd, msg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送失败</span></span><br><span class="line">    <span class="keyword">if</span> (nWrite &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       .....</span><br><span class="line">        return -error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送成功</span></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InputChannel的sendMessage操作即是使用服务器socket send一个Message；下面将会提到socket服务端没有往inputchannel中写入数据时，客户端暂时处于阻塞状态，一旦服务端有了数据后，客户端也被唤醒了。</p>
<p>这里先来了解下这个重要类InputChannel是如何被初始化的；</p>
<h1 id="三、重要的类InputChannel"><a href="#三、重要的类InputChannel" class="headerlink" title="三、重要的类InputChannel:"></a>三、重要的类InputChannel:</h1><h2 id="1、InputChannel定义"><a href="#1、InputChannel定义" class="headerlink" title="1、InputChannel定义:"></a>1、InputChannel定义:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\include\input\InputTransport.h **/</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * An input channel consists of a local unix domain socket used to send and receive</span><br><span class="line"> * input messages across processes.  Each channel has a descriptive name for debugging purposes.</span><br><span class="line"> *</span><br><span class="line"> * Each endpoint has its own InputChannel object that specifies its file descriptor.</span><br><span class="line"> *</span><br><span class="line"> * The input channel is closed when all references to it are released.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// 上面提到InputChannel是使用unix domain socket（UDS）进行通信的，而非Binder</span></span><br><span class="line"><span class="keyword">class</span> InputChannel : <span class="keyword">public</span> RefBase &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span>~InputChannel();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    InputChannel(<span class="keyword">const</span> String8&amp; name, <span class="keyword">int</span> fd); <span class="comment">// fd类似设备描述符</span></span><br><span class="line">    <span class="comment">// 用于打开一个InputChannel对（Pair）,用以实现双向通信</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> status_t <span class="title">openInputChannelPair</span><span class="params">(<span class="keyword">const</span> String8&amp; name,</span><br><span class="line">            sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> String8 <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; returnmName; &#125;</span><br><span class="line">    <span class="function">inlineint <span class="title">getFd</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; returnmFd; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 发送接收信息</span></span><br><span class="line">    <span class="keyword">status_t</span> sendMessage(<span class="keyword">const</span> InputMessage* msg);</span><br><span class="line">    <span class="keyword">status_t</span> receiveMessage(InputMessage* msg);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Returns a new object that has a duplicate of this channel's fd. */</span></span><br><span class="line">    sp&lt;InputChannel&gt; dup() <span class="keyword">const</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    String8 mName;</span><br><span class="line">    <span class="keyword">int</span> mFd;  <span class="comment">// 重点要弄清该变量代表的含义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>InputChannel是可以双向通信的，它通过openInputChannelPair来打开一个InputChannel对，然后sendMessage或者receiveMessage来发送接收消息；<br>InputChannel是通过UDS来实现通信的，Android系统中最为常用的进程间通信时Binder通信，其次便是UDS进行单机内的进程间通信，也称IPC Socket。<br>来看InputChannel的初始化：<br>了解Window的创建过程后，之后有一个重要的对象ViewRootImpl，这里从其setView开始探索：</p>
<h2 id="2、ViewRootImpl-setView"><a href="#2、ViewRootImpl-setView" class="headerlink" title="2、ViewRootImpl#setView:"></a>2、ViewRootImpl#setView:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\core\java\android\view\ViewRootImpl.java **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        .....</span><br><span class="line">        <span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">                &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">            mInputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在Session addToDisplay时，传入mInputChannel</span></span><br><span class="line">            res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                    getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                    mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mInputChannel);</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实Java层的InputChannel只是对native层的封装，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\core\java\android\view\InputChannel.java **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InputChannel</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mPtr; <span class="comment">// used by native code</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> InputChannel[] nativeOpenInputChannelPair(String name);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeDispose</span><span class="params">(<span class="keyword">boolean</span> finalized)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeTransferTo</span><span class="params">(InputChannel other)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeReadFromParcel</span><span class="params">(Parcel parcel)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeWriteToParcel</span><span class="params">(Parcel parcel)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeDup</span><span class="params">(InputChannel target)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> String <span class="title">nativeGetName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WindowSession的具体细节参见<a href="http://blog.csdn.net/woliuyunyicai/article/details/48419135" target="_blank" rel="external">《View机制深入学习（一）》</a>，addToDisplay会继续调用WindowManagerService的addWindow函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\core\java\android\view\WindowManagerService.java **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span><br><span class="line">                     WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span><br><span class="line">                     Rect outContentInsets, Rect outStableInsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">if</span> (outInputChannel != <span class="keyword">null</span> &amp;&amp; (attrs.inputFeatures</span><br><span class="line">            &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">        String name = win.makeInputChannelName();</span><br><span class="line">        <span class="comment">// 打开InputChannel对</span></span><br><span class="line">        InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);</span><br><span class="line">        <span class="comment">// WindowState设置inputChannel变量</span></span><br><span class="line">        win.setInputChannel(inputChannels[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 设置outputChannel</span></span><br><span class="line">        inputChannels[<span class="number">1</span>].transferTo(outInputChannel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// InputManager注册InputChannel</span></span><br><span class="line">        mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在这里通过openInputChannelPair打开InputChannel，前面提到openInputChannelPair就是调用native端InputChannel的openInputChannelPair函数；<br>从这里面还可以看到，创建的InputChannel对，一个用来设置给WindowState，即供Window使用；一个设置给InputManagerService，其实是设置给native端的InputDispatcher，用以分发相应的事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\core\java\android\view\InputChannel.java **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InputChannel[] openInputChannelPair(String name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"name must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nativeOpenInputChannelPair(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> InputChannel[] nativeOpenInputChannelPair(String name);</span><br></pre></td></tr></table></figure>
<p>下面来看native端的InputChannel；</p>
<h2 id="3、InputChannel-openInputChannelPair"><a href="#3、InputChannel-openInputChannelPair" class="headerlink" title="3、InputChannel::openInputChannelPair:"></a>3、InputChannel::openInputChannelPair:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\libs\input\InputTransport.cpp **/</span></span><br><span class="line"><span class="keyword">status_t</span> InputChannel::openInputChannelPair(<span class="keyword">const</span> String8&amp; name,</span><br><span class="line">                                            sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel) &#123;</span><br><span class="line">    <span class="comment">// 建立UDS</span></span><br><span class="line">    <span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 创建一个饱含2个元素的socket数组，socketpair创建一对socket对象，SOCK_SEQPACKET表示创建连续可靠的数据包连接，如果创建成功，返回0，如果返回-1，出错。</span></span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets)) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> result = -errno;</span><br><span class="line">        outServerChannel.clear();</span><br><span class="line">        outClientChannel.clear();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置缓冲区大小</span></span><br><span class="line">    <span class="keyword">int</span> bufferSize = SOCKET_BUFFER_SIZE;</span><br><span class="line">    setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Server与Client端实例</span></span><br><span class="line">    String8 serverChannelName = name;</span><br><span class="line">    serverChannelName.append(<span class="string">" (server)"</span>);</span><br><span class="line">    outServerChannel = new InputChannel(serverChannelName, sockets[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    String8 clientChannelName = name;</span><br><span class="line">    clientChannelName.append(<span class="string">" (client)"</span>);</span><br><span class="line">    outClientChannel = new InputChannel(clientChannelName, sockets[<span class="number">1</span>]);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面创建了一对InputChannel：分别为服务端管道对象outServerChannel和客户端管道对象outClientChannel;inputChannels[0]作为服务端管道提供给InputDispatcher使用，用来发送按键事件；inputChannels[1]作为客户端管道提供给应用程序主线程使用，用来接收、消费按键事件。</p>
<p>创建好InputChannel之后，继续来看addWindow中的InputManagerService注册InputChannel的过程；前面提到，创建的inputChannels[0]即outServerChannel是供IMS中的InputDispatcher使用的，因此这里需要进行注册；</p>
<h2 id="4、InputManagerService-registerInputChannel："><a href="#4、InputManagerService-registerInputChannel：" class="headerlink" title="4、InputManagerService#registerInputChannel："></a>4、InputManagerService#registerInputChannel：</h2><p>直接来到本地端的nativeRegisterInputChannel，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span>  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeRegisterInputChannel</span><span class="params">(JNIEnv* env, jclass clazz,</span><br><span class="line">        jlong ptr, jobject inputChannelObj, jobject inputWindowHandleObj, jboolean monitor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将Java端存储的ptr指针地址转化为NativeInputManager对象</span></span><br><span class="line">    NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据传输进来的inputChannelObj获取InputChannel对象</span></span><br><span class="line">    sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env, inputChannelObj);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 根据传递进来的inputWindowHandleObj来获取InputWindowHandle对象</span></span><br><span class="line">    sp&lt;InputWindowHandle&gt; inputWindowHandle = android_server_InputWindowHandle_getHandle(env, inputWindowHandleObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用NativeInputManager的registerInputChannel进行注册</span></span><br><span class="line">    <span class="keyword">status_t</span> status = im-&gt;registerInputChannel(env, inputChannel, inputWindowHandle, monitor);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的逻辑很清晰，通过java层传递进来的inputChannelObj,inputWindowHandleObj来获取相对应的InputChannel以及InputWindowHandle对象。<br>然后将获得的实例传入到NativeInputManager中的registerInputChannel进行注册；</p>
<h2 id="5、NativeInputManager-registerInputChannel"><a href="#5、NativeInputManager-registerInputChannel" class="headerlink" title="5、NativeInputManager#registerInputChannel:"></a>5、NativeInputManager#registerInputChannel:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp **/</span>  </span><br><span class="line"><span class="keyword">status_t</span> NativeInputManager::registerInputChannel(JNIEnv* env,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="keyword">bool</span> monitor) &#123;</span><br><span class="line">    return mInputManager-&gt;getDispatcher()-&gt;registerInputChannel(</span><br><span class="line">            inputChannel, inputWindowHandle, monitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里最终是调用InputManager中的InputDispatcher的registerInputChannel进行注册，这也验证了前面所叙述的服务器端的InputChannel是供以InputDispatcher来使用的。</p>
<h2 id="6、InputDispatcher-registerInputChannel"><a href="#6、InputDispatcher-registerInputChannel" class="headerlink" title="6、InputDispatcher#registerInputChannel:"></a>6、InputDispatcher#registerInputChannel:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** \frameworks\native\services\inputflinger\InputDispatcher.cpp **/</span>  </span><br><span class="line"><span class="keyword">status_t</span> InputDispatcher::registerInputChannel(<span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="keyword">bool</span> monitor) &#123;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getConnectionIndexLocked(inputChannel) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            return BAD_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Connection来管理对应的InputChannel以及WindowHandler</span></span><br><span class="line">        sp&lt;Connection&gt; connection = new Connection(inputChannel, inputWindowHandle, monitor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取InputChannel对应的socket Fd;</span></span><br><span class="line">        <span class="keyword">int</span> fd = inputChannel-&gt;getFd();</span><br><span class="line">        <span class="comment">// 类似于key,value形式，将connection与inputChannel的fd建立起关联</span></span><br><span class="line">        mConnectionsByFd.add(fd, connection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (monitor) &#123;</span><br><span class="line">            mMonitoringChannels.push(inputChannel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将InputChannel的fd添加到Looper中epoll的兴趣事件列表中</span></span><br><span class="line">        mLooper-&gt;addFd(fd, <span class="number">0</span>, ALOOPER_EVENT_INPUT, handleReceiveCallback, <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wake the looper because some connections have changed.</span></span><br><span class="line">    <span class="comment">// 因为connection已经发生了变化，则唤醒Looper</span></span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过InputChannel以及InputWindowHandle来创建相对应的Connection；Connetction是用来管理InputChannel的，Connection存储在 mConnectionsByFd的，它通过key-value形式进行存储，Connection的关键字使用InputChannel创建时的socket的fd来标识。</p>
<p>然后将InputChannel的fd添加到Looper的epoll兴趣列表中，注意这里的Looper对应的是InputDispatcherThread中的Looper；当server端的InputChannel有事件传递时，这时Looper会被唤醒，执行handleReceiveCallback回调；</p>
<p>服务器端InputChannel使用InputManagerService的registerInputChannel来实现，而客户端的InputChannel则通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputChannels[1].transferTo(outInputChannel);</span><br></pre></td></tr></table></figure>
<p>来实现；</p>
<h2 id="7、InputChannel-transferTo："><a href="#7、InputChannel-transferTo：" class="headerlink" title="7、InputChannel#transferTo："></a>7、InputChannel#transferTo：</h2><p>直接来到对应的native层的transferTo:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @path: \frameworks\base\core\jni\android_view_InputChannel.cpp */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_view_InputChannel_nativeTransferTo</span><span class="params">(JNIEnv* env, jobject obj,</span><br><span class="line">        jobject otherObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (android_view_InputChannel_getNativeInputChannel(env, otherObj) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>,</span><br><span class="line">                <span class="string">"Other object already has a native input channel."</span>);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建InputChannel</span></span><br><span class="line">    NativeInputChannel* nativeInputChannel =</span><br><span class="line">            android_view_InputChannel_getNativeInputChannel(env, obj);</span><br><span class="line">    android_view_InputChannel_setNativeInputChannel(env, otherObj, nativeInputChannel);</span><br><span class="line">    android_view_InputChannel_setNativeInputChannel(env, obj, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意函数中出现的几个变量对应的含义：<br>obj：本地方法所在对象的引用，对应inputChannels[1]客户端对象的引用<br>otherObj：在ViewRootImpl中创建的InputChannel对象<br>具体不再细述，就是将本地端的InputChannel[1]赋值给Java端的outInputChannel对象；</p>
<p>在前面第二章末已经提出，使用InputPublisher来将Message传递给InputChannel，这里是发送事件；而相对应的，会有一个是用来接收事件的，其类名为InputConsumer；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Retrofit源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/06/Retrofit源码解析/" class="article-date">
      <time datetime="2016-05-06T13:23:44.358Z" itemprop="datePublished">2016-05-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/06/Retrofit源码解析/">Retrofit源码解析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="一、gradle添加依赖"><a href="#一、gradle添加依赖" class="headerlink" title="一、gradle添加依赖"></a>一、gradle添加依赖</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'com.squareup.okhttp:okhttp:2.4.0'</span></span><br><span class="line">compile <span class="string">'com.squareup.okhttp:okhttp-urlconnection:2.4.0'</span></span><br><span class="line">compile <span class="string">'com.squareup.okio:okio:1.5.0'</span></span><br><span class="line">compile <span class="string">'com.google.code.gson:gson:2.2.4'</span></span><br><span class="line"></span><br><span class="line">compile <span class="string">'com.squareup.retrofit:retrofit:2.0.0-beta2'</span></span><br><span class="line">compile <span class="string">'com.squareup.retrofit:adapter-rxjava:2.0.0-beta2'</span></span><br><span class="line">compile <span class="string">'com.squareup.retrofit:converter-gson:2.0.0-beta2'</span></span><br><span class="line"></span><br><span class="line">compile <span class="string">'io.reactivex:rxandroid:1.1.0'</span></span><br><span class="line">compile <span class="string">'io.reactivex:rxjava:1.1.0'</span></span><br></pre></td></tr></table></figure>
<p><strong>盗两张网上的图：</strong><br>下面是从创建Retrofit出发，具体的使用流程；Retrofit最终的请求操作都是交由okHttp去执行的，执行的结果返回Response，再根据转换器进行解析成相对应的返回类型T;<br>Retrofit中使用了动态代理，方便了使用；通过retrofit.create返回的其实是个动态代理类，所有具体的处理逻辑交由MethodHandler进行处理；<br><img src="http://chuantu.biz/t4/9/1462541755x3738746535.png" alt="Alt text"></p>
<p>下面是Retrofit系统中的整个类图，有点像外观模式，Retrofit持有所有子系统的引用；Retrofit比较重要的是两个Factory，一个使用来生成CallAdapter的CallAdapterFactory；一个是用来转换结果的ConvertFactory；这两个都可以用户自己进行添加。<br>在自定义的Service中，每一个method对应一个MethodHandler,MethodHandler持有retrofit，前面两个Factory以及生成Request的RequestFactory；在okHttp中，Request需要自己进行定义创建，而Retrofit简化了这个操作，进行了相应的封装，使用注解的方式来定义Request的相关参数信息；注解信息的解析则在RequestFactory中完成，通过RequestFactoryParser对注解信息进行简单解析，RequestBuilderAction是解析method中参数中的注解如@Path这些产生的中间产物，最终通过RequestBuilder来具体产生一个Request，RequestBuilder中持有okHttp中的Request.Builder类的引用，其创建Request过程其实都是交给okHttp来操作的；<br>生成的Request最终封装成为一个OkHttpCall，OkHttpCall则可以看做是对okHttp中Call的通过，它的enqueue等网络请求操作都是委托个给okHttp来操作的；同时对okHttp的返回Response进行解析，使用convertFactory，将其解析为用户所期望的返回类型；<br><img src="http://chuantu.biz/t4/9/1462541864x3738746535.png" alt="Alt text"></p>
<h1 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h1><h2 id="（一）使用Call形式"><a href="#（一）使用Call形式" class="headerlink" title="（一）使用Call形式"></a>（一）使用Call形式</h2><h3 id="1、定义请求接口："><a href="#1、定义请求接口：" class="headerlink" title="1、定义请求接口："></a>1、定义请求接口：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetrofirHttpService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"&#123;user&#125;"</span>)</span><br><span class="line">    <span class="function">Call&lt;UserInfo&gt; <span class="title">getData</span><span class="params">(@Path(<span class="string">"user"</span>)</span> String user)</span>;</span><br><span class="line">&#125;</span><br><span class="line">注：UserInfo是自己定义的解析类：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">    String username;</span><br><span class="line">    String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、使用GET获取信息："><a href="#2、使用GET获取信息：" class="headerlink" title="2、使用GET获取信息："></a>2、使用GET获取信息：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始的CallBack方式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getUseCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加拦截器</span></span><br><span class="line">    OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    client.interceptors().add(<span class="keyword">new</span> LoggingInterceptor());</span><br><span class="line"></span><br><span class="line">    Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="string">"http://115.156.187.146/TransferServer/"</span>)</span><br><span class="line">            .client(client)                                     <span class="comment">// 添加okHttp</span></span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create()) <span class="comment">// GSON进行转换</span></span><br><span class="line">            .build();</span><br><span class="line">    RetrofirHttpService apiStores = retrofit.create(RetrofirHttpService.class);</span><br><span class="line">    Call&lt;UserInfo&gt; call = apiStores.getData(<span class="string">"ServerMain.php"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步调用</span></span><br><span class="line">    call.enqueue(<span class="keyword">new</span> Callback&lt;UserInfo&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Response&lt;UserInfo&gt; response, Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">            UserInfo data = response.body();</span><br><span class="line">            LogUtils.i(<span class="string">"Call Result:"</span> + data.m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            LogUtils.e(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="（二）使用RxJava形式"><a href="#（二）使用RxJava形式" class="headerlink" title="（二）使用RxJava形式"></a>（二）使用RxJava形式</h2><h3 id="1、定义请求接口"><a href="#1、定义请求接口" class="headerlink" title="1、定义请求接口"></a>1、定义请求接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RxHttpService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"&#123;path&#125;"</span>)</span><br><span class="line">    <span class="function">Observable&lt;UserInfo&gt; <span class="title">getData</span><span class="params">(@Path(<span class="string">"path"</span>)</span> String path)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、具体使用"><a href="#2、具体使用" class="headerlink" title="2、具体使用"></a>2、具体使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用RxJava方式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getUseRxJava</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加拦截器</span></span><br><span class="line">    OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    client.interceptors().add(<span class="keyword">new</span> LoggingInterceptor());</span><br><span class="line"></span><br><span class="line">    Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="string">"http://115.156.187.146/TransferServer/"</span>)</span><br><span class="line">            .client(client)  <span class="comment">// 添加okHttp</span></span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create()) <span class="comment">// GSON进行转换</span></span><br><span class="line">            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    RxHttpService apiStores = retrofit.create(RxHttpService.class);</span><br><span class="line">    Observable&lt;UserInfo&gt; observable = apiStores.getData(<span class="string">"ServerMain.php"</span>);</span><br><span class="line">    observable.subscribeOn(Schedulers.io())</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Observer&lt;UserInfo&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(UserInfo user)</span> </span>&#123;</span><br><span class="line">                    LogUtils.i(<span class="string">"Call Result:"</span> + user.m);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">                    LogUtils.e(error.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、源码分析："><a href="#三、源码分析：" class="headerlink" title="三、源码分析："></a>三、源码分析：</h1><h2 id="（一）先来看创建动态代理类的过程："><a href="#（一）先来看创建动态代理类的过程：" class="headerlink" title="（一）先来看创建动态代理类的过程："></a>（一）先来看创建动态代理类的过程：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RxHttpService apiStores = retrofit.create(RxHttpService.class);</span><br></pre></td></tr></table></figure>
<h3 id="1）Retrofit-create"><a href="#1）Retrofit-create" class="headerlink" title="1）Retrofit#create:"></a>1）Retrofit#create:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Create an implementation of the API defined by the &#123;<span class="doctag">@code</span> service&#125; interface. */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) <span class="comment">// Single-interface proxy creation guarded by parameter safety.</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    Utils.validateServiceInterface(service);</span><br><span class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">        eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;service&#125;,</span><br><span class="line">            <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span><br><span class="line">                        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">                    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">                        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> loadMethodHandler(method).invoke(args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准的动态代理创建过程；<br>来看代理类和委托类之间的中间InvocationHandler类的invoke函数具体执行逻辑；<br><code>loadMethodHandler(method).invoke(args);</code></p>
<h3 id="2）Retrofit-loadMethodHandler"><a href="#2）Retrofit-loadMethodHandler" class="headerlink" title="2）Retrofit#loadMethodHandler:"></a>2）Retrofit#loadMethodHandler:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MethodHandler&lt;?&gt;&gt; methodHandlerCache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">MethodHandler&lt;?&gt; loadMethodHandler(Method method) &#123;</span><br><span class="line">    MethodHandler&lt;?&gt; handler;</span><br><span class="line">    <span class="keyword">synchronized</span> (methodHandlerCache) &#123;</span><br><span class="line">        handler = methodHandlerCache.get(method);</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handler = MethodHandler.create(<span class="keyword">this</span>, method);</span><br><span class="line">            methodHandlerCache.put(method, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Retrofit维护了一个method对应的Map，这里将method都封装成一个MethodHandler类（可以当作是委托类）；调用代理类，其实就是调用MethodHandler的invoke;所以具体的实现逻辑都在MethodHanlder中；</p>
<h2 id="（二）MethodHanlder"><a href="#（二）MethodHanlder" class="headerlink" title="（二）MethodHanlder"></a>（二）MethodHanlder</h2><h3 id="1）MethodHandler类："><a href="#1）MethodHandler类：" class="headerlink" title="1）MethodHandler类："></a>1）MethodHandler类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// MethodHandler持有一个retrofit对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Retrofit retrofit;</span><br><span class="line">    <span class="comment">// 类似于Volley中的 Request ，包含了HTTP请求的Url、Header信息，MediaType、Method以及RequestAction数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestFactory requestFactory;</span><br><span class="line">    <span class="comment">// HTTP请求返回数据的类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;T&gt; callAdapter;</span><br><span class="line">    <span class="comment">// 对返回数据进行转换的类型转换器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;ResponseBody, T&gt; responseConverter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MethodHandler</span><span class="params">(Retrofit retrofit, RequestFactory requestFactory,</span><br><span class="line">                          CallAdapter&lt;T&gt; callAdapter, Converter&lt;ResponseBody, T&gt; responseConverter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">        <span class="keyword">this</span>.requestFactory = requestFactory;</span><br><span class="line">        <span class="keyword">this</span>.callAdapter = callAdapter;</span><br><span class="line">        <span class="keyword">this</span>.responseConverter = responseConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一次请求的最终具体调用的函数</span></span><br><span class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以发现最终是调用callAdapter的adapt函数</span></span><br><span class="line">        <span class="comment">// 并且将相应的请求事务封装成一个OkHttpCall类进行处理</span></span><br><span class="line">        <span class="keyword">return</span> callAdapter.adapt(<span class="keyword">new</span> OkHttpCall&lt;&gt;(retrofit, requestFactory, responseConverter, args));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用该静态类创建一个MethodHandler实例</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">static</span> MethodHandler&lt;?&gt; create(Retrofit retrofit, Method method) &#123;</span><br><span class="line">        <span class="comment">// 创建CallAdapter</span></span><br><span class="line">        CallAdapter&lt;Object&gt; callAdapter = (CallAdapter&lt;Object&gt;) createCallAdapter(method, retrofit);</span><br><span class="line">        <span class="comment">// 根据callAdapter来获取相应的返回类型</span></span><br><span class="line">        Type responseType = callAdapter.responseType();</span><br><span class="line">        <span class="comment">// 创建结果类型转换器</span></span><br><span class="line">        Converter&lt;ResponseBody, Object&gt; responseConverter =</span><br><span class="line">                (Converter&lt;ResponseBody, Object&gt;) createResponseConverter(method, retrofit, responseType);</span><br><span class="line">        <span class="comment">// 创建RequestFactory</span></span><br><span class="line">        RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodHandler&lt;&gt;(retrofit, requestFactory, callAdapter, responseConverter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建相应的CallAdapter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CallAdapter&lt;?&gt; createCallAdapter(Method method, Retrofit retrofit) &#123;</span><br><span class="line">        <span class="comment">// 这个method即为service中自定义的一个方法，一般返回都是泛型类</span></span><br><span class="line">        Type returnType = method.getGenericReturnType();</span><br><span class="line">        <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Utils.methodError(method,</span><br><span class="line">                    <span class="string">"Method return type must not include a type variable or wildcard: %s"</span>, returnType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Utils.methodError(method, <span class="string">"Service methods cannot return void."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取Method上对应的注解即（GET这些）</span></span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据注解来获取相应的Adapter</span></span><br><span class="line">            <span class="keyword">return</span> retrofit.callAdapter(returnType, annotations);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">            <span class="keyword">throw</span> Utils.methodError(e, method, <span class="string">"Unable to create call adapter for %s"</span>, returnType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后也是调用retrofit来实现的；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Converter&lt;ResponseBody, ?&gt; createResponseConverter(Method method,</span><br><span class="line">                                                                      Retrofit retrofit, Type responseType) &#123;</span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> retrofit.responseConverter(responseType, annotations);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">            <span class="keyword">throw</span> Utils.methodError(e, method, <span class="string">"Unable to create converter for %s"</span>, responseType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MethodHandler是系统为定义的每一个Service中的method中创建的一个具体执行类，通过调用其invoke函数，来执行具体的请求的逻辑；<br>它主要包含四个变量：<br>// MethodHandler持有一个retrofit对象<br><code>private final Retrofit retrofit;</code><br>// 类似于Volley中的 Request ，包含了HTTP请求的Url、Header信息，MediaType、Method以及RequestAction数组<br><code>private final RequestFactory requestFactory;</code><br>// HTTP请求返回数据的类型<br><code>private final CallAdapter&lt;T&gt; callAdapter;</code><br>// 对返回数据进行转换的类型转换器<br><code>private final Converter&lt;ResponseBody, T&gt; responseConverter;</code><br>具体来看每个变量的创建；</p>
<h3 id="2）Retrofit-callAdapter"><a href="#2）Retrofit-callAdapter" class="headerlink" title="2）Retrofit#callAdapter:"></a>2）Retrofit#callAdapter:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; adapterFactories;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;</span><br><span class="line">    <span class="keyword">return</span> nextCallAdapter(<span class="keyword">null</span>, returnType, annotations);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns the &#123;<span class="doctag">@link</span> CallAdapter&#125; for &#123;<span class="doctag">@code</span> returnType&#125; from the available &#123;<span class="doctag">@linkplain</span></span><br><span class="line"> * #callAdapterFactories() factories&#125; except &#123;<span class="doctag">@code</span> skipPast&#125;.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// 返回相关的可用的CallAdapter（除了指定跳过的skipPast）</span></span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?&gt; nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,</span><br><span class="line">                                      Annotation[] annotations) &#123;</span><br><span class="line">    checkNotNull(returnType, <span class="string">"returnType == null"</span>);</span><br><span class="line">    checkNotNull(annotations, <span class="string">"annotations == null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = adapterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历adapterFactories中所有的Factory</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">        CallAdapter&lt;?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 如果找到，则返回该Adapter</span></span><br><span class="line">        <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> adapter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果获取不到相应的CallAdapter，则抛出异常</span></span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"Could not locate call adapter for "</span>)</span><br><span class="line">            .append(returnType)</span><br><span class="line">            .append(<span class="string">". Tried:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">        builder.append(<span class="string">"\n * "</span>).append(adapterFactories.get(i).getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (skipPast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        builder.append(<span class="string">"\nSkipped:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; start; i++) &#123;</span><br><span class="line">            builder.append(<span class="string">"\n * "</span>).append(adapterFactories.get(i).getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RetroFit中有一个adapterFactories保存了所有CallAdapter.Factory,通过遍历这些factory来获取相应符合的CallAdapter;<br>先来看adapterFactories都保存了哪些Factory；从Retrofit创建开始</p>
<h2 id="（三）Retrofit的创建"><a href="#（三）Retrofit的创建" class="headerlink" title="（三）Retrofit的创建"></a>（三）Retrofit的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BaseUrl baseUrl;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; adapterFactories;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Retrofit</span><span class="params">(OkHttpClient client, BaseUrl baseUrl, List&lt;Converter.Factory&gt; converterFactories,</span><br><span class="line">                 List&lt;CallAdapter.Factory&gt; adapterFactories, Executor callbackExecutor,</span><br><span class="line">                 <span class="keyword">boolean</span> validateEagerly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">    <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">    <span class="keyword">this</span>.converterFactories = converterFactories;</span><br><span class="line">    <span class="keyword">this</span>.adapterFactories = adapterFactories;</span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    <span class="keyword">this</span>.validateEagerly = validateEagerly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Create the &#123;<span class="doctag">@link</span> Retrofit&#125; instances. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base URL required."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认使用OkhttpClient</span></span><br><span class="line">    OkHttpClient client = <span class="keyword">this</span>.client;</span><br><span class="line">    <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">        client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向adapterFactories添加了一个默认的CallAdapterFactory</span></span><br><span class="line">    <span class="comment">// 如果前面add了CallAdpterfactory（如RxJavaCallAdapterFactory），则可以看到默认的Factory会添加到用户指定的Factory后面</span></span><br><span class="line">    <span class="comment">// 则在遍历的时候，会优先遍历用户指定的Factory</span></span><br><span class="line">    List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.adapterFactories);</span><br><span class="line">    adapterFactories.add(Platform.get().defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make a defensive copy of the converters.</span></span><br><span class="line">    List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.converterFactories);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(client, baseUrl, converterFactories, adapterFactories, callbackExecutor,</span><br><span class="line">            validateEagerly);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 用户添加自定义的CallAdapterFactory</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">addCallAdapterFactory</span><span class="params">(CallAdapter.Factory factory)</span> </span>&#123;</span><br><span class="line">    adapterFactories.add(checkNotNull(factory, <span class="string">"factory == null"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续来看系统默认的CallAdapterFactory；<br>Platform.get()是根据系统不同来创建不同的运行环境，比如是再Android上还是Java上运行时由区别的，如下所示：</p>
<h3 id="1）Platform"><a href="#1）Platform" class="headerlink" title="1）Platform:"></a>1）Platform:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Platform PLATFORM = findPlatform();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Platform <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PLATFORM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Platform <span class="title">findPlatform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是Android系统</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"android.os.Build"</span>);</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Android();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是Java系统</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"java.util.Optional"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Java8();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是其他系统</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Platform();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建默认的CallAdapterFactory过程</span></span><br><span class="line">        <span class="meta">@Override</span> CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果没有指定callbackExecutor，或者为null，则新创建一个MainThreadExecutor</span></span><br><span class="line">                callbackExecutor = <span class="keyword">new</span> MainThreadExecutor();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该Executor的主要工作逻辑就是调用主线程的Looper来创建一个对应的Handler</span></span><br><span class="line">        <span class="comment">// 执行execute就是操作Handler进行post事件（Runnable）</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                handler.post(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到对应不同的系统平台，Retrofit提供了不同的Platform版本； 默认的CallAdapterFactory是个ExecutorCallAdapterFactory，它是通过callbackExecutor来创建的；<br>如果用户没有执行相应的callbackExecutor，系统或创建一个默认的MainThreadExecutor，该MainThreadExecutor的主要执行逻辑就是使用主线程的Handler来post Runnable消息；<br>然后Retrofit把ExecutorCallAdapterFactory实例添加到adapterFactories中；</p>
<h3 id="2）继续二中MethodHandler的查找CallAdapter的逻辑："><a href="#2）继续二中MethodHandler的查找CallAdapter的逻辑：" class="headerlink" title="2）继续二中MethodHandler的查找CallAdapter的逻辑："></a>2）继续二中MethodHandler的查找CallAdapter的逻辑：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CallAdapter&lt;?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallAdapterFactory</span> <span class="keyword">implements</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">    ExecutorCallAdapterFactory(Executor callbackExecutor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CallAdapter&lt;Call&lt;?&gt;&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">        <span class="comment">// 根据returnType获得具体的返回类型</span></span><br><span class="line">        <span class="keyword">if</span> (Utils.getRawType(returnType) != Call.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Type responseType = Utils.getCallResponseType(returnType);</span><br><span class="line">        <span class="comment">// 返回一个CallAdapter</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> responseType;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用adapt返回一个ExecutorCallbackCall类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;R&gt; <span class="function">Call&lt;R&gt; <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 将前面所有的逻辑串在一起，使用动态代理创建的代理类使用的InvokeHandler，调用其invoke来实现一个具体的方法调用；委托类是系统自定义创建的MethodHandler，系统根据method来创建相应的MethodHandler;MethodHandler中持有对CallAdapter的引用，CallAdapter是通过相应的CallAdpterFactory来创建的，如果加入了自定义的比如RxJava，最终会添加到Retrofit中的一个factory链表中，系统通过扫描链表来获取合适的CallAdpterFactory来创建CallAdapter;<br>如果没有自定义CallAdapterFactory，则会默认生成一个CallAdapterFactory;通过这个默认的Factory会创建一个默认的CallAdapter；<br>代理类的方法实现，是通过InvokeHandler的invoke来实现的；在系统定义的Invokehandler中进而调用MethodHandler的invoke函数，该invoke函数会继续调用CallAdpter的adapt,由上知，最终返回一个ExecutorCallbackCall类；</p>
<p>继续来看ExecutorCallbackCall类：</p>
<h3 id="3）ExecutorCallbackCall类："><a href="#3）ExecutorCallbackCall类：" class="headerlink" title="3）ExecutorCallbackCall类："></a>3）ExecutorCallbackCall类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallAdapterFactory</span> <span class="keyword">implements</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这里的Call传递进来的是一个封装好的OkHttpCall类</span></span><br><span class="line">        ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">            <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">            <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">            delegate.enqueue(<span class="keyword">new</span> ExecutorCallback&lt;&gt;(callbackExecutor, callback));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> delegate.execute();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            delegate.cancel();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"CloneDoesntCallSuperClone"</span>) <span class="comment">// Performing deep clone.</span></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;T&gt; <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallback</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Callback&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">        ExecutorCallback(Executor callbackExecutor, Callback&lt;T&gt; delegate) &#123;</span><br><span class="line">            <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">            <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(<span class="keyword">final</span> Response&lt;T&gt; response, <span class="keyword">final</span> Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">            callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    delegate.onResponse(response, retrofit);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">            callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    delegate.onFailure(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来ExecutorCallbackCall也是一个代理类，它的委托类是OkHttpCall；所以使用默认的CallAdapterFactory返回的是一个封装了OkHttpCall的一个Call类，其具体的类型是ExecutorCallbackCall；</p>
<h3 id="4）OkHttpCall"><a href="#4）OkHttpCall" class="headerlink" title="4）OkHttpCall:"></a>4）OkHttpCall:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Retrofit retrofit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestFactory requestFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;ResponseBody, T&gt; responseConverter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> com.squareup.okhttp.Call rawCall;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> executed; <span class="comment">// Guarded by this.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled;</span><br><span class="line"></span><br><span class="line">    OkHttpCall(Retrofit retrofit, RequestFactory requestFactory,</span><br><span class="line">               Converter&lt;ResponseBody, T&gt; responseConverter, Object[] args) &#123;</span><br><span class="line">        <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">        <span class="keyword">this</span>.requestFactory = requestFactory;</span><br><span class="line">        <span class="keyword">this</span>.responseConverter = responseConverter;</span><br><span class="line">        <span class="keyword">this</span>.args = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"CloneDoesntCallSuperClone"</span>)</span><br><span class="line">    <span class="comment">// We are a final type &amp; this saves clearing state.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OkHttpCall&lt;T&gt; <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OkHttpCall&lt;&gt;(retrofit, requestFactory, responseConverter, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看enqueue操作；在用户代码中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;UserInfo&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Response&lt;UserInfo&gt; response, Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">        UserInfo data = response.body();</span><br><span class="line">        LogUtils.i(<span class="string">"Call Result:"</span> + data.m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        LogUtils.e(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>由前面知这里的Call对应的是一个ExecutorCallbackCall，来看起enqueue操作：</p>
<h3 id="5）ExecutorCallbackCall-enqueue"><a href="#5）ExecutorCallbackCall-enqueue" class="headerlink" title="5）ExecutorCallbackCall#enqueue:"></a>5）ExecutorCallbackCall#enqueue:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    delegate.enqueue(<span class="keyword">new</span> ExecutorCallback&lt;&gt;(callbackExecutor, callback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delegate对应的即是OkHttpCall,先来看其enqueue传入的参数： ExecutorCallback<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallback</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callback&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    ExecutorCallback(Executor callbackExecutor, Callback&lt;T&gt; delegate) &#123;</span><br><span class="line">        <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(<span class="keyword">final</span> Response&lt;T&gt; response, <span class="keyword">final</span> Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">        callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                delegate.onResponse(response, retrofit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">        callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                delegate.onFailure(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ExecutorCallback也是一个代理类，用来封装用户定义的Callback，即类内部的变量delegate；callbackExecutor是查找Platform过程中new Android时创建的，其execute的逻辑较为简单，就是使用主线程对应的Handler来将Runnable事件post出去；可以看到，这里最终的响应都会在主线程中，而且调用用户自定义的onResponse和onFailure;<br>ExecutorCallback的主要作用就是封装Callback，将Callback的响应切换到主线程中；</p>
<h3 id="6）继续来看对应的OkHttpCall的enqueue操作："><a href="#6）继续来看对应的OkHttpCall的enqueue操作：" class="headerlink" title="6）继续来看对应的OkHttpCall的enqueue操作："></a>6）继续来看对应的OkHttpCall的enqueue操作：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意okHttp的call和retrofit的Call是不同</span></span><br><span class="line">    com.squareup.okhttp.Call rawCall;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个okhttp类型的Call</span></span><br><span class="line">        rawCall = createRawCall();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        callback.onFailure(t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果取消</span></span><br><span class="line">    <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">        rawCall.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.rawCall = rawCall;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Call中事务全部委托给okHttp来操作</span></span><br><span class="line">    <span class="comment">// 调用okHttp的enqueue，使用okHttp的Callback来封装retrofit中的Callback</span></span><br><span class="line">    rawCall.enqueue(<span class="keyword">new</span> com.squareup.okhttp.Callback() &#123;</span><br><span class="line">        <span class="comment">// 请求失败的响应</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailure</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                callback.onFailure(e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 请求成功的响应</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callSuccess</span><span class="params">(Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                callback.onResponse(response, retrofit);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Request request, IOException e)</span> </span>&#123;</span><br><span class="line">            callFailure(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(com.squareup.okhttp.Response rawResponse)</span> </span>&#123;</span><br><span class="line">            Response&lt;T&gt; response;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获得结果，并且解析结果</span></span><br><span class="line">                response = parseResponse(rawResponse);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                callFailure(e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            callSuccess(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OkHttpCall是对OkHttp里面的Call的封装，将所有的操作都委托给该Call进行操作；这里主要的是通过retrofit的call来创建一个okHttp的Call类；这里通过createRawCall来创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> com.squareup.okhttp.<span class="function">Call <span class="title">createRawCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> retrofit.client().newCall(requestFactory.create(args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里是通过okHttpClient来创建的一个Call；首先来看 requestFactory是如何根据args参数来创建一个相应的Call的；<br>先来看requestFactory，它是MethodHandler中创建传递过来的；<br><code>RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);</code></p>
<h2 id="（四）RequestFactory："><a href="#（四）RequestFactory：" class="headerlink" title="（四）RequestFactory："></a>（四）RequestFactory：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestFactoryParser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> RequestFactory <span class="title">parse</span><span class="params">(Method method, Type responseType, Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">        RequestFactoryParser parser = <span class="keyword">new</span> RequestFactoryParser(method);</span><br><span class="line">        <span class="comment">// Method对应的注解这里解析</span></span><br><span class="line">        parser.parseMethodAnnotations(responseType);</span><br><span class="line">        parser.parseParameters(retrofit);</span><br><span class="line">        <span class="comment">// 创建一个RequestFactory</span></span><br><span class="line">        <span class="keyword">return</span> parser.toRequestFactory(retrofit.baseUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RequestFactoryParser</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RequestFactoryParser主要是根据method对应的注解及返回类型进行相应解析，得出相应的解析结果，然后创建一个RequestFactory来保存所有解析后结果，供创建OkHttpCall来使用。</p>
<h3 id="lt-一-gt-parseMethodAnnotations："><a href="#lt-一-gt-parseMethodAnnotations：" class="headerlink" title="&lt;一&gt;parseMethodAnnotations："></a>&lt;一&gt;parseMethodAnnotations：</h3><h4 id="1）RequestFactoryParser-parseMethodAnnotations："><a href="#1）RequestFactoryParser-parseMethodAnnotations：" class="headerlink" title="1）RequestFactoryParser#parseMethodAnnotations："></a>1）RequestFactoryParser#parseMethodAnnotations：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是对注解进行解析的核心代码</span></span><br><span class="line"><span class="comment">// 根据注解类型的不同（即请求类型类型的不同进行相应解析）</span></span><br><span class="line"><span class="comment">// 这里也对应的retrofit的基本用法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseMethodAnnotations</span><span class="params">(Type responseType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : method.getAnnotations()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> DELETE) &#123;</span><br><span class="line">            parseHttpMethodAndPath(<span class="string">"DELETE"</span>, ((DELETE) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> GET) &#123;</span><br><span class="line">            parseHttpMethodAndPath(<span class="string">"GET"</span>, ((GET) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HEAD) &#123;</span><br><span class="line">            parseHttpMethodAndPath(<span class="string">"HEAD"</span>, ((HEAD) annotation).value(), <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (!Void.class.equals(responseType)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> methodError(method, <span class="string">"HEAD method must use Void as response type."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PATCH) &#123;</span><br><span class="line">            parseHttpMethodAndPath(<span class="string">"PATCH"</span>, ((PATCH) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> POST) &#123;</span><br><span class="line">            parseHttpMethodAndPath(<span class="string">"POST"</span>, ((POST) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PUT) &#123;</span><br><span class="line">            parseHttpMethodAndPath(<span class="string">"PUT"</span>, ((PUT) annotation).value(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HTTP) &#123;</span><br><span class="line">            HTTP http = (HTTP) annotation;</span><br><span class="line">            parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Headers) &#123;</span><br><span class="line">            <span class="comment">// 只有Headers是通过parseHeaders来解析的</span></span><br><span class="line">            String[] headersToParse = ((Headers) annotation).value();</span><br><span class="line">            <span class="keyword">if</span> (headersToParse.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> methodError(method, <span class="string">"@Headers annotation is empty."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            headers = parseHeaders(headersToParse);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Multipart) &#123;</span><br><span class="line">            <span class="comment">// 可以看到Multipart和FormUrlEncoded不能同时定义</span></span><br><span class="line">            <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">                <span class="keyword">throw</span> methodError(method, <span class="string">"Only one encoding annotation is allowed."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            isMultipart = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> FormUrlEncoded) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">                <span class="keyword">throw</span> methodError(method, <span class="string">"Only one encoding annotation is allowed."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            isFormEncoded = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">"HTTP method annotation is required (e.g., @GET, @POST, etc.)."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不存在实体，但是用户定义为isMultipart或者isFormEncoded类型，则会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!hasBody) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">            <span class="keyword">throw</span> methodError(method,</span><br><span class="line">                    <span class="string">"Multipart can only be specified on HTTP methods with request body (e.g., @POST)."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">            <span class="keyword">throw</span> methodError(method,</span><br><span class="line">                    <span class="string">"FormUrlEncoded can only be specified on HTTP methods with request body "</span></span><br><span class="line">                            + <span class="string">"(e.g., @POST)."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是对注解进行解析的核心代码 ，根据注解类型的不同（即请求类型类型的不同） 进行相应解析，这里也对应的retrofit的基本用法；<br>可以看到除了headers使用的parseheader进行解析外，其他都是通过 parseHttpMethodAndPath进行解析的；这里来重点分析下parseHttpMethodAndPath；</p>
<h4 id="2）parseHttpMethodAndPath："><a href="#2）parseHttpMethodAndPath：" class="headerlink" title="2）parseHttpMethodAndPath："></a>2）parseHttpMethodAndPath：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数只是先做了一个前期判断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseHttpMethodAndPath</span><span class="params">(String httpMethod, String value, <span class="keyword">boolean</span> hasBody)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">"Only one HTTP method is allowed. Found: %s and %s."</span>,</span><br><span class="line">                <span class="keyword">this</span>.httpMethod, httpMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对应"GET","POST"等</span></span><br><span class="line">    <span class="keyword">this</span>.httpMethod = httpMethod;</span><br><span class="line">    <span class="comment">// 标注有没有实体</span></span><br><span class="line">    <span class="keyword">this</span>.hasBody = hasBody;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注解值为空直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断URL是否已经有查询字符串query string</span></span><br><span class="line">    <span class="comment">// Get the relative URL path and existing query string, if present.</span></span><br><span class="line">    <span class="keyword">int</span> question = value.indexOf(<span class="string">'?'</span>);</span><br><span class="line">    <span class="keyword">if</span> (question != -<span class="number">1</span> &amp;&amp; question &lt; value.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 保证URL的查询字符串中没有&#123;...&#125;之类的字符</span></span><br><span class="line">        <span class="comment">// Ensure the query string does not have any named parameters.</span></span><br><span class="line">        String queryParams = value.substring(question + <span class="number">1</span>);</span><br><span class="line">        Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);</span><br><span class="line">        <span class="keyword">if</span> (queryParamMatcher.find()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> methodError(method, <span class="string">"URL query string \"%s\" must not have replace block. "</span></span><br><span class="line">                    + <span class="string">"For dynamic query parameters use @Query."</span>, queryParams);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体的解析继续由parsePathParameters来完成</span></span><br><span class="line">    <span class="keyword">this</span>.relativeUrl = value;</span><br><span class="line">    <span class="keyword">this</span>.relativeUrlParamNames = parsePathParameters(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数仅是做了一个简单的前期判断，将method对应的请求类型（httpMethod） ，注解值（relativeUrl），以及是否包含实体信息（hasBody）赋值给该RequestFactoryParser;<br>来看POST和GET的简单调用实例：<br><code>parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);</code><br><code>parseHttpMethodAndPath(&quot;POST&quot;, ((POST) annotation).value(), true);</code><br>继续来看解析函数parsePathParameters :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM = <span class="string">"[a-zA-Z][a-zA-Z0-9_-]*"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PARAM_URL_REGEX = Pattern.compile(<span class="string">"\\&#123;("</span> + PARAM + <span class="string">")\\&#125;"</span>);</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Gets the set of unique path parameters used in the given URI. If a parameter is used twice</span><br><span class="line"> * in the URI, it will only show up once in the set.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// 检测出路径中所有&#123;..&#125;的字段，如&#123;user&#125;等，添加到一个Set中（因此不会重复添加）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Set&lt;String&gt; <span class="title">parsePathParameters</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    Matcher m = PARAM_URL_REGEX.matcher(path);</span><br><span class="line">    Set&lt;String&gt; patterns = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">        patterns.add(m.group(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> patterns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一步仅是根据正则表达式获取URL中所有{…}类型的数据，添加到patterns这个Set中，然后返回给RequestFactoryParser，对relativeUrlParamNames进行赋值；</p>
<p>第一步解析完毕，来到第二步parseParameters：</p>
<h3 id="lt-二-gt-parseParameters："><a href="#lt-二-gt-parseParameters：" class="headerlink" title="&lt;二&gt;parseParameters："></a>&lt;二&gt;parseParameters：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseParameters</span><span class="params">(Retrofit retrofit)</span> </span>&#123;</span><br><span class="line">    Type[] methodParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">    <span class="comment">// 获取method所有参数中的所有的注解信息</span></span><br><span class="line">    Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> gotField = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> gotPart = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> gotBody = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> gotPath = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> gotQuery = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> gotUrl = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = methodParameterAnnotationArrays.length;</span><br><span class="line">    <span class="comment">// 这里是一个重要的类</span></span><br><span class="line">    RequestBuilderAction[] requestBuilderActions = <span class="keyword">new</span> RequestBuilderAction[count];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Type methodParameterType = methodParameterTypes[i];</span><br><span class="line">        Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i];</span><br><span class="line">        <span class="keyword">if</span> (methodParameterAnnotations != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Annotation methodParameterAnnotation : methodParameterAnnotations) &#123;</span><br><span class="line">                RequestBuilderAction action = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 解析URL</span></span><br><span class="line">                <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Url) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (gotUrl) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"Multiple @Url method annotations found."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (gotPath) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Path parameters may not be used with @Url."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (gotQuery) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"A @Url parameter must not come after a @Query"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (methodParameterType != String.class) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Url must be String type."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (relativeUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Url cannot be used with @%s URL"</span>, httpMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                    gotUrl = <span class="keyword">true</span>;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Url();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Path) &#123; <span class="comment">// 解析Path注解</span></span><br><span class="line">                    <span class="keyword">if</span> (gotQuery) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"A @Path parameter must not come after a @Query."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (gotUrl) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Path parameters may not be used with @Url."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (relativeUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Path can only be used with relative url on @%s"</span>,</span><br><span class="line">                                httpMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                    gotPath = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    Path path = (Path) methodParameterAnnotation;</span><br><span class="line">                    String name = path.value();</span><br><span class="line">                    validatePathName(i, name);</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Path(name, path.encoded());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Query) &#123; <span class="comment">// 解析Query注解</span></span><br><span class="line">                    Query query = (Query) methodParameterAnnotation;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Query(query.value(), query.encoded());</span><br><span class="line">                    gotQuery = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> QueryMap) &#123; <span class="comment">// 解析QueryMap注解</span></span><br><span class="line">                    <span class="keyword">if</span> (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@QueryMap parameter type must be Map."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    QueryMap queryMap = (QueryMap) methodParameterAnnotation;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.QueryMap(queryMap.encoded());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Header) &#123; <span class="comment">// 解析header注解</span></span><br><span class="line">                    Header header = (Header) methodParameterAnnotation;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Header(header.value());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Field) &#123; <span class="comment">// 解析Field注解</span></span><br><span class="line">                    <span class="keyword">if</span> (!isFormEncoded) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Field parameters can only be used with form encoding."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Field field = (Field) methodParameterAnnotation;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Field(field.value(), field.encoded());</span><br><span class="line">                    gotField = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> FieldMap) &#123; <span class="comment">// 解析FieldMap</span></span><br><span class="line">                    <span class="keyword">if</span> (!isFormEncoded) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@FieldMap parameters can only be used with form encoding."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@FieldMap parameter type must be Map."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    FieldMap fieldMap = (FieldMap) methodParameterAnnotation;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.FieldMap(fieldMap.encoded());</span><br><span class="line">                    gotField = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Part) &#123; <span class="comment">// 解析Part</span></span><br><span class="line">                    <span class="keyword">if</span> (!isMultipart) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@Part parameters can only be used with multipart encoding."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Part part = (Part) methodParameterAnnotation;</span><br><span class="line">                    com.squareup.okhttp.Headers headers = com.squareup.okhttp.Headers.of(</span><br><span class="line">                            <span class="string">"Content-Disposition"</span>, <span class="string">"form-data; name=\""</span> + part.value() + <span class="string">"\""</span>,</span><br><span class="line">                            <span class="string">"Content-Transfer-Encoding"</span>, part.encoding());</span><br><span class="line">                    Converter&lt;?, RequestBody&gt; converter;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        converter =</span><br><span class="line">                                retrofit.requestConverter(methodParameterType, methodParameterAnnotations);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">                        <span class="keyword">throw</span> parameterError(e, i, <span class="string">"Unable to create @Part converter for %s"</span>,</span><br><span class="line">                                methodParameterType);</span><br><span class="line">                    &#125;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Part&lt;&gt;(headers, converter);</span><br><span class="line">                    gotPart = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> PartMap) &#123; <span class="comment">//解析PartMap</span></span><br><span class="line">                    <span class="keyword">if</span> (!isMultipart) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i,</span><br><span class="line">                                <span class="string">"@PartMap parameters can only be used with multipart encoding."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"@PartMap parameter type must be Map."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    PartMap partMap = (PartMap) methodParameterAnnotation;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.PartMap(retrofit, partMap.encoding(),</span><br><span class="line">                            methodParameterAnnotations);</span><br><span class="line">                    gotPart = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodParameterAnnotation <span class="keyword">instanceof</span> Body) &#123; <span class="comment">// 解析Body</span></span><br><span class="line">                    <span class="keyword">if</span> (isFormEncoded || isMultipart) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i,</span><br><span class="line">                                <span class="string">"@Body parameters cannot be used with form or multi-part encoding."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (gotBody) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"Multiple @Body method annotations found."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Converter&lt;?, RequestBody&gt; converter;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        converter =</span><br><span class="line">                                retrofit.requestConverter(methodParameterType, methodParameterAnnotations);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">                        <span class="keyword">throw</span> parameterError(e, i, <span class="string">"Unable to create @Body converter for %s"</span>,</span><br><span class="line">                                methodParameterType);</span><br><span class="line">                    &#125;</span><br><span class="line">                    action = <span class="keyword">new</span> RequestBuilderAction.Body&lt;&gt;(converter);</span><br><span class="line">                    gotBody = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (action != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (requestBuilderActions[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> parameterError(i, <span class="string">"Multiple Retrofit annotations found, only one allowed."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    requestBuilderActions[i] = action;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (requestBuilderActions[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> parameterError(i, <span class="string">"No Retrofit annotation found."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (relativeUrl == <span class="keyword">null</span> &amp;&amp; !gotUrl) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">"Missing either @%s URL or @Url parameter."</span>, httpMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">"Non-body HTTP method cannot contain @Body."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">"Form-encoded method must contain at least one @Field."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">"Multipart method must contain at least one @Part."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.requestBuilderActions = requestBuilderActions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是根据method里面对应的参数中的注解比如<code>@(Url,Path,Query,QueryMap,Header,Field,FieldMap,Part,PartMap,Body)</code>，它们的解析操作都是通过创建一个RequestBuilderAction类进行相应的解析，比如@Path，解析则调用的是创建一个RequestBuilderAction.Path，Path类是RequestBuilderAction的静态内部类，继承了RequestBuilderAction；最后所有参数中的注解对应一个RequestBuilderAction数组requestBuilderActions，把这个数组赋值给RequestFactoryParser;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBuilderAction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(RequestBuilder builder, Object value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RequestBuilderAction是个抽象类，它内部有一个perform的抽象方法；还有一些具体的内部类继承该方法，根据不同的注解，来创建不同的静态内部类，这些静态内部类都继承了RequestBuilderAction，并且重写了自己的perform方法；<br>如Path:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Path</span> <span class="keyword">extends</span> <span class="title">RequestBuilderAction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> encoded;</span><br><span class="line"></span><br><span class="line">  Path(String name, <span class="keyword">boolean</span> encoded) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = checkNotNull(name, <span class="string">"name == null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.encoded = encoded;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">perform</span><span class="params">(RequestBuilder builder, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">          <span class="string">"Path parameter \""</span> + name + <span class="string">"\" value must not be null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.addPathParam(name, value.toString(), encoded);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这里涉及到一个 RequestBuilder的概念，等到具体使用的时候再进行分析；</p>
<h3 id="lt-三-gt-parser-toRequestFactory-retrofit-baseUrl"><a href="#lt-三-gt-parser-toRequestFactory-retrofit-baseUrl" class="headerlink" title="&lt;三&gt;parser.toRequestFactory(retrofit.baseUrl())"></a>&lt;三&gt;parser.toRequestFactory(retrofit.baseUrl())</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RequestFactory <span class="title">toRequestFactory</span><span class="params">(BaseUrl baseUrl)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RequestFactory(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody,</span><br><span class="line">      isFormEncoded, isMultipart, requestBuilderActions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一步将所有解析完的信息封装成一个 RequestFactory；<br>则继续来看第（三）步中okHttp创建Call是传递进来的参数：requestFactory.create(args)</p>
<h4 id="1）RequestFactory-create"><a href="#1）RequestFactory-create" class="headerlink" title="1）RequestFactory#create:"></a>1）RequestFactory#create:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BaseUrl baseUrl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String relativeUrl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Headers headers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MediaType contentType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> hasBody;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isFormEncoded;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isMultipart;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestBuilderAction[] requestBuilderActions;</span><br><span class="line"></span><br><span class="line">    RequestFactory(String method, BaseUrl baseUrl, String relativeUrl, Headers headers,</span><br><span class="line">                   MediaType contentType, <span class="keyword">boolean</span> hasBody, <span class="keyword">boolean</span> isFormEncoded, <span class="keyword">boolean</span> isMultipart,</span><br><span class="line">                   RequestBuilderAction[] requestBuilderActions) &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">        <span class="keyword">this</span>.relativeUrl = relativeUrl;</span><br><span class="line">        <span class="keyword">this</span>.headers = headers;</span><br><span class="line">        <span class="keyword">this</span>.contentType = contentType;</span><br><span class="line">        <span class="keyword">this</span>.hasBody = hasBody;</span><br><span class="line">        <span class="keyword">this</span>.isFormEncoded = isFormEncoded;</span><br><span class="line">        <span class="keyword">this</span>.isMultipart = isMultipart;</span><br><span class="line">        <span class="keyword">this</span>.requestBuilderActions = requestBuilderActions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Request <span class="title">create</span><span class="params">(Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个RequestBuilder，它是真正创建Request的类</span></span><br><span class="line">        RequestBuilder requestBuilder =</span><br><span class="line">                <span class="keyword">new</span> RequestBuilder(method, baseUrl.url(), relativeUrl, headers, contentType, hasBody,</span><br><span class="line">                        isFormEncoded, isMultipart);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 前面解析method参数中的注解获取到的RequestBuilderAction</span></span><br><span class="line">            RequestBuilderAction[] actions = requestBuilderActions;</span><br><span class="line">            <span class="keyword">if</span> (actions.length != args.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Argument count ("</span></span><br><span class="line">                        + args.length</span><br><span class="line">                        + <span class="string">") doesn't match action count ("</span></span><br><span class="line">                        + actions.length</span><br><span class="line">                        + <span class="string">")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = args.length; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="comment">// 这里调用RequestBuilderAction的perform进行创建</span></span><br><span class="line">                actions[i].perform(requestBuilder, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建造者模型，返回一个build</span></span><br><span class="line">        <span class="keyword">return</span> requestBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到RequestFactory在create时创建了一个RequestBuilder，它是一个典型的Builder模式，也就是类似OkHttp的Request Buidler模式，由用户调用builder自定义来转化为通过注解方式进行定义，而Retrofit通过解析注解信息，分析用户行为，然后将解析信息添加到requestBuidler中来自行构造Request；它暴漏出注解定义的方式，而将具体的Request Builder细节隐藏了。<br>这里终点来看RequestBuidler，前面分析method参数类型获得的RequestBuilderAction，其具体的perform也是通过RequestBuilderAction来实现的；</p>
<h3 id="lt-四-gt-RequestBuilder："><a href="#lt-四-gt-RequestBuilder：" class="headerlink" title="&lt;四&gt;RequestBuilder："></a>&lt;四&gt;RequestBuilder：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBuilder</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注意这里的Request对应的是okHttp的request</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Request.Builder requestBuilder;</span><br><span class="line">    RequestBuilder(String method, HttpUrl baseUrl, String relativeUrl, Headers headers,</span><br><span class="line">                   MediaType contentType, <span class="keyword">boolean</span> hasBody, <span class="keyword">boolean</span> isFormEncoded, <span class="keyword">boolean</span> isMultipart) &#123;</span><br><span class="line"><span class="keyword">this</span>.method = method;</span><br><span class="line"><span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line"><span class="keyword">this</span>.relativeUrl = relativeUrl;</span><br><span class="line"><span class="keyword">this</span>.requestBuilder = <span class="keyword">new</span> Request.Builder();</span><br><span class="line"><span class="keyword">this</span>.contentType = contentType;</span><br><span class="line"><span class="keyword">this</span>.hasBody = hasBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (headers != <span class="keyword">null</span>) &#123;</span><br><span class="line">requestBuilder.headers(headers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line"><span class="comment">// Will be set to 'body' in 'build'.</span></span><br><span class="line">formEncodingBuilder = <span class="keyword">new</span> FormEncodingBuilder();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line"><span class="comment">// Will be set to 'body' in 'build'.</span></span><br><span class="line">multipartBuilder = <span class="keyword">new</span> MultipartBuilder();</span><br><span class="line">            multipartBuilder.type(MultipartBuilder.FORM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Retrofit默认是通过okHttp来实现的，RequestBuidler其实将所有Request创建的任务交给真正的类Okhttp中的Request.Builder进行构造器request；相应的FormEncodingBuilder以及MultipartBuilder也都是okHttp内部的；<br>RequestBuilderAction中的perform也都是通过RequestBuidler的函数来实现的，比如@Path:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Path</span> <span class="keyword">extends</span> <span class="title">RequestBuilderAction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> encoded;</span><br><span class="line"></span><br><span class="line">    Path(String name, <span class="keyword">boolean</span> encoded) &#123;</span><br><span class="line">       <span class="keyword">this</span>.name = checkNotNull(name, <span class="string">"name == null"</span>);</span><br><span class="line">       <span class="keyword">this</span>.encoded = encoded;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">perform</span><span class="params">(RequestBuilder builder, Object value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">       <span class="string">"Path parameter \""</span> + name + <span class="string">"\" value must not be null."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       builder.addPathParam(name, value.toString(), encoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到调用的RequestBuilder的addPathParam方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addPathParam</span><span class="params">(String name, String value, <span class="keyword">boolean</span> encoded)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (relativeUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// The relative URL is cleared when the first query parameter is set.</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">     &#125;</span><br><span class="line">    relativeUrl = relativeUrl.replace(<span class="string">"&#123;"</span> + name + <span class="string">"&#125;"</span>, canonicalize(value, encoded));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再来看RequestFactory#create的返回值，即RequestBuilder.builder:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Request <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  HttpUrl url;</span><br><span class="line">  HttpUrl.Builder urlBuilder = <span class="keyword">this</span>.urlBuilder;</span><br><span class="line">  <span class="keyword">if</span> (urlBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    url = urlBuilder.build();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No query parameters triggered builder creation, just combine the relative URL and base URL.</span></span><br><span class="line">    url = baseUrl.resolve(relativeUrl);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RequestBody body = <span class="keyword">this</span>.body;</span><br><span class="line">  <span class="keyword">if</span> (body == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Try to pull from one of the builders.</span></span><br><span class="line">    <span class="keyword">if</span> (formEncodingBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      body = formEncodingBuilder.build();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (multipartBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      body = multipartBuilder.build();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasBody) &#123;</span><br><span class="line">      <span class="comment">// Body is absent, make an empty body.</span></span><br><span class="line">      body = RequestBody.create(<span class="keyword">null</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MediaType contentType = <span class="keyword">this</span>.contentType;</span><br><span class="line">  <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">      body = <span class="keyword">new</span> ContentTypeOverridingRequestBody(body, contentType);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      requestBuilder.addHeader(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> requestBuilder</span><br><span class="line">      .url(url)</span><br><span class="line">      .method(method, body)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可想而知最后调用的是okHttp总的builder来具体创建一个Request,具体的创建细节见okHttp源码解析；<br>因此返回的是一个okHttp中的Request；来看具体的创建：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">retrofit.client().newCall(requestFactory.create(args));</span><br><span class="line">OkHttpClient#newCall:</span><br><span class="line">/**</span><br><span class="line"> * Prepares the &#123;@code request&#125; to be executed at some point in the future.</span><br><span class="line"> */</span><br><span class="line">public Call newCall(Request request) &#123;</span><br><span class="line">    return new Call(this, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将Request封装成一个Call；因此，接下来的所有网络请求操作都交由okHttp进行处理；</p>
<h3 id="（五）这里来看具体的对返回结果的转换："><a href="#（五）这里来看具体的对返回结果的转换：" class="headerlink" title="（五）这里来看具体的对返回结果的转换："></a>（五）这里来看具体的对返回结果的转换：</h3><p>在调用OkHttpCall的enqueue时，可以看到Callback中会对结果Response(okHttp中的)进行进一步解析，然后将解析后的结果通过Retrofit中定义的callback进行返回，返回的结果为Response<t>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">rawCall.enqueue(<span class="keyword">new</span> com.squareup.okhttp.Callback() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailure</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                callback.onFailure(e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callSuccess</span><span class="params">(Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            callback.onResponse(response, retrofit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Request request, IOException e)</span> </span>&#123;</span><br><span class="line">        callFailure(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(com.squareup.okhttp.Response rawResponse)</span> </span>&#123;</span><br><span class="line">        Response&lt;T&gt; response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response = parseResponse(rawResponse);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            callFailure(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        callSuccess(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></t></p>
<p>可以看到主要解析过程则在于parseResponse中；</p>
<h4 id="1）OkHttpCall-parseResponse："><a href="#1）OkHttpCall-parseResponse：" class="headerlink" title="1）OkHttpCall#parseResponse："></a>1）OkHttpCall#parseResponse：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(com.squareup.okhttp.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ResponseBody rawBody = rawResponse.body();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove the body's source (the only stateful object) so we can pass the response along.</span></span><br><span class="line">    rawResponse = rawResponse.newBuilder()</span><br><span class="line">            .body(<span class="keyword">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> code = rawResponse.code();</span><br><span class="line">    <span class="comment">// 如果请求失败</span></span><br><span class="line">    <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">            ResponseBody bufferedBody = Utils.readBodyToBytesIfNecessary(rawBody);</span><br><span class="line">            <span class="keyword">return</span> Response.error(bufferedBody, rawResponse);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            closeQuietly(rawBody);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有数据返回情况，则不用进行解析</span></span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Response.success(<span class="keyword">null</span>, rawResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ExceptionCatchingRequestBody是对okHttp的RequestBody类的一个封装</span></span><br><span class="line">    ExceptionCatchingRequestBody catchingBody = <span class="keyword">new</span> ExceptionCatchingRequestBody(rawBody);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 利用变换器进行转换</span></span><br><span class="line">        T body = responseConverter.convert(catchingBody);</span><br><span class="line">        <span class="comment">// 将转换后的实体结果和原Response封装成一个Response&lt;T&gt;</span></span><br><span class="line">        <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></span><br><span class="line">        <span class="comment">// a runtime exception.</span></span><br><span class="line">        catchingBody.throwIfCaught();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当请求发生错误，获取204情况没有实体返回时，自然不用对实体进行转化；而对于实体的转换是通过最初定义的转换器来（这里用的是GSON）来进行covert的；然后将转换后的结果同原始okHttp返回的Response封装成一个Response<t>进行返回；<br>先来看传递进来的转换器：</t></p>
<h4 id="2）ConverterFactory："><a href="#2）ConverterFactory：" class="headerlink" title="2）ConverterFactory："></a>2）ConverterFactory：</h4><p>是通过在build retrofit的时候添加的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = new Retrofit.Builder()</span><br><span class="line">        .baseUrl("http://115.156.187.146/TransferServer/")</span><br><span class="line">        .client(client)                                     // 添加okHttp</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create()) // GSON进行转换</span><br><span class="line">        .build();</span><br><span class="line">Retrofit#ConverterFactory:</span><br><span class="line">/** Add converter factory for serialization and deserialization of objects. */</span><br><span class="line">public Builder addConverterFactory(Converter.Factory converterFactory) &#123;</span><br><span class="line">    converterFactories.add(checkNotNull(converterFactory, "converterFactory == null"));</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由前面的分析知，在创建MethodHandler时，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MethodHandler&lt;?&gt; create(Retrofit retrofit, Method method) &#123;</span><br><span class="line">    CallAdapter&lt;Object&gt; callAdapter = (CallAdapter&lt;Object&gt;) createCallAdapter(method, retrofit);</span><br><span class="line">    Type responseType = callAdapter.responseType();</span><br><span class="line">    <span class="comment">// 创建转换器</span></span><br><span class="line">    Converter&lt;ResponseBody, Object&gt; responseConverter =</span><br><span class="line">            (Converter&lt;ResponseBody, Object&gt;) createResponseConverter(method, retrofit, responseType);</span><br><span class="line">    RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MethodHandler&lt;&gt;(retrofit, requestFactory, callAdapter, responseConverter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Converter&lt;ResponseBody, ?&gt; createResponseConverter(Method method,</span><br><span class="line">                                                                  Retrofit retrofit, Type responseType) &#123;</span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> retrofit.responseConverter(responseType, annotations);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">        <span class="keyword">throw</span> Utils.methodError(e, method, <span class="string">"Unable to create converter for %s"</span>, responseType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进而根据返回数据类型调用Retrofit.responseConverter来创建；下面基本上和CallAdapterFactory基本相同的流程；通过遍历converterFactories链表进行获取相应的解析Converter:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">responseConverter</span><span class="params">(Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">    checkNotNull(type, <span class="string">"type == null"</span>);</span><br><span class="line">    checkNotNull(annotations, <span class="string">"annotations == null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 重点看这个解析函数</span></span><br><span class="line">        Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">                converterFactories.get(i).fromResponseBody(type, annotations);</span><br><span class="line">        <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            <span class="keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"Could not locate ResponseBody converter for "</span>)</span><br><span class="line">            .append(type)</span><br><span class="line">            .append(<span class="string">". Tried:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (Converter.Factory converterFactory : converterFactories) &#123;</span><br><span class="line">        builder.append(<span class="string">"\n * "</span>).append(converterFactory.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要的逻辑在：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重点看这个解析函数</span></span><br><span class="line">        Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">                converterFactories.get(i).fromResponseBody(type, annotations);</span><br><span class="line">这里的converterFactories.get(i)即是通过GsonConverterFactory.create()创建的GSON转换器；来看其具体细节；</span><br></pre></td></tr></table></figure></p>
<h4 id="3）GsonConverterFactory："><a href="#3）GsonConverterFactory：" class="headerlink" title="3）GsonConverterFactory："></a>3）GsonConverterFactory：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonConverterFactory</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Create an instance using a default &#123;<span class="doctag">@link</span> Gson&#125; instance for conversion. Encoding to JSON and</span><br><span class="line">   * decoding from JSON (when no charset is specified by a header) will use UTF-8.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GsonConverterFactory <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> Gson());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Create an instance using &#123;<span class="doctag">@code</span> gson&#125; for conversion. Encoding to JSON and</span><br><span class="line">   * decoding from JSON (when no charset is specified by a header) will use UTF-8.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GsonConverterFactory <span class="title">create</span><span class="params">(Gson gson)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GsonConverterFactory(gson);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">GsonConverterFactory</span><span class="params">(Gson gson)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (gson == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"gson == null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.gson = gson;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; fromResponseBody(Type type, Annotation[] annotations) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GsonResponseBodyConverter&lt;&gt;(gson, type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Converter&lt;?, RequestBody&gt; toRequestBody(Type type, Annotation[] annotations) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GsonRequestBodyConverter&lt;&gt;(gson, type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这个Factory很简单，就是持有了一个GSON实例对象；<br>上面调用了fromResponseBody，这里根据returntype来创建一个GsonRequestBodyConverter：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonRequestBodyConverter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">T</span>, <span class="title">RequestBody</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE = MediaType.parse(<span class="string">"application/json; charset=UTF-8"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset UTF_8 = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line"></span><br><span class="line">    GsonRequestBodyConverter(Gson gson, Type type) &#123;</span><br><span class="line">        <span class="keyword">this</span>.gson = gson;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestBody <span class="title">convert</span><span class="params">(T value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Buffer buffer = <span class="keyword">new</span> Buffer();</span><br><span class="line">        Writer writer = <span class="keyword">new</span> OutputStreamWriter(buffer.outputStream(), UTF_8);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            gson.toJson(value, type, writer);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e); <span class="comment">// Writing to Buffer does no I/O.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RequestBody.create(MEDIA_TYPE, buffer.readByteString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其转换函数convert逻辑也较为简单，将工作交给gson就可以了；所以Retrofit的解析工作在okHttp的Call返回结果时，在其okHttp的Callback中进行解析，解析过程也较为简单，通过获取返回类型Returntype，然后使用gson进行解析即可；</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ArrayMapy、SparseArray源码学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/06/ArrayMapy、SparseArray源码学习/" class="article-date">
      <time datetime="2016-05-06T08:39:33.378Z" itemprop="datePublished">2016-05-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/06/ArrayMapy、SparseArray源码学习/">ArrayMapy、SparseArray源码学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>ArrayMap和SparseArray是Android中提供用来替代HashMap实现内存优化的集合类，来具体看下其源码实现：</p>
<h1 id="ArrayMap简单分析"><a href="#ArrayMap简单分析" class="headerlink" title="ArrayMap简单分析"></a>ArrayMap简单分析</h1><h2 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a>存储原理</h2><p>HashMap是使用一个table数组来存储；发生冲突时采用链地址法以链表或者红黑树的形式进行存储；<br>而ArrayMap使用的是两个数组，mHash数组用来存储hash值（顺序存储）；mArray在对应位置存储（比如mHash存储位置为index），偶数位（index&lt;&lt;1）存储key;奇数位(index&lt;&lt;+1)存储value;<br>发生冲突时，mHash把相同的hash组放在一起存储（因为mHash是按照hash值大小顺序来存储的）；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] mHashes;</span><br><span class="line">    Object[] mArray;</span><br><span class="line">    <span class="keyword">int</span> mSize;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayMap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">            mHashes = EmptyArray.INT;</span><br><span class="line">            mArray = EmptyArray.OBJECT;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            allocArrays(capacity);</span><br><span class="line">        &#125;</span><br><span class="line">        mSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加元素put操作"><a href="#添加元素put操作" class="headerlink" title="添加元素put操作"></a>添加元素put操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        hash = <span class="number">0</span>;</span><br><span class="line">        index = indexOfNull();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 根据hash值查找key对应的位置</span></span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = indexOf(key, hash);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 大于0表示该元素已经存在，这里直接覆盖即可</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        index = (index&lt;&lt;<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> V old = (V)mArray[index];</span><br><span class="line">        mArray[index] = value;</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;0表示不存在，取反得到插入位置</span></span><br><span class="line">    index = ~index;</span><br><span class="line">    <span class="comment">// 插入前判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (mSize &gt;= mHashes.length) &#123;</span><br><span class="line">        <span class="comment">// 重新分配空间大小</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = mSize &gt;= (BASE_SIZE*<span class="number">2</span>) ? (mSize+(mSize&gt;&gt;<span class="number">1</span>))</span><br><span class="line">                : (mSize &gt;= BASE_SIZE ? (BASE_SIZE*<span class="number">2</span>) : BASE_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] ohashes = mHashes;</span><br><span class="line">        <span class="keyword">final</span> Object[] oarray = mArray;</span><br><span class="line">        <span class="comment">// 分配数组空间</span></span><br><span class="line">        allocArrays(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原始数组拷贝到新分配的数组中</span></span><br><span class="line">        <span class="keyword">if</span> (mHashes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"put: copy 0-"</span> + mSize + <span class="string">" to 0"</span>);</span><br><span class="line">            System.arraycopy(ohashes, <span class="number">0</span>, mHashes, <span class="number">0</span>, ohashes.length);</span><br><span class="line">            System.arraycopy(oarray, <span class="number">0</span>, mArray, <span class="number">0</span>, oarray.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的空间</span></span><br><span class="line">        freeArrays(ohashes, oarray, mSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单的插入操作</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; mSize) &#123;</span><br><span class="line">        System.arraycopy(mHashes, index, mHashes, index + <span class="number">1</span>, mSize - index);</span><br><span class="line">        System.arraycopy(mArray, index &lt;&lt; <span class="number">1</span>, mArray, (index + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>, (mSize - index) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应位置进行赋值</span></span><br><span class="line">    mHashes[index] = hash;</span><br><span class="line">    mArray[index&lt;&lt;<span class="number">1</span>] = key;</span><br><span class="line">    mArray[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] = value;</span><br><span class="line">    mSize++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>查找插入位置：</strong><br>HashMap是根据key的hashcode，然后将其高低十六位相与hash&amp;（hash&gt;&gt;&gt;16）,进而与table数组的长度length相与（hash&amp;(length-1)）来找到对应的table数组插入位置；<br>而ArrayMap是通过ContainerHelpers的binarySearch即二分查找的方法，根据key的hash值来查找mHash数组（顺序数组），找到对应的index；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分法查找对应位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object key, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = mSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Important fast case: if nothing is in here, nothing to look for.</span></span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ~<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找，查找结果</span></span><br><span class="line">    <span class="keyword">int</span> index = ContainerHelpers.binarySearch(mHashes, N, hash);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the hash code wasn't found, then we have no entry for this key.</span></span><br><span class="line">    <span class="comment">// &lt;0表示没有查找到</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决冲突，双向进行查找一次相同的hash值，比较key值是否匹配</span></span><br><span class="line">    <span class="comment">// If the key at the returned index matches, that's what we want.</span></span><br><span class="line">    <span class="keyword">if</span> (key.equals(mArray[index&lt;&lt;<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search for a matching key after the index.</span></span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">for</span> (end = index + <span class="number">1</span>; end &lt; N &amp;&amp; mHashes[end] == hash; end++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.equals(mArray[end &lt;&lt; <span class="number">1</span>])) <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search for a matching key before the index.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; mHashes[i] == hash; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.equals(mArray[i &lt;&lt; <span class="number">1</span>])) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Key not found -- return negative value indicating where a</span></span><br><span class="line">    <span class="comment">// new entry for this key should go.  We use the end of the</span></span><br><span class="line">    <span class="comment">// hash chain to reduce the number of array entries that will</span></span><br><span class="line">    <span class="comment">// need to be copied when inserting.</span></span><br><span class="line">    <span class="keyword">return</span> ~end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>简单的二分查找：</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is Arrays.binarySearch(), but doesn't do any argument validation.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> size, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> midVal = array[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (midVal &lt; value) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; value) &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;  <span class="comment">// value found</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ~lo;  <span class="comment">// value not present</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>冲突解决：</strong><br>HashMap是采用遍历链表来实现；而ArrayMap的mHash表中可能存在多个相同的hash值，即冲突；它通过二分查找，找到相应的一个相等值，然后以这个值为中心，分别向前向后遍历，比较对应的key值是否相等；</p>
<p><strong>继续看前面的put过程：</strong><br>未找到情况：当没有找到对应的hash值，或者相同的hash，但没有找到相等的key的情况，这个时候，查找结果index表示待插入的位置，未找到返回index的取反（~index）;便于插入操作判断是进行插入还是重写；</p>
<p><strong>覆盖操作：</strong><br>如果index&gt;=0表示当期key值已存在，则需要进行覆盖，将mArray[(index&lt;&lt;1) + 1]即value赋值为新的value值，然后返回old value值；<br>如果index&lt;0，表示需要执行插入操作，~index即为新元素要插入的位置；</p>
<p><strong>扩充容量：</strong><br>再插入之前，首先判断当前存储空间是否足够，HashMap的扩容时机是总空间超过容量<em>状态因子时，而ArrayMap是当mHash的大小超过MAX_SIZE，即进行扩容，扩容的算法为：<br>n = mSize &gt;= (BASE_SIZE</em>2) ? (mSize+(mSize&gt;&gt;1))<br>        : (mSize &gt;= BASE_SIZE ? (BASE_SIZE*2) : BASE_SIZE);<br>BASE_SIZE=4;即容量大于8的时候，扩容1.5倍；容量大于4小于8时，直接分配空间为8；否则分配空间为4；<br>扩充容量的操作和ArrayList差不多，都是操作数组进行复制。注意这里mHash和mArray都要复制；</p>
<p><strong>插入操作：</strong><br>插入操作也是简单的数组已知index进行插入问题，简单的arraycopy；</p>
<h2 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h2><p>较为简单，通过mHash数组获取存储位置，&lt;0表示没有找到，否则返回value值即可；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = indexOfKey(key);</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> ? (V)mArray[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="remove操作"><a href="#remove操作" class="headerlink" title="remove操作"></a>remove操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找对应的index进行remove</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = indexOfKey(key);</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> removeAt(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Remove the key/value mapping at the given index.</span><br><span class="line"> * <span class="doctag">@param</span> index The desired index, must be between 0 and &#123;<span class="doctag">@link</span> #size()&#125;-1.</span><br><span class="line"> * <span class="doctag">@return</span> Returns the value that was stored at this index.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object old = mArray[(index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (mSize &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Now empty.</span></span><br><span class="line">        <span class="comment">// 删除之后数组中元素就为空了，所以进行空间释放</span></span><br><span class="line">        freeArrays(mHashes, mArray, mSize);</span><br><span class="line">        mHashes = EmptyArray.INT;</span><br><span class="line">        mArray = EmptyArray.OBJECT;</span><br><span class="line">        mSize = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果空余空间过多，将要收缩空间</span></span><br><span class="line">        <span class="keyword">if</span> (mHashes.length &gt; (BASE_SIZE*<span class="number">2</span>) &amp;&amp; mSize &lt; mHashes.length/<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// Shrunk enough to reduce size of arrays.  We don't allow it to</span></span><br><span class="line">            <span class="comment">// shrink smaller than (BASE_SIZE*2) to avoid flapping between</span></span><br><span class="line">            <span class="comment">// that and BASE_SIZE.</span></span><br><span class="line">            <span class="comment">// 收缩空间大小</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> n = mSize &gt; (BASE_SIZE*<span class="number">2</span>) ? (mSize + (mSize&gt;&gt;<span class="number">1</span>)) : (BASE_SIZE*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] ohashes = mHashes;</span><br><span class="line">            <span class="keyword">final</span> Object[] oarray = mArray;</span><br><span class="line">            allocArrays(n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 简单的数组元素删除操作</span></span><br><span class="line">            mSize--;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"remove: copy from 0-"</span> + index + <span class="string">" to 0"</span>);</span><br><span class="line">                System.arraycopy(ohashes, <span class="number">0</span>, mHashes, <span class="number">0</span>, index);</span><br><span class="line">                System.arraycopy(oarray, <span class="number">0</span>, mArray, <span class="number">0</span>, index &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; mSize) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"remove: copy from "</span> + (index+<span class="number">1</span>) + <span class="string">"-"</span> + mSize</span><br><span class="line">                        + <span class="string">" to "</span> + index);</span><br><span class="line">                System.arraycopy(ohashes, index + <span class="number">1</span>, mHashes, index, mSize - index);</span><br><span class="line">                System.arraycopy(oarray, (index + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>, mArray, index &lt;&lt; <span class="number">1</span>,</span><br><span class="line">                        (mSize - index) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mSize--;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; mSize) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"remove: move "</span> + (index+<span class="number">1</span>) + <span class="string">"-"</span> + mSize</span><br><span class="line">                        + <span class="string">" to "</span> + index);</span><br><span class="line">                System.arraycopy(mHashes, index + <span class="number">1</span>, mHashes, index, mSize - index);</span><br><span class="line">                System.arraycopy(mArray, (index + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>, mArray, index &lt;&lt; <span class="number">1</span>,</span><br><span class="line">                        (mSize - index) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mArray[mSize &lt;&lt; <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">            mArray[(mSize &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (V)old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayMap的remove操作，除了将元素从数组指定位置删除之外；当数组的空余空间过多时，还需要对空间进行紧缩。<br>紧缩的时机是mHashes.length &gt; (BASE_SIZE*2) &amp;&amp; mSize &lt; mHashes.length/3；<br>即mHash数组的容量大于8，并且当前存储的元素不足总空间的三分之一，则进行紧缩，来节省内存使用。</p>
<h1 id="SparseArray简单分析："><a href="#SparseArray简单分析：" class="headerlink" title="SparseArray简单分析："></a>SparseArray简单分析：</h1><p>SparseArray是用来替代HashpMap<integer,xxx>的，即key的类型为Integer，ArrayMap避免了int的自动装箱操作，和ArrayMap的原理大致相同，也是使用了两个数组mKeys、mValues来分别存储key值和value值。避免了对int类型的key再进行Hash。<br>同样查找元素的操作也是通过二分法，基本原理和ArrayMap大致相同；这里有个区别是，当删除元素时，并不立即将对应key删除，然后占一个空位便于以后今后复用；当空间紧张时，再进行统一删除，避免了频繁的数组移动操作；<br><strong>1）put操作：</strong></integer,xxx></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 二分查找位置</span></span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到对应元素</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mValues[i] = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = ~i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里是进行复用之前已经删过的元素</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class="line">            mKeys[i] = key;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果数组空间不够继续存储时，对原数组进行GC</span></span><br><span class="line">        <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">            gc();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Search again because indices may have changed.</span></span><br><span class="line">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行插入操作</span></span><br><span class="line">        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</span><br><span class="line">        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">        mSize++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到和ArrayMap基本相同，也是通过二分查找找到对应的存储位置，然后执行插入，只不过这里多个一个删除元素复用的情况；来看一下删除的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    delete(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mValues[i] != DELETED) &#123;</span><br><span class="line">            mValues[i] = DELETED;</span><br><span class="line">            mGarbage = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Removes the mapping at the specified index.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mValues[index] != DELETED) &#123;</span><br><span class="line">        mValues[index] = DELETED;</span><br><span class="line">        mGarbage = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到删除逻辑中只是将要删除的元素的value值设置成了一个DELETE的空对象，并未进行移位删除操作；它的移位删除操作统一放在了put里面数组空间不够用时进行的gc函数中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Log.e("SparseArray", "gc start with " + mSize);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = mSize;</span><br><span class="line">    <span class="keyword">int</span> o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] keys = mKeys;</span><br><span class="line">    Object[] values = mValues;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Object val = values[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val != DELETED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != o) &#123;</span><br><span class="line">                keys[o] = keys[i];</span><br><span class="line">                values[o] = val;</span><br><span class="line">                values[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            o++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mGarbage = <span class="keyword">false</span>;</span><br><span class="line">    mSize = o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Log.e("SparseArray", "gc end with " + mSize);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的数组紧缩操作，从前往后扫描，将非DELETE元素通过交换紧缩到前面空间中来；</p>
<p>因此综上来看，ArrayMap和SparseMap都是通过数组来实现的，一个数组存储hash值（key值），用以通过二分查找查找key对应的存储位置；相对于HashMap的查询效率O(1)而言，ArrayMap和 SparseMap的查询效率O(lgn)并不出色，而且涉及到大量的数组移位操作；但是ArrayMap和 SparseMap最大的好处是节省空间，而且提供了良好的及时进行空间紧缩，特别适合Android这些内存空间比较紧张的开发环境。而SparseMap是对应HashMap特殊情况的优化，在key为Integer时，避免了装箱操作。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016 流云易采
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>